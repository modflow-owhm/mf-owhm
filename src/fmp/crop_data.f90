!
!#########################################################################################################
!
MODULE CROP_DATA_FMP_MODULE
  !
  USE    FMP_DIMENSION_MODULE, ONLY: FMP_DIMENSION
  USE     WBS_DATA_FMP_MODULE, ONLY:     WBS_DATA
  USE    SOIL_DATA_FMP_MODULE, ONLY:    SOIL_DATA
  USE CLIMATE_DATA_FMP_MODULE, ONLY: CLIMATE_DATA
  !
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN 
  USE GLOBAL,       ONLY: HNEW_OLD, UPLAY, UPLAY_IDX, LENUNI, WTABLE, WTABLE_OLD !, HNEW
  USE GWFBASMODULE, ONLY: HDRY
  !
  USE CONSTANTS
  USE ULOAD_AND_SFAC_INTERFACE
  USE SORT_INTERFACE,                   ONLY: SORT
  USE SET_ARRAY_INTERFACE,              ONLY: SET_ZERO
  !USE RELAX_INTERFACE,                  ONLY: RELAX_IT
  USE ERROR_INTERFACE,                  ONLY: STOP_ERROR, WARNING_MESSAGE, FILE_IO_ERROR
  USE PARSE_WORD_INTERFACE,             ONLY: PARSE_WORD, PARSE_WORD_UP
  USE STRINGS,                          ONLY: GET_NUMBER, GET_INTEGER
  USE UTIL_INTERFACE,                   ONLY: SET_NEAR_ZERO, NEAR_ZERO, NOT_NEAR_ZERO
  USE NUM2STR_INTERFACE,                ONLY: NUM2STR
  USE ALLOC_INTERFACE,                  ONLY: ALLOC
  USE GENERIC_OUTPUT_FILE_INSTRUCTION,  ONLY: GENERIC_OUTPUT_FILE
  USE GENERIC_BLOCK_READER_INSTRUCTION, ONLY: GENERIC_BLOCK_READER
  USE IXJ_INSTRUCTION,                  ONLY: IXJ_SINGLE_ENTRY!, IXJ_STRUCTURE
  USE LIST_ARRAY_INPUT_INTERFACE,       ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE WARNING_TYPE_INSTRUCTION,         ONLY: WARNING_TYPE
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: CROP_DATA, INITIALIZE_CROP_DATA
  !
  !TYPE PSI_VEC
  !    DOUBLE PRECISION,DIMENSION(4):: PSI
  !END TYPE
  !
  TYPE CROP_PROP  !FALLOW FRACTION?
      INTEGER:: N=Z, ID, LD
      !LOGICAL:: FRACTION =.FALSE.
      INTEGER,         DIMENSION(:,:),ALLOCATABLE:: RC
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: T_CONCEPT !0 - No T, 1 Root Pressure, 2 Linear Uptake, 3 No 
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: ROOT
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FRAC
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: Kc
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CF
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CU
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FTR  
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FEP
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FEI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DEMAND
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DEMAND_EXT
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DEMAND_EXT_INI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: ADMD
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CON_PRECIP_FRAC
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FIESWP 
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FIESWI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: PSI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CIR
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CIR_INI
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: RNOFF
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DPERC
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: RNOFF_Peff
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: RNOFF_EXT
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: DPERC_EXT
      !
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: GW_INTER
      LOGICAL,         DIMENSION(:),  ALLOCATABLE:: NOT_FALLOW 
      LOGICAL,         DIMENSION(:),  ALLOCATABLE:: NOT_FALLOW_SP
      !
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: FID
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: IRR
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: FALLOW_RANK
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: EFF  !IRRIGATION EFFECIENCY
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: ADRF  !FRACTION OF EXTRA IRRIGATION THAT BECOMES RUNOFF
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: EFL  !EVAPORATIVE LOSS FRACTION
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: EGW, TGW, EGWA, TGWA, TPPOT, EPPOT,EP, TSURF, TI, TP, ANOX_LOSS, SOIL_LOSS, PRECIP, TI_BAK
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: PRECIP_POT_TRAN
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: PRECIP_POT_EVAP
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: AREA
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: GSE
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: SS  !GSE - ROOT
      !DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: PSIA
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: LXX   !GSE - ROOT - CAP  -- Lower Extinction Elevation
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: XX    !GSE - CAP
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: UXX   !Upper Extinction Elevation
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: MXX   !Middle Extinction Elevation
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: CECT
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: THI, THD  !TRANSPIRATION INDEPENDENT OF HEAD AND DEPENDENT ON HEAD...USED FOR FD EQUATIONS
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: EHI, EHD
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: POND
      !
      CONTAINS
      !
      GENERIC::              COPY_INPUT => COPY_CROP_INPUT_TO_CROP_PROP,COPY_CROP_INPUT_TO_CROP_PROP_INT
      PROCEDURE, PASS(CPR):: SETUP_UXX_MXX => CALC_CROP_OPTIMAL_UPTAKE_PRESSURE!(CPR, SOIL, MLT, ONLY_K)
      PROCEDURE, PASS(CPR):: DESTROY    => DEALLOCATE_CROP_PROP
      !
      PROCEDURE, PASS(CPR), PRIVATE:: COPY_CROP_INPUT_TO_CROP_PROP
      PROCEDURE, PASS(CPR), PRIVATE:: COPY_CROP_INPUT_TO_CROP_PROP_INT
      FINAL:: DEALLOCATE_CROP_PROP_FINAL
  END TYPE
  !
  TYPE CROP_DATA
      INTEGER:: NCROP = Z, NIRRG=Z
      INTEGER:: NROW, NCOL
      INTEGER:: NCROP_ELEV
      INTEGER:: CROP_NAME_LEN
      INTEGER:: IOUT=Z, LOUT=Z
      INTEGER:: ITER_CALC_EGW_TGW_LOCK = inf_I
      INTEGER:: ITER_AVE_HEAD = inf_I
      LOGICAL:: HAS_AVE_HEAD = FALSE
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: AVE_HEAD
      !LOGICAL:: FRACTION = FALSE
      LOGICAL:: MULTI_CROP_CELLS    = FALSE
      LOGICAL:: TFR_READ            = FALSE
      LOGICAL:: CHECK_BARE          = FALSE
      LOGICAL:: GW_ROOT_INTERACTION = TRUE
      LOGICAL:: HAS_Kc              = FALSE
      LOGICAL:: HAS_POND            = FALSE
      LOGICAL:: HAS_PSI             = FALSE
      LOGICAL:: HAS_Pe              = FALSE
      LOGICAL:: HAS_DEMAND_EXT      = FALSE
      LOGICAL:: DEMAND_EXT_FLUX     = FALSE
      LOGICAL:: TPOT_SHIFT_EPOT     = TRUE
      !LOGICAL:: PCF_IS_FRAC         = TRUE
      INTEGER,             DIMENSION(:,:),ALLOCATABLE:: CRPID
      TYPE(CROP_PROP),     DIMENSION(:),  ALLOCATABLE:: CROP
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: BARE_FRAC, BARE_GSE, BARE_FRAC_RUNOFF, BARE_TOT_PRECEP, BARE_PRECEP_EXCESS, BARE_RNOFF_Peff, BARE_EVAP, BARE_POT_EVAP, BARE_EVAP_EHI, BARE_EVAP_EHD, BARE_EVAP_PRECIP!, BARE_FRAC_PRECIP !BARE/FALLOW FRACTION of PRECIP to RUNOFF
      DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: TTOT, ETOT, TGWA, EGWA
      CHARACTER(20),       DIMENSION(:),  ALLOCATABLE:: CROP_NAME  !OPTIONAL
      INTEGER,             DIMENSION(:),  ALLOCATABLE:: CROP_SCAPE_ID
      !
      DOUBLE PRECISION:: MIN_BARE    = DZ  !MINIMUM BARE FRACTION ALLOWED
      DOUBLE PRECISION:: MLT               !CONVERSION FROM MODEL UNIT TO CM
      DOUBLE PRECISION:: RELAX_FACT  = UNO !RELAXATION FACTOR LOADED IN CROP BLOCK AND APPLIED BETWEEN TWO ITERATIOSN FOR DETERMINING GROUNDWATER ROOT CROP INTERACTION
      DOUBLE PRECISION:: RELAX       = UNO !RELAXATION FACTOR APPLIED BETWEEN TWO ITERATIOSN FOR DETERMINING GROUNDWATER ROOT CROP INTERACTION
      DOUBLE PRECISION:: HNEW_FACTOR = UNO
      !DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: CIR
      !DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: ARRAY
      !DOUBLE PRECISION,    DIMENSION(:,:),ALLOCATABLE:: LIST
      !
      TYPE(LIST_ARRAY_INPUT_INT):: CID
      TYPE(LIST_ARRAY_INPUT_INT):: IRR
      TYPE(LIST_ARRAY_INPUT_INT):: GW_INTER
      TYPE(LIST_ARRAY_INPUT_INT):: PRINT_CROP
      TYPE(LIST_ARRAY_INPUT_INT):: FEI_CHECK
      TYPE(LIST_ARRAY_INPUT_INT):: ZERO_CU_TO_BARE
      TYPE(LIST_ARRAY_INPUT):: ROOT
      TYPE(LIST_ARRAY_INPUT):: FRAC
      TYPE(LIST_ARRAY_INPUT):: Kc
      TYPE(LIST_ARRAY_INPUT):: CF
      TYPE(LIST_ARRAY_INPUT):: FTR  
      TYPE(LIST_ARRAY_INPUT):: FEI
      !TYPE(LIST_ARRAY_INPUT):: CON_PRECIP_FRAC 
      TYPE(LIST_ARRAY_INPUT):: FIESWP 
      TYPE(LIST_ARRAY_INPUT):: FIESWI
      TYPE(LIST_ARRAY_INPUT):: PSI
      TYPE(LIST_ARRAY_INPUT):: POND
      TYPE(LIST_ARRAY_INPUT):: ADMD
      !
      TYPE(LIST_ARRAY_INPUT_INT):: GSE_CID
      !TYPE(LIST_ARRAY_INPUT_INT):: GSE_SFR
      TYPE(LIST_ARRAY_INPUT)::     SPEC_GSE
      TYPE(LIST_ARRAY_INPUT)::     GSE_OFFSET
      !TYPE(LIST_ARRAY_INPUT):: DEMAND
      !TYPE(LIST_ARRAY_INPUT):: FEP
      !
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BYFARMCROP
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BYFARM
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BYCROP
      TYPE(GENERIC_OUTPUT_FILE):: OUT_DETAIL
      TYPE(GENERIC_OUTPUT_FILE):: OUT_ALL
      TYPE(GENERIC_OUTPUT_FILE):: OUT_BARE
      TYPE(GENERIC_OUTPUT_FILE):: OUT_INPUT
      TYPE(GENERIC_OUTPUT_FILE):: OUT_ET
      INTEGER,                  DIMENSION(:,:), ALLOCATABLE:: OUT_CROP_RC  !(R, C)
      TYPE(GENERIC_OUTPUT_FILE), DIMENSION(:),  ALLOCATABLE:: OUT_CROP
      !TYPE(GENERIC_OUTPUT_FILE):: OUT_ROOT
      !
      CONTAINS
      !
      PROCEDURE, PASS(CDAT):: PARSE_CROP_ROW_COL
      PROCEDURE, PASS(CDAT):: NEXT                 => SETUP_NEXT_STRESS_PERIOD
      PROCEDURE, PASS(CDAT):: NEXT_TS              => SETUP_NEXT_TIME_STEP
      PROCEDURE, PASS(CDAT):: SETUP_CROP_EFFICIENCY
      PROCEDURE, PASS(CDAT):: COPY_AND_SETUP_IRRIGATION => COPY_AND_SETUP_IRRIGATION_INPUT_TO_CROP_PROP
      PROCEDURE, PASS(CDAT):: CALC_WBS_IRRIGATED_AREA
      PROCEDURE, PASS(CDAT):: CALC_EGW_TGW
      PROCEDURE, PASS(CDAT):: CALC_CIR_DEMAND
      PROCEDURE, PASS(CDAT):: INIT_EXTERNAL_DEMAND !SET TO ZERO
      PROCEDURE, PASS(CDAT):: ADD_EXTERNAL_DEMAND!(DMD,I,K,F,USE_AREA)
      PROCEDURE, PASS(CDAT):: SET_EXTERNAL_DEMAND_INI
      PROCEDURE, PASS(CDAT):: ADD_CROP_DEMAND_TO_ARRAY
      PROCEDURE, PASS(CDAT):: ADD_CROP_ADDED_DEMAND_BYWBS
      PROCEDURE, PASS(CDAT):: SET_WBS_ADDED_DEMAND!(WBS)
      PROCEDURE, PASS(CDAT):: NOT_FALLOW_RESET
      PROCEDURE, PASS(CDAT):: APPLY_DEFICIENCY_SCENARIO
      PROCEDURE, PASS(CDAT):: CALC_INEFFICIENT_LOSSES
      PROCEDURE, PASS(CDAT):: UPDATE_TWGA_EGWA_BARE_EVAP
      PROCEDURE, PASS(CDAT):: CALC_TTOT_ETOT_TGWA_EGWA_TOTALS
      PROCEDURE, PASS(CDAT):: CALC_WBS_EFFICIENCY
      PROCEDURE, PASS(CDAT):: SUBTRACT_TGWA_EGWA_FROM_FNRCH!(WBS)
      !
      PROCEDURE, PASS(CDAT):: PRINT_OUT_BYFARM_BYCROP
      PROCEDURE, PASS(CDAT):: PRINT_OUT_BYFARM!(WBS, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_BYCROP!(WBS, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_DETAIL_CROP!(WBS, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_BARE!(WBS, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_INPUT!(WBS, KPER, KSTP)
      PROCEDURE, PASS(CDAT):: PRINT_OUT_ALL_CROP
      PROCEDURE, PASS(CDAT):: PRINT_OUT_SPECIFIED
      PROCEDURE, PASS(CDAT):: PRINT_OUT_ET
      !
      !PROCEDURE, PASS(CDAT):: SET_PRECIP_POTENTIAL => SETUP_CROP_PRECIP_POTENTIAL
      FINAL:: DEALLOCATE_CROP_DATA_FINAL
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_CROP_DATA_FINAL(CDAT)
    TYPE(CROP_DATA)::CDAT
    !
    IF(ALLOCATED(CDAT%CROP) ) DEALLOCATE(CDAT%CROP)
    !
    IF(ALLOCATED(CDAT%CRPID)) DEALLOCATE(CDAT%CRPID)
    !
    IF(ALLOCATED(CDAT%CROP_NAME)    ) DEALLOCATE(CDAT%CROP_NAME)
    IF(ALLOCATED(CDAT%CROP_SCAPE_ID)) DEALLOCATE(CDAT%CROP_SCAPE_ID)
    !
    IF(ALLOCATED(CDAT%BARE_FRAC         )) DEALLOCATE(CDAT%BARE_FRAC)
    IF(ALLOCATED(CDAT%BARE_GSE          )) DEALLOCATE(CDAT%BARE_GSE)
    IF(ALLOCATED(CDAT%BARE_FRAC_RUNOFF  )) DEALLOCATE(CDAT%BARE_FRAC_RUNOFF)
    IF(ALLOCATED(CDAT%BARE_PRECEP_EXCESS)) DEALLOCATE(CDAT%BARE_PRECEP_EXCESS)
    IF(ALLOCATED(CDAT%BARE_RNOFF_Peff)   ) DEALLOCATE(CDAT%BARE_RNOFF_Peff)
    IF(ALLOCATED(CDAT%BARE_TOT_PRECEP)   ) DEALLOCATE(CDAT%BARE_TOT_PRECEP)
    IF(ALLOCATED(CDAT%BARE_POT_EVAP)     ) DEALLOCATE(CDAT%BARE_POT_EVAP)
    IF(ALLOCATED(CDAT%BARE_EVAP    )     ) DEALLOCATE(CDAT%BARE_EVAP)
    IF(ALLOCATED(CDAT%BARE_EVAP_EHI)     ) DEALLOCATE(CDAT%BARE_EVAP_EHI)
    IF(ALLOCATED(CDAT%BARE_EVAP_EHD)     ) DEALLOCATE(CDAT%BARE_EVAP_EHD)
    IF(ALLOCATED(CDAT%BARE_EVAP_PRECIP)  ) DEALLOCATE(CDAT%BARE_EVAP_PRECIP)
    IF(ALLOCATED(CDAT%TTOT)              ) DEALLOCATE(CDAT%TTOT)
    IF(ALLOCATED(CDAT%ETOT)              ) DEALLOCATE(CDAT%ETOT)
    IF(ALLOCATED(CDAT%TGWA)              ) DEALLOCATE(CDAT%TGWA)
    IF(ALLOCATED(CDAT%OUT_CROP_RC)        ) DEALLOCATE(CDAT%OUT_CROP_RC)
    IF(ALLOCATED(CDAT%OUT_CROP)           ) DEALLOCATE(CDAT%OUT_CROP)
    !IF(ALLOCATED(CDAT%BARE_FRAC_PRECIP)) DEALLOCATE(CDAT%BARE_FRAC_PRECIP)
    !
    IF(ALLOCATED(CDAT%AVE_HEAD)        ) DEALLOCATE(CDAT%AVE_HEAD)
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_CROP_PROP_FINAL(CPR)
    TYPE(CROP_PROP)::CPR
    !
    CALL DEALLOCATE_CROP_PROP(CPR)
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CROP_PROP(CPR)
    CLASS(CROP_PROP), INTENT(INOUT)::CPR
    CPR%N=Z
    IF(ALLOCATED(CPR%RC             ))  DEALLOCATE(CPR%RC             )
    IF(ALLOCATED(CPR%T_CONCEPT      ))  DEALLOCATE(CPR%T_CONCEPT      )
    IF(ALLOCATED(CPR%ROOT           ))  DEALLOCATE(CPR%ROOT           )
    IF(ALLOCATED(CPR%FRAC           ))  DEALLOCATE(CPR%FRAC           )
    IF(ALLOCATED(CPR%Kc             ))  DEALLOCATE(CPR%Kc             )
    IF(ALLOCATED(CPR%CF             ))  DEALLOCATE(CPR%CF             )
    IF(ALLOCATED(CPR%CU             ))  DEALLOCATE(CPR%CU             )
    IF(ALLOCATED(CPR%FTR            ))  DEALLOCATE(CPR%FTR            )
    IF(ALLOCATED(CPR%FEI            ))  DEALLOCATE(CPR%FEI            )
    IF(ALLOCATED(CPR%DEMAND         ))  DEALLOCATE(CPR%DEMAND         )
    IF(ALLOCATED(CPR%ADRF           ))  DEALLOCATE(CPR%ADRF           )
    IF(ALLOCATED(CPR%DEMAND_EXT     ))  DEALLOCATE(CPR%DEMAND_EXT     )
    IF(ALLOCATED(CPR%DEMAND_EXT_INI ))  DEALLOCATE(CPR%DEMAND_EXT_INI )
    !IF(ALLOCATED(CPR%CON_PRECIP_FRAC))  DEALLOCATE(CPR%CON_PRECIP_FRAC)
    IF(ALLOCATED(CPR%FIESWP         ))  DEALLOCATE(CPR%FIESWP         )
    IF(ALLOCATED(CPR%FIESWI         ))  DEALLOCATE(CPR%FIESWI         )
    IF(ALLOCATED(CPR%PSI            ))  DEALLOCATE(CPR%PSI            )
    IF(ALLOCATED(CPR%CIR            ))  DEALLOCATE(CPR%CIR            )
    IF(ALLOCATED(CPR%CIR_INI        ))  DEALLOCATE(CPR%CIR_INI        )
    IF(ALLOCATED(CPR%RNOFF          ))  DEALLOCATE(CPR%RNOFF          )
    IF(ALLOCATED(CPR%DPERC          ))  DEALLOCATE(CPR%DPERC          )
    IF(ALLOCATED(CPR%RNOFF_EXT      ))  DEALLOCATE(CPR%RNOFF_EXT      )
    IF(ALLOCATED(CPR%RNOFF_Peff     ))  DEALLOCATE(CPR%RNOFF_Peff     )
    IF(ALLOCATED(CPR%DPERC_EXT      ))  DEALLOCATE(CPR%DPERC_EXT      )
    IF(ALLOCATED(CPR%GW_INTER       ))  DEALLOCATE(CPR%GW_INTER       )
    IF(ALLOCATED(CPR%NOT_FALLOW     ))  DEALLOCATE(CPR%NOT_FALLOW     )
    IF(ALLOCATED(CPR%NOT_FALLOW_SP  ))  DEALLOCATE(CPR%NOT_FALLOW_SP  )
    IF(ALLOCATED(CPR%FID            ))  DEALLOCATE(CPR%FID            )
    IF(ALLOCATED(CPR%IRR            ))  DEALLOCATE(CPR%IRR            )
    IF(ALLOCATED(CPR%FALLOW_RANK    ))  DEALLOCATE(CPR%FALLOW_RANK    )
    IF(ALLOCATED(CPR%EFF            ))  DEALLOCATE(CPR%EFF            )
    IF(ALLOCATED(CPR%ADRF           ))  DEALLOCATE(CPR%ADRF           )
    !IF(ALLOCATED(CPR%EFL            ))  DEALLOCATE(CPR%EFL            )
    IF(ALLOCATED(CPR%EGW            ))  DEALLOCATE(CPR%EGW            )
    IF(ALLOCATED(CPR%TGW            ))  DEALLOCATE(CPR%TGW            )
    IF(ALLOCATED(CPR%EGWA           ))  DEALLOCATE(CPR%EGWA           )
    IF(ALLOCATED(CPR%TGWA           ))  DEALLOCATE(CPR%TGWA           )
    IF(ALLOCATED(CPR%TPPOT          ))  DEALLOCATE(CPR%TPPOT          )
    IF(ALLOCATED(CPR%EPPOT          ))  DEALLOCATE(CPR%EPPOT          )
    IF(ALLOCATED(CPR%EP             ))  DEALLOCATE(CPR%EP             )
    IF(ALLOCATED(CPR%PRECIP         ))  DEALLOCATE(CPR%PRECIP         )
    IF(ALLOCATED(CPR%TSURF          ))  DEALLOCATE(CPR%TSURF          )
    IF(ALLOCATED(CPR%TI             ))  DEALLOCATE(CPR%TI             )
    IF(ALLOCATED(CPR%TI_BAK         ))  DEALLOCATE(CPR%TI_BAK         )
    IF(ALLOCATED(CPR%TP             ))  DEALLOCATE(CPR%TP             )
    IF(ALLOCATED(CPR%ANOX_LOSS      ))  DEALLOCATE(CPR%ANOX_LOSS      )
    IF(ALLOCATED(CPR%SOIL_LOSS      ))  DEALLOCATE(CPR%SOIL_LOSS      )
    IF(ALLOCATED(CPR%AREA           ))  DEALLOCATE(CPR%AREA           )
    IF(ALLOCATED(CPR%GSE            ))  DEALLOCATE(CPR%GSE            )
    IF(ALLOCATED(CPR%SS             ))  DEALLOCATE(CPR%SS             )
    IF(ALLOCATED(CPR%LXX            ))  DEALLOCATE(CPR%LXX            )
    IF(ALLOCATED(CPR%XX             ))  DEALLOCATE(CPR%XX             )
    IF(ALLOCATED(CPR%UXX            ))  DEALLOCATE(CPR%UXX            )
    IF(ALLOCATED(CPR%MXX            ))  DEALLOCATE(CPR%MXX            )
    IF(ALLOCATED(CPR%CECT           ))  DEALLOCATE(CPR%CECT           )
    IF(ALLOCATED(CPR%THI            ))  DEALLOCATE(CPR%THI            )
    IF(ALLOCATED(CPR%THD            ))  DEALLOCATE(CPR%THD            )
    IF(ALLOCATED(CPR%EHI            ))  DEALLOCATE(CPR%EHI            )
    IF(ALLOCATED(CPR%EHD            ))  DEALLOCATE(CPR%EHD            )
    IF(ALLOCATED(CPR%POND           ))  DEALLOCATE(CPR%POND           )
    IF(ALLOCATED(CPR%ADMD           ))  DEALLOCATE(CPR%ADMD           )
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_CROP_DATA( BL, CDAT, LINE, FDIM, HAS_SFR )  !NFARM, IFID
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(CROP_DATA),            INTENT(INOUT):: CDAT
    CHARACTER(*),                INTENT(INOUT):: LINE
    CLASS(FMP_DIMENSION),        INTENT(IN   ):: FDIM
    LOGICAL,                     INTENT(IN   ):: HAS_SFR
    !INTEGER,                     INTENT(IN   ):: NFARM
    !INTEGER, DIMENSION(:,:),     INTENT(IN   ):: IFID
    INTEGER, DIMENSION(3):: CDIM
    CHARACTER(5):: ERROR
    LOGICAL:: EOF
    INTEGER:: I, LLOC, ISTART, ISTOP, IU, NROW, NCOL, ELV_NROW, PAD, NPRNT_CROP !Z, ONE, 
    !CHARACTER(20), DIMENSION(:), ALLOCATABLE:: CROPNAME, CTMP
    !CHARACTER(20):: NAME
    CHARACTER(6):: BYFARM, BYCROP
    CHARACTER(10):: BYIRRIGATE
    !CHARACTER(4), PARAMETER:: LIST  = 'LIST'
    !CHARACTER(5), PARAMETER:: ARRAY = 'ARRAY'
    !CHARACTER(6), PARAMETER:: STATICKEY = 'STATIC'
    !CHARACTER(9), PARAMETER:: TRANSIENT = 'TRANSIENT'
    TYPE(WARNING_TYPE):: WARN
    LOGICAL:: BINARY, HAS_ADDED
    !
    CALL WARN%INIT()
    !
    WRITE(BL%IOUT,'(/A/)') 'CROP BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    BYFARM = 'BYWBS'
    BYCROP = 'BYCROP'
    BYIRRIGATE = 'BYIRRIGATE'
    HAS_ADDED = FALSE
    !
    !Z = 0
    !ONE=1 
    !TRUE = .TRUE.
    !FALSE= .FALSE.
    NCOL = FDIM%NCOL
    NROW = FDIM%NROW
    ELV_NROW   = NROW
    CDAT%NROW  = NROW
    CDAT%NCOL  = NCOL
    CDAT%NIRRG = FDIM%NIRRG
    CDAT%NCROP = FDIM%NCROP
    CDAT%NCROP_ELEV = FDIM%NCROP_ELEV
    CDAT%IOUT  = BL%IOUT
    CDAT%LOUT  = BL%IOUT
    CDAT%CHECK_BARE = FALSE
    CDAT%HAS_DEMAND_EXT  = FALSE
    CDAT%DEMAND_EXT_FLUX = FALSE
    CDAT%HNEW_FACTOR = FDIM%HNEW_FACTOR
    !CDAT%PCF_IS_FRAC     = TRUE
    CDAT%HAS_Kc = FALSE
    CDAT%ITER_CALC_EGW_TGW_LOCK = inf_I
    CDAT%ITER_AVE_HEAD = inf_I
    NPRNT_CROP = Z
    !
    ALLOCATE(CDAT%TTOT(NCOL,NROW), CDAT%ETOT(NCOL,NROW), CDAT%TGWA(NCOL,NROW), CDAT%EGWA(NCOL,NROW), SOURCE=DZ) !AUTOALLOCATES ALL TO ZERO
    ALLOCATE(CDAT%BARE_FRAC(NCOL,NROW), SOURCE=DZ)
    !
    SELECT CASE (LENUNI)
    CASE(ONE);          CDAT%MLT = 30.48D0  !FOOT
    CASE(TWO);          CDAT%MLT = 100D0    !METER
    CASE(THREE);        CDAT%MLT = 1D0      !CENTIMETER
    CASE DEFAULT;       CDAT%MLT = 1D0      !UNKNOWN
    END SELECT
    !
    CDAT%RELAX_FACT= UNO
    ERROR='ERROR'
    !
    IF(CDAT%NCROP==Z) THEN
        !WRITE(BL%IOUT, '(A)') 'WARNING: NCROP = 0, ARE YOU SURE YOU WANT TO USE FMP WITHOUT ANY CROPS?'
        CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP NCROP = 0, ARE YOU SURE YOU WANT TO USE FMP WITHOUT ANY CROPS???',INLINE=TRUE)
        RETURN
    END IF
    !
    !
    CALL BL%START()
    !
    EOF = TRUE  !USE AS FLAG IF KEYWORD IS FOUND
    CDAT%MULTI_CROP_CELLS = FALSE
    DO I=ONE, BL%NLINE
                    LLOC=ONE
                    CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                    IF (BL%LINE(ISTART:ISTOP)=='MULTI_LAND_USE_PER_CELL' .OR. BL%LINE(ISTART:ISTOP)=='MULTIPLE_LAND_USE_PER_CELL') THEN
                        CDAT%MULTI_CROP_CELLS = TRUE
                        IF(.NOT. EOF) CALL STOP_ERROR(BL%LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. YOU MAY ONLY SPECIFY "SINGLE_LAND_USE_PER_CELL" OR "MULTIPLE_LAND_USE_PER_CELL", BUT NOT BOTH DURING THE SAME SIMULATION.')
                        EOF = FALSE
                    ELSEIF(BL%LINE(ISTART:ISTOP)=='SINGLE_LAND_USE_PER_CELL') THEN
                        CDAT%MULTI_CROP_CELLS = FALSE
                        IF(.NOT. EOF) CALL STOP_ERROR(BL%LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. YOU MAY ONLY SPECIFY "SINGLE_LAND_USE_PER_CELL" OR "MULTIPLE_LAND_USE_PER_CELL", BUT NOT BOTH DURING THE SAME SIMULATION.')
                        EOF = FALSE
                    ELSEIF(BL%LINE(ISTART:ISTOP)=='PRINT') THEN
                        CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
                        IF(BL%LINE(ISTART:ISTOP)=="ROW"      .OR. &
                           BL%LINE(ISTART:ISTOP)=="ROW_COL"  .OR. &
                           BL%LINE(ISTART:ISTOP)=="ROW_COLUMN") NPRNT_CROP = NPRNT_CROP + ONE
                    END IF
                    !
                    CALL BL%NEXT()
    END DO
    !
    IF(NPRNT_CROP > Z) THEN
        ALLOCATE(CDAT%OUT_CROP_RC(TWO, NPRNT_CROP))
        ALLOCATE(CDAT%OUT_CROP   (NPRNT_CROP))
        NPRNT_CROP = Z
    END IF
    !
    IF(EOF) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK FAILED TO IDENTIFY KEYWORD "SINGLE_LAND_USE_PER_CELL" OR "MULTIPLE_LAND_USE_PER_CELL".'//BLN//'IT WILL ASSUME THE KEYWORD "SINGLE_LAND_USE_PER_CELL" AND REQUIRES SPECIFYING LAND USE/CROP ID "LOCATION"s.')
    !
    IF(CDAT%MULTI_CROP_CELLS) THEN
        CDAT%MIN_BARE = NEARZERO_12
    ELSE
        CDAT%MIN_BARE = inf
    END IF
    !
    IF(CDAT%NCROP_ELEV < ONE) CDAT%NCROP_ELEV = CDAT%NCROP
    !
    IF(CDAT%MULTI_CROP_CELLS) THEN
                          NROW     = CDAT%NCROP * NROW !LOAD IN NCROP SETS OF NROWS
                          ELV_NROW = CDAT%NCROP_ELEV * ELV_NROW 
                          CDIM = [3,1,0]
    ELSE
                          CDIM = [2,1,0]
    END IF
    !
    !
    ALLOCATE(CDAT%CROP(CDAT%NCROP))
    DO CONCURRENT(I=ONE:CDAT%NCROP); CDAT%CROP(I)%ID = I
    END DO
    !
    IF (CDAT%MULTI_CROP_CELLS) THEN
        DO CONCURRENT(I=ONE:CDAT%NCROP); CDAT%CROP(I)%LD = ONE + ( (I-ONE) * FDIM%NROW )
        END DO
    ELSE
        CDAT%CROP%LD = ONE
    END IF
    !
    PAD = LEN(NUM2STR(CDAT%NCROP))
    ALLOCATE( CDAT%CROP_NAME(CDAT%NCROP) )
    DO I=ONE, CDAT%NCROP
        CDAT%CROP_NAME(I) = 'CROP_'//NUM2STR(I,PAD,TRUE)
    END DO
    CDAT%CROP_NAME_LEN = MAX(FIVE+PAD,9)
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF, LINE)
    !
    IF(CDAT%NCROP > Z) THEN
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      !CASE ("NCROP")
      !                  CYCLE
      CASE ("CROP_NAME", "NAME")
                        WRITE(BL%IOUT,'(A)') '        NAME              KEYWORD FOUND. NOW USING ULOAD TO READ IN LIST OF CROP NAMES.'
                        IU = Z
                        CALL ULOAD(CDAT%CROP_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
                        !
                        DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP_NAME_LEN<LEN_TRIM(CDAT%CROP_NAME(I)) );  CDAT%CROP_NAME_LEN = LEN_TRIM(CDAT%CROP_NAME(I))
                        END DO
      CASE ("CROPSCAPE")
                        WRITE(BL%IOUT,'(A)') '   CROPSCAPE              KEYWORD FOUND. NOW USING ULOAD TO READ IN LIST OF CROPSCAPE IDs THAT REFER TO EACH CROP.'
                        IU = Z
                        ALLOCATE(CDAT%CROP_SCAPE_ID(CDAT%NCROP))
                        CALL ULOAD(CDAT%CROP_SCAPE_ID, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
      CASE ("LOCATION","CID")
                        WRITE(BL%IOUT,'(A)') '   LOCATION (CID)         KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP IDs.'
                        !
                        IF(CDAT%MULTI_CROP_CELLS) CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. YOU CAN NOT USE THE KEYWORD "LOCATION" WHEN USING THE KEYWORD "MULTI_LAND_USE_PER_CELL". INSTEAD THE LOCATION IS INFERED FROM THE KEYWORD "LAND_USE_AREA_FRACTION".')
                        !
                        CALL CDAT%CID%INIT('CID',       LLOC, LINE, BL%IOUT, BL%IU, Z, Z, NROW, NCOL, BL%SCRATCH, CDIM=[3,0,0])
                        !
                        ALLOCATE(CDAT%CRPID(NCOL,NROW), SOURCE=Z)
      CASE("SINGLE_LAND_USE_PER_CELL","MULTI_LAND_USE_PER_CELL","MULTIPLE_LAND_USE_PER_CELL")
                                     CONTINUE ! DO NOTHING
      CASE ("LAND_USE_AREA_FRACTION")
                        !
                        IF(CDAT%MULTI_CROP_CELLS) THEN
                            WRITE(BL%IOUT,'(A)') '   LAND_USE_AREA_FRACTION  KEYWORD FOUND. MULTIPLE CROP PER CELL INPUT REQUIRES ARRAY STYLE ONLY. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP FRACTIONS (NOTE THAT ARRAY IS [NCROP*NROW,NCOL]).'
                            CALL CDAT%FRAC%INIT('MULTI_FRAC', LLOC, LINE, BL%IOUT, BL%IU,          Z,   Z, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        ELSE
                            WRITE(BL%IOUT,'(A)') '   LAND_USE_AREA_FRACTION KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP FRACTIONS (NOTE THAT ARRAY IS [NROW,NCOL]).'
                            CALL CDAT%FRAC%INIT('SINGLE_FRAC', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        END IF
      CASE ("MAX_ITERATION_CALCULATE_INITIAL_EVAPOTRANSPIRATION")
                        WRITE(BL%IOUT,'(A)') '   MAX_ITERATION_CALCULATE_INITIAL_EVAPOTRANSPIRATION KEYWORD FOUND. NOW LOADING LOADING THE OUTER ITERATION THAT RESULTS IN STOPPING THE INITIAL ESTIMATE OF LAND USE ET.'
                        !
                        CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,CDAT%ITER_CALC_EGW_TGW_LOCK,  MSG='FMP CROP BLOCK "" FAILED TO LOAD THE ACTUAL VALUE.')
      CASE ("ITERATION_USE_AVERAGE_HEAD_FOR_EVAPOTRANSPIRATION")
                        WRITE(BL%IOUT,'(A)') '   ITERATION_START_USE_AVERAGE_HEAD_EVAPOTRANSPIRATION KEYWORD FOUND. NOW LOADING LOADING THE OUTHER ITERATION THAT RESULTS IN STOPPING THE INITIAL ESTIMATE OF LAND USE ET.'
                        !
                        CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,CDAT%ITER_AVE_HEAD,  MSG='FMP CROP BLOCK "" FAILED TO LOAD THE ACTUAL VALUE.')
                        ALLOCATE(CDAT%AVE_HEAD(CDAT%NCOL,CDAT%NROW), SOURCE=DZ)
      CASE ("MIN_BARE_FRACTION")
                        WRITE(BL%IOUT,'(A)') '   MIN_BARE_FRACTION      KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN 2D ARRAY OF CROP FRACTIONS (NOTE THAT ARRAY IS (NROW*NCROP,NCOL).'
                        !
                        CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,CDAT%MIN_BARE,  MSG='FMP CROP BLOCK "MIN_BARE_FRACTION" FAILED TO LOAD THE ACTUAL VALUE.')
      CASE ("IRRIGATION")
                        WRITE(BL%IOUT,'(A)') '   IRRIGATION             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD, THEN CROP IRRIGATION TYPES.'
                        IF(CDAT%NIRRG > Z) THEN
                            CALL CDAT%IRR%INIT('IRR',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, BL%SCRATCH)
                            !
                        ELSE
                            CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "IRRIGATION" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE IRRIGATION FLAG SET TO 0 FOR ALL CROPS.',CMD_PRINT=TRUE)
                        END IF
                        !
      CASE ("ROOT","ROOT_DEPTH","ROOT_PRESSURE") !ALLOW FOR SPACE BETWEEN ROOT DEPTH AND ROOT PRESSURE
                        !
                        IF(LINE(ISTART:ISTOP) == "ROOT") CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        !
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE('DEPTH',"ROOT_DEPTH")
                                        WRITE(BL%IOUT,'(A)') '   ROOT_DEPTH             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                                        CALL CDAT%ROOT%INIT('ROOT',     LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
                                        !CALL CDAT%ROOT%NEXT()
                        CASE('PRESSURE',"ROOT_PRESSURE")
                                        WRITE(BL%IOUT,'(A)') '   ROOT_PRESSURE          KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST OF ROOT PRESSURES.'
                                        CALL CDAT%PSI%INIT('PSI',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, FOUR, Z, Z, Z,'n', CDAT%NCROP, BYCROP,Z,'n', SCRATCH=BL%SCRATCH)
                                        !CALL CDAT%PSI%NEXT()
                        CASE DEFAULT
                                        CALL STOP_ERROR(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP CROP ERROR. FOUND KETYWORD "ROOT" WHICH MUST BE FOLLOWED BY EITHER "DEPTH" OR "PRESSURE".'//NL//'CHECK BLOCK FOR COMPLETENESS (viz. "ROOT DEPTH" or "ROOT PRESSURE")')
                        END SELECT
                        !
      CASE ("CROP_COEFFICIENT", "CROP_COEFICIENT")
                        WRITE(BL%IOUT,'(A)') '   CROP_COEFFICIENT       KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%Kc%INIT('Kc',         LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM) !, NONEG=TRUE)
                        CDAT%HAS_Kc = TRUE
                        !
      CASE ("CONSUMPTIVE_USE")
                        WRITE(BL%IOUT,'(A)') '   CONSUMPTIVE_USE        KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%CF%INIT('CF',         LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM) !, NONEG=TRUE)
                        !
                        !
      CASE ("ZERO_CONSUMPTIVE_USE_BECOMES_BARE_SOIL")
                        WRITE(BL%IOUT,'(A)') '   ZERO_CONSUMPTIVE_USE_BECOMES_BARE_SOIL KEYWORD FOUND. CHECKING FOR "STATIC", "TRANSIENT", OR "LIST" KEYWORD. IF NOT FOUND THEN OPTION IS APPLIED TO ALL CROPS.'
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE(LINE(ISTART:ISTOP))
                        CASE("STATIC","TRANSIENT","LIST")
                                   LLOC = ISTART
                                   CALL CDAT%ZERO_CU_TO_BARE%INIT('CU_TO_BARE',  LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        CASE DEFAULT
                                   CALL CDAT%ZERO_CU_TO_BARE%INIT('CU_TO_BARE', ONE,         BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
                        END SELECT
                        !
      CASE ("ADDED_DEMAND","ADMD")
                        WRITE(BL%IOUT,'(A)') '   ADDED_DEMAND (ADMD)     KEYWORD FOUND. NOW LOADING LENGTH (OR FLUX) OR RATE KEYWORDS THEN STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        !
                        IF(CDAT%HAS_DEMAND_EXT) CALL STOP_ERROR(OUTPUT=CDAT%LOUT, MSG='FMP CROP BLOCK ERROR. YOU MAY ONLY SPECIFY KEYWORD "ADDED_DEMAND" ONCE, SO YOU MAY ONLY SIMULATE WITH EITHER THE KEYWORD "LENGTH" OR "RATE", BUT NOT BOTH AT ONCE. IF YOU NEED TO SIMULATE BOTH THEN USE THE KEYWORD "ADDED_CROP_DEMAND" IN THE WBS BLOCK, WHICH CAN BE SPECIFIED TWICED, ONE WITH THE KEYWORD "LENGTH" AND ANOTHER WITH THE KEYWORD "RATE".')
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE("LENGTH","FLUX")
                                               CALL CDAT%ADMD%INIT('ADMD',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, FDIM%NFARM, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, LISTARRAY=TRUE, CDIM=CDIM, NONEG=TRUE)
                                               CDAT%DEMAND_EXT_FLUX = TRUE
                        CASE("RATE")
                                               CALL CDAT%ADMD%INIT('ADMD',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, FDIM%NFARM, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, LISTARRAY=TRUE, CDIM=CDIM, NONEG=TRUE)
                                               CDAT%DEMAND_EXT_FLUX = FALSE
                        CASE DEFAULT;          CALL STOP_ERROR(OUTPUT=CDAT%LOUT, MSG='FMP CROP BLOCK ERROR. IF YOU SPECIFY KEYWORD "ADDED_DEMAND", YOU MUST FOLLOW IT WITH THE KEYWORD "LENGTH" OR "RATE"'//NL//'TO INDICATE ADDED DEMAND IS LENGTH PER TIME OR VOLUME PER TIME.')
                        END SELECT
                        !
                        CDAT%HAS_DEMAND_EXT = TRUE
                        !
      CASE ("TRANSPIRATION_FRACTION","FTR")
                        WRITE(BL%IOUT,'(A)') '   TRANSPIRATION_FRACTION (FTR)           KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%FTR%INIT('FTR',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        !
      CASE ("EVAPORATION_IRRIGATION_FRACTION","FEI")
                        WRITE(BL%IOUT,'(A)') '   EVAPORATION_IRRIGATION_FRACTION (FEI)  KEYWORD FOUND. FIRST CHECKING "BY_IRRIGATE" OR "BY_CROP" FLAG, THEN LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        IF(CDAT%NIRRG > Z) THEN
                           !
                           CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                           !
                           SELECT CASE ( LINE(ISTART:ISTOP) )
                           CASE('BYIRRIGATE', 'BY_IRRIGATE','BYIRRIGATION',"BY_IRRIGATION")
                                           WRITE(BL%IOUT,'(3x,4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR EVAPORATION_IRRIGATION_FRACTION (FEI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NIRRG), ' (NIRRIGATE) RECORDS.'
                                           CALL CDAT%FEI%INIT('FEI_BYIRR',      LLOC, LINE, BL%IOUT, BL%IU, CDAT%NIRRG, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           CASE('BYCROP',"BY_CROP")
                                           WRITE(BL%IOUT,'(3x,4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR EVAPORATION_IRRIGATION_FRACTION (FEI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
                                           CALL CDAT%FEI%INIT('FEI_BYCROP',      LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           CASE DEFAULT
                                           WRITE(BL%IOUT,'(3x,3A)') '"BY_IRRIGATE" OR "BY_CROP" FLAG NOT FOUND, ASSUMING IT IS NOT SPECIFIED AND WILL USE "BY_CROP", SO IF USING LIST STYLE FOR EVAPORATION_IRRIGATION_FRACTION (FEI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
                                           LLOC = ISTART
                                           CALL CDAT%FEI%INIT('FEI_BYCROP',      LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           END SELECT
                        ELSE
                            CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "EVAPORATION_IRRIGATION_FRACTION" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EVAPORATION_IRRIGATION_FRACTION SET TO 0.0 FOR ALL CROPS.',CMD_PRINT=TRUE)
                        END IF
                        !!!WRITE(BL%IOUT,'(A)') '   EVAPORATION_IRRIGATION_FRACTION (FEI)  KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        !!!IF(CDAT%NIRRG > Z) THEN
                        !!!    CALL CDAT%FEI%INIT('FEI',       LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                        !!!ELSE
                        !!!    CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "EVAPORATION_IRRIGATION_FRACTION" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EVAPORATION_IRRIGATION_FRACTION SET TO 0.0 FOR ALL CROPS.',CMD_PRINT=TRUE)
                        !!!END IF
                        !
                        !
      CASE ("EVAPORATION_IRRIGATION_FRACTION_SUM_ONE_CORRECTION")
                        WRITE(BL%IOUT,'(A)') '   EVAPORATION_IRRIGATION_FRACTION_SUM_ONE_CORRECTION KEYWORD FOUND. CHECKING FOR "STATIC", "TRANSIENT", OR "LIST" KEYWORD. IF NOT FOUND THEN OPTION IS APPLIED TO ALL CROPS.'
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE(LINE(ISTART:ISTOP))
                        CASE("STATIC","TRANSIENT","LIST")
                                   LLOC = ISTART
                                   CALL CDAT%FEI_CHECK%INIT('FEI_CHECK',  LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        CASE DEFAULT
                                   CALL CDAT%FEI_CHECK%INIT('FEI_CHECK', ONE,         BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
                        END SELECT
                        !
      CASE ("SURFACEWATER_LOSS_FRACTION_PRECIPITATION","FIESWP")
                        WRITE(BL%IOUT,'(A)') '   SURFACEWATER_LOSS_FRACTION_PRECIPITATION (FIESWP) KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%FIESWP%INIT('FIESWP', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
                        !
      CASE ("SURFACEWATER_LOSS_FRACTION_IRRIGATION","FIESWI")
                        WRITE(BL%IOUT,'(A)') '   SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI)    KEYWORD FOUND. FIRST CHECKING "BY_IRRIGATE" OR "BY_CROP" FLAG, THEN LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        IF(CDAT%NIRRG > Z) THEN
                           !
                           CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                           !
                           SELECT CASE ( LINE(ISTART:ISTOP) )
                           CASE('BYIRRIGATE', 'BY_IRRIGATE','BYIRRIGATION',"BY_IRRIGATION")
                                           WRITE(BL%IOUT,'(3x,4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NIRRG), ' (NIRRIGATE) RECORDS.'
                                           CALL CDAT%FIESWI%INIT('FIESWI_BYIRR', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NIRRG, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           CASE('BYCROP',"BY_CROP")
                                           WRITE(BL%IOUT,'(3x,4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
                                           CALL CDAT%FIESWI%INIT('FIESWI_BYCROP', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           CASE DEFAULT
                                           WRITE(BL%IOUT,'(3x,3A)') '"BY_IRRIGATE" OR "BY_CROP" FLAG NOT FOUND, ASSUMING IT IS NOT SPECIFIED AND WILL USE "BY_CROP", SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
                                           LLOC = ISTART
                                           CALL CDAT%FIESWI%INIT('FIESWI_BYCROP', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM)
                           END SELECT
                        ELSE
                            CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "SURFACEWATER_LOSS_FRACTION_IRRIGATION" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE SURFACEWATER_LOSS_FRACTION_IRRIGATION SET TO 0.0 FOR ALL CROPS.',CMD_PRINT=TRUE)
                        END IF
      !
      !!!CASE ("PRECIP_CONSUMPTION_FRACTION", "PRECIPITATION_CONSUMPTION_FRACTION", "PCF")
      !!!                  WRITE(BL%IOUT,'(A)') '   PRECIPITATION_CONSUMPTION_FRACTION (PCF)       KEYWORD FOUND. FIRST CHECKING "BY_LENGTH" OR "BY_FRAC" KEYWORD. IF NOT PRESENT THEN DEFAULT TO "BY_FRAC".'
      !!!                  !
      !!!                  CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !!!                  !
      !!!                  SELECT CASE ( LINE(ISTART:ISTOP) )
      !!!                  CASE('BYLENGTH', 'BY_LENGTH','BYHEIGHT',"BY_HEIGHT")
      !!!                                  WRITE(BL%IOUT,'(3x,4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NIRRG), ' (NIRRIGATE) RECORDS.'
      !!!                                  CALL CDAT%CON_PRECIP_FRAC%INIT('PCF', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
      !!!                                  CDAT%PCF_IS_FRAC = FALSE
      !!!                  CASE('BYFRAC',"BY_FRAC","BYFRACTION","BY_FRACTION")
      !!!                                  WRITE(BL%IOUT,'(3x,4A)') LINE(ISTART:ISTOP),' KEYWORD FOUND, SO IF USING LIST STYLE FOR SURFACEWATER_LOSS_FRACTION_IRRIGATION (FIESWI), THEN IT WILL EXPECT TO LOAD ', NUM2STR(CDAT%NCROP), ' (NCROP) RECORDS.'
      !!!                                  CALL CDAT%CON_PRECIP_FRAC%INIT('PCF', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
      !!!                  CASE DEFAULT
      !!!                                  WRITE(BL%IOUT,'(3x,3A)') '"BY_LENGTH" OR "BY_FRAC" FLAG NOT FOUND, ASSUMING IT IS NOT SPECIFIED AND WILL USE "BY_FRAC".'
      !!!                                  LLOC = ISTART
      !!!                                  CALL CDAT%CON_PRECIP_FRAC%INIT('PCF', LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, CDIM=CDIM, NONEG=TRUE)
      !!!                  END SELECT
      !!!                  !
      CASE ("GW_ROOT","GROUNDWATER_ROOT_INTERACTION") 
                        WRITE(BL%IOUT,'(A)') '   GROUNDWATER_ROOT_INTERACTION            KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CALL CDAT%GW_INTER%INIT('GWRT',LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL, BL%SCRATCH)
                        !
      CASE ("RELAXATION_FACTOR_HEAD_CHANGE")
                        WRITE(BL%IOUT,'(A)') '   GROUNDWATER_ROOT_RELAXATION_FACTOR       KEYWORD FOUND. NOW LOADING NUMBER BETWEEN 0 AND 1 WITH ULOAD.'
                        IU = Z
                        CALL ULOAD(CDAT%RELAX_FACT, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
                        !
      CASE ("POND_DEPTH")
                        WRITE(BL%IOUT,'(A)') '   POND_DEPTH             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        CDAT%HAS_POND = TRUE
                        CALL CDAT%POND%INIT('POND',     LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP,CDAT%NIRRG, BYIRRIGATE, SCRATCH=BL%SCRATCH, NONEG=TRUE)
                        !
      CASE ("SPECIFY_PRINT_ALL_CROP","SPECIFY_PRINT_ALL_CROPS")
                        WRITE(BL%IOUT,'(A)') '   SPECIFY_PRINT_CROP     KEYWORD FOUND. NOW USING ULOAD TO READ IN LIST OF CROP NAMES.'
                        IU = Z
                        CALL CDAT%PRINT_CROP%INIT('PRINT_CROP',LLOC, LINE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z, BL%SCRATCH)
                        !
      CASE ("PRINT")
                        BINARY = FALSE
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        IF(LINE(ISTART:ISTOP) == 'BINARY') THEN
                            BINARY = TRUE
                            CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        END IF
                        !
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE ("BYCROP")
                                          CALL CDAT%OUT_BYCROP%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("BYWBS","BYFARM")
                                          CALL CDAT%OUT_BYFARM%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("BYWBS_BYCROP", "BYWBSBYCROP","BYWBSCROP","BYFARM_BYCROP", "BYFARMBYCROP")
                                          CALL CDAT%OUT_BYFARMCROP%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("ALL_VERBOSE","ALL_DETAIL")
                                          CALL CDAT%OUT_DETAIL%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=1)
                        CASE ("ALL")
                                          CALL CDAT%OUT_ALL%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=1)
                        CASE ("BARE")
                                          CALL CDAT%OUT_BARE%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("ET_BYWBS_BYCROP")
                                          CALL CDAT%OUT_ET%OPEN(LINE,LLOC,BL%IOUT,BL%IU,NOBINARY=.TRUE.,SPLITMAXCOUNT=11)
                        CASE ("INPUT")
                                          CALL CDAT%OUT_INPUT%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("ROW_COL","ROW_COLUMN","ROW")
                                          IF(LINE(ISTART:ISTOP) == 'ROW')  CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
                                          !
                                          NPRNT_CROP = NPRNT_CROP + ONE
                                          CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,CDAT%OUT_CROP_RC(:, NPRNT_CROP),  MSG='FMP CROP BLOCK "PRINT ROW_COLUMN" EXPECTS TO READ "ROW COL" BEFORE READING THE GENERIC_OUTPUT. FAILED TO LOAD ONE OF THOSE TWO INTEGERS.')
                                          CALL CDAT%OUT_CROP(NPRNT_CROP)%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                                          IF (CDAT%OUT_CROP_RC(ONE, NPRNT_CROP) < ONE  .OR. &
                                              CDAT%OUT_CROP_RC(ONE, NPRNT_CROP) > NROW .OR. &
                                              CDAT%OUT_CROP_RC(TWO, NPRNT_CROP) < ONE  .OR. &
                                              CDAT%OUT_CROP_RC(TWO, NPRNT_CROP) > NCOL) CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK "PRINT ROW_COLUMN" SPECIFIED A ROW or COLUMN THAT IS INVALID (e.g. LESS THAN 1 OR GREATER THAN NROW or NCOL)')
                        !                 
                        !CASE ("ROOT")
                        !                  CALL CDAT%OUT_ROOT%OPEN(LINE,LLOC,BL%IOUT,BL%IU,SPLITMAXCOUNT=11)
                        !
                        CASE DEFAULT;     CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK KEYWORD ERROR. IDENTIFIED KEYWORD "PRINT", BUT THE NEXT WORD WAS NOT IDENTIFIED.'//NL//'WORDS EXPECTED ARE: "BYFARM", "BYCROP", "BYFARM_BYCROP", "ALL", "ALL_VERBOSE, "BARE", "INPUT", "ROW_COLUMN"')
                        END SELECT
                        !
      CASE ("CROPS_THAT_SPECIFY_SURFACE_ELEVATION")
                        WRITE(BL%IOUT,'(A)') '   CROPS_THAT_SPECIFY_SURFACE_ELEVATION KEYWORD FOUND. NOW LOADING LIST OF "NCROP_SPECIFIED_ELEVATIONS" CROP IDs (CID/LOCATIONs). IF THE CROP ID IS 0 (ZERO) THEN THE ELEVATION IS BARE LAND, OTHERWISE IT IS THE CROP ID SPECIFIED.)'
                        IF(FDIM%NCROP_ELEV < ONE) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "CROPS_THAT_SPECIFY_SURFACE_ELEVATION" WHEN IN THE GLOBAL DIMENSION BLOCK THERE IS "NCROP_SPECIFIED_ELEVATIONS" = 0 (OR IT WAS NOT SPECIFIED). IT WILL BE ASSUMED THAT THIS VALUE IS NCROP, WHICH MAY CAUSE INPUT TO RAISE AN ERROR IF YOU DO NOT HAVE A LIST LENGTH OF NCROP INPUT.',INLINE=TRUE)
                        !
                        CALL CDAT%GSE_CID%INIT('GSE_CROPS',LLOC, LINE, BL%IOUT, BL%SCRATCH, CDAT%NCROP_ELEV, ONE, Z, Z, SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
                        !
      CASE ("CROP_SURFACE_ELEVATION")
                        WRITE(BL%IOUT,'(A)') '   CROP_SURFACE_ELEVATION KEYWORD FOUND. NOW LOADING 2D ARRAY OF CROP ELEVATIONS. NOTE IF USING "MULTI_CROP_FRACTION" KEYWORD THEN ARRAY IS (NROW*NCROP_SPECIFIED_ELEVATIONS,NCOL).'
                        IF(FDIM%NCROP_ELEV < ONE) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "CROP_SURFACE_ELEVATION" WHEN IN THE GLOBAL DIMENSION BLOCK THERE IS "NCROP_SPECIFIED_ELEVATIONS" = 0 (OR IT WAS NOT SPECIFIED). IT WILL BE ASSUMED THAT THIS VALUE IS NCROP, WHICH MAY CAUSE INPUT TO RAISE AN ERROR IF YOU ARE USING "FRACTIONS" AND NOT LOADING AN NCROP*NROW BY NCOL ARRAY.',INLINE=TRUE)
                        !
                        CALL CDAT%SPEC_GSE%INIT('GSE_SPEC',LLOC, LINE, BL%IOUT, BL%SCRATCH, Z, Z, ELV_NROW, NCOL, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
                        !
      CASE ("CROP_SURFACE_ELEVATION_OFFSET")
                        WRITE(BL%IOUT,'(A)') '   CROP_SURFACE_ELEVATION_OFFSET KEYWORD FOUND. NOW LOADING LIST OF "NCROP_SPECIFIED_ELEVATIONS" ELEVATIONS TO OFFSET. (POSITIVE INDICATES MOVING SURFACE_ELEVATION UPWARD.)'
                        IF(FDIM%NCROP_ELEV < ONE) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "CROP_SURFACE_ELEVATION_OFFSET" WHEN IN THE GLOBAL DIMENSION BLOCK THERE IS "NCROP_SPECIFIED_ELEVATIONS" = 0 (OR IT WAS NOT SPECIFIED). IT WILL BE ASSUMED THAT THIS VALUE IS NCROP, WHICH MAY CAUSE INPUT TO RAISE AN ERROR IF YOU DO NOT HAVE A LIST LENGTH OF NCROP INPUT.',INLINE=TRUE)
                        !
                        CALL CDAT%GSE_OFFSET%INIT('GSE_OFFSET',LLOC, LINE, BL%IOUT, BL%SCRATCH, CDAT%NCROP_ELEV, ONE, Z, Z, FDIM%NFARM, BYFARM, CDAT%NCROP, BYCROP, SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
                        !
      !CASE ("CROP_SURFACE_ELEVATION_FROM_SFR")
      !                  WRITE(BL%IOUT,'(A)') '   CROP_SURFACE_ELEVATION_FROM_SFR KEYWORD FOUND. NOW LOADING LIST OF "NCROP_SPECIFIED_ELEVATIONS" CROP IDs THAT WILL USE SFR TO GET ITS SURFACE ELEVATIONS.'
      !                  IF(FDIM%NCROP_ELEV < ONE) CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FOUND KEYWORD "CROP_SURFACE_ELEVATION_FROM_SFR" WHEN IN THE GLOBAL DIMENSION BLOCK THERE IS "NCROP_SPECIFIED_ELEVATIONS" = 0 (OR IT WAS NOT SPECIFIED). IT WILL BE ASSUMED THAT THIS VALUE IS NCROP, WHICH MAY CAUSE INPUT TO RAISE AN ERROR IF YOU DO NOT HAVE A LIST LENGTH OF NCROP INPUT.',INLINE=TRUE)
      !                  !IF(.NOT. CDAT%MULTI_CROP_CELLS) CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP CROP BLOCK ERROR. CROPS ARE DEFINED AS BY CROP ID (NO FRACTIONS OF CELLS CONTAINING CROPS), SO YOU SHOULD READ IN A CROP LOCATION (CID) ARRAY WITH KEYWORD LOCATION AND REMOVE KEYWORD FRACTION.')
      !                  CALL CDAT%GSE_SFR%INIT('GSE_SFR',LLOC, LINE, BL%IOUT, BL%SCRATCH, CDAT%NCROP_ELEV, ONE, Z, Z, SCRATCH=BL%SCRATCH, NO_TRANSIENT=TRUE)
      !                  !
      CASE DEFAULT
                        CALL WARN%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                        
      END SELECT
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN%CHECK(HED='FMP CROP BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL, INIT=TRUE)
    !
    END IF
    !
    IF(CDAT%MULTI_CROP_CELLS) THEN
        WRITE(CDAT%IOUT,'(//A)') 'LAND USE/CROP MODEL ALLLOWS FOR MORE THEN ONE CROP PER MODEL CELL. THIS MODIFIES ARRAY INPUT TO EXPECT A SIZE OF NCROP*NROW x NCOL (ONE ARRAY PER CROP THAT IS READ AS ONE GIANT ARRAY)'
    ELSE
        WRITE(CDAT%IOUT,'(//A)') 'LAND USE/CROP MODEL SPECIFIES AT MOST ONE CROP PER MODEL CELL. THE CROP LOCATION IS IDENTIFIED WTIH THE KEYWORD LOCATION.'
    END IF
    WRITE(CDAT%IOUT,'(//A/)' )'CROP PROPERTIES LOADED: '
    IF( CDAT%CID%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'CROP ID (LOCATION)'
    IF(CDAT%MULTI_CROP_CELLS) THEN
        IF( CDAT%FRAC%INUSE ) WRITE(CDAT%IOUT,'(A)') 'LAND_USE_AREA_FRACTION WITH MULTIPLE_LAND_USE_PER_CELL IS READ AS AS NCROP*NROW x NCOL FRACTION ARRAYS'
    ELSE
        IF( CDAT%FRAC%INUSE ) WRITE(CDAT%IOUT,'(A)') 'LAND_USE_AREA_FRACTION WITH SINGLE_LAND_USE_PER_CELL DEFINES THE FRACTION OF AREA THAT EACH CROP OCCUPIES'
    END IF
    IF( CDAT%IRR%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'IRRIGATION FLAG'
    IF( CDAT%ROOT%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'ROOT DEPTH'
    IF( CDAT%PSI%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'ROOT PRESSURES'
    IF( CDAT%Kc%INUSE        ) WRITE(CDAT%IOUT,'(A)') 'CROP COEFFICIENT'
    IF( CDAT%CF%INUSE        ) WRITE(CDAT%IOUT,'(A)') 'CONSUMPTIVE USE QUANTITY'
    IF( CDAT%FTR%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF TRANSPIRATION'
    IF( CDAT%FEI%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF EVAPORATION FROM IRRIGATION'
    IF( CDAT%FIESWP%INUSE    ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF INEFFICIENT LOSSES FROM PRECIPITATION'
    IF( CDAT%FIESWI%INUSE    ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF INEFFICIENT LOSSES FROM IRRIGATION'
    IF( CDAT%GW_INTER%INUSE  ) WRITE(CDAT%IOUT,'(A)') 'ROOT-GROUNDWATER INTERACTION FLAG'
    IF( CDAT%POND%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'PONDING WATER DEPTH BEFORE PLANT DEATH/DROWNING'
    IF( CDAT%ADMD%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'ADDED_DEMAND THAT IS ADDITIONALLY DEMANDED WATER FOR IRRIGATED CROP THAT BECOMES EITHER DEEP PEROCOLATION OR RUNOFF'
    IF( CDAT%GSE_CID%INUSE   ) WRITE(CDAT%IOUT,'(A)') 'CROP IDs THAT WILL HAVE THEIR GSE SPECIFIED AND NOT USE THE GLOBAL DIMENSION SURFACE_ELEVATION.'
    IF( CDAT%SPEC_GSE%INUSE  ) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED FOR CERTAIN CROPS THEIR SURFACE_ELEVATIONS.'
    IF( CDAT%GSE_OFFSET%INUSE) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED FOR CERTAIN CROPS THEIR AN OFFSET FROM THE GLOBAL DIMENSION SURFACE_ELEVATION.'
    !IF( CDAT%GSE_SFR%INUSE   ) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED CROPS LOCATED IN CELL WITH SFR SEGMENT/REACH USE THE ELEVATION SPECIFIED BY SFR.'
    
    WRITE(CDAT%IOUT,'(//A/)')'CROP PROPERTIES NOT USED IN SIMULATION: '
    !
    IF( .NOT. CDAT%CID%INUSE .AND. .NOT. CDAT%MULTI_CROP_CELLS) WRITE(CDAT%IOUT,'(A)') 'CROP ID (LOCATION)'
    !
    IF( .NOT. CDAT%FRAC%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'LAND_USE_AREA_FRACTION'
    IF( .NOT. CDAT%IRR%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'IRRIGATION FLAG'
    IF( .NOT. CDAT%ROOT%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'ROOT DEPTH'
    IF( .NOT. CDAT%PSI%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'ROOT PRESSURES'
    IF( .NOT. CDAT%Kc%INUSE        ) WRITE(CDAT%IOUT,'(A)') 'CROP COEFFICIENT'
    IF( .NOT. CDAT%CF%INUSE        ) WRITE(CDAT%IOUT,'(A)') 'CONSUMPTIVE USE QUANTITY'
    IF( .NOT. CDAT%FTR%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF TRANSPIRATION'
    IF( .NOT. CDAT%FEI%INUSE       ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF EVAPORATION FROM IRRIGATION'
    IF( .NOT. CDAT%FIESWP%INUSE    ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF INEFFICIENT LOSSES FROM PRECIPITATION'
    IF( .NOT. CDAT%FIESWI%INUSE    ) WRITE(CDAT%IOUT,'(A)') 'FRACTION OF INEFFICIENT LOSSES FROM IRRIGATION'
    IF( .NOT. CDAT%GW_INTER%INUSE  ) WRITE(CDAT%IOUT,'(A)') 'ROOT-GROUNDWATER INTERACTION FLAG, AUTOMATICALLY SETTING FOR FULL GROUNDWATER_ROOT INTERACTION (LEVEL 2)'
    IF( .NOT. CDAT%POND%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'PONDING WATER DEPTH BEFORE PLANT DEATH/DROWNING'
    IF( .NOT. CDAT%ADMD%INUSE      ) WRITE(CDAT%IOUT,'(A)') 'ADDED_DEMAND THAT IS ADDITIONALLY DEMANDED WATER FOR IRRIGATED CROP THAT BECOMES EITHER DEEP PEROCOLATION OR RUNOFF'
    IF( .NOT. CDAT%GSE_CID%INUSE   ) WRITE(CDAT%IOUT,'(A)') 'CROP IDs THAT WILL HAVE THEIR GSE SPECIFIED AND NOT USE THE GLOBAL DIMENSION SURFACE_ELEVATION.'
    IF( .NOT. CDAT%SPEC_GSE%INUSE  ) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED FOR CERTAIN CROPS THEIR SURFACE_ELEVATIONS.'
    IF( .NOT. CDAT%GSE_OFFSET%INUSE) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED FOR CERTAIN CROPS THEIR AN OFFSET FROM THE GLOBAL DIMENSION SURFACE_ELEVATION.'
    !IF( .NOT. CDAT%GSE_SFR%INUSE   ) WRITE(CDAT%IOUT,'(A)') 'HAS SPECIFIED CROPS LOCATED IN CELL WITH SFR SEGMENT/REACH USE THE ELEVATION SPECIFIED BY SFR.'
    !
    WRITE(CDAT%IOUT,'(/2A/)') 'RELAXATION FACTOR APPLIED TO THE PICARD/NETWON ITERATION HEAD CHANGE WHEN DETERMINING GROUNDWATER-ROOT UPTAKE IS: ', NUM2STR(CDAT%RELAX_FACT)
    !
    ! Set up minimum bare fraction of area
    !
    IF( .NOT. CDAT%FRAC%INUSE .AND. CDAT%MIN_BARE > NEAR_inf ) CDAT%MIN_BARE=UNO         !NEVER IS NEEDED
    IF(       CDAT%Kc%INUSE   .AND. CDAT%MIN_BARE > NEAR_inf ) CDAT%MIN_BARE=NEARZERO_12 !KNOWN THAT ETR IS DEFINED
    !
    IF(CDAT%MIN_BARE<NEARZERO_30 ) CDAT%MIN_BARE=NEARZERO_30
    IF(CDAT%MIN_BARE<UNO) THEN
        WRITE(CDAT%IOUT,'(/2A, /A/)') 'MINIMUM BARE FRACTION IS: ', NUM2STR(CDAT%MIN_BARE),'ANY FRACTIONS LESS THAN THIS WILL BE AUTOMATICALLY SET TO ZERO.'
    ELSEIF(CDAT%MIN_BARE < NEAR_inf) THEN
        WRITE(CDAT%IOUT,'(4(/A), /)') 'MINIMUM BARE FRACTION IS GREATER THAN 1.0,','SO SOIL EVAPORATION, DEEP PERCOLATION, AND SURFACE RUNOFF ON BAR SOIL/FALLOW CROPS WILL NOT BE CALCULATED.','PRECIPITATION THAT FALLS ON BARE SOIL/FALLOW CROPS IS REMOVED FROM MODEL.','THIS EFFECTS CELLS WITH CROP IDs EQUAL TO ZERO OR CROP FRACTIONS DO NOT SUM TO ONE FOR A MODEL CELL.'
    END IF
    !
    !CALL CDAT%PARSE_CROP_ROW_COL()  !POPULATE CDAT%CROP%RC
    !CALL CDAT%SETUP_FID(IFID)      !POPULATE CDAT%CROP%FID
    !
    IF(.NOT. CDAT%GSE_CID%INUSE .AND. (CDAT%SPEC_GSE%INUSE .OR. CDAT%GSE_OFFSET%INUSE)) THEN !.OR. CDAT%GSE_SFR%INUSE
        CALL WARNING_MESSAGE(INFILE=BL%IU, OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK: FAILED TO FIND TO FIND KEYWORD "CROPS_THAT_SPECIFY_SURFACE_ELEVATION" WHEN ONE OF THE CUSTOM ELEVATION KEYWORDS WERE USED. IT WILL BE ASSUMED THERE IS A ONE TO ONE MAPPYING OF CROP IDs TO THE CUSTOM ELEVATIONS. THIS WILL RESULT IN ALL CROPS USING CUSTOM ELEVATIONS (e.g ALL CROPS ARE MATCHED TO ARRAY INPUT AND FOR LIST INPUT THE FIRST RECORD IS FOR CROP 1, SECOND RECORD IS CROP 2...AND SO FORTH.',INLINE=TRUE)
        !
        CALL CDAT%GSE_CID%INIT('GSE_CROPS', ONE, BL%IOUT, BL%SCRATCH, CDAT%NCROP_ELEV, ONE, Z, Z)
        DO CONCURRENT (I=ONE:CDAT%NCROP_ELEV); CDAT%GSE_CID%LIST(I) = I
        END DO
    END IF
    !
    IF (CDAT%Kc%INUSE .AND. CDAT%CF%INUSE)  CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FYI - FMP CROP BLOCK: CROP COEFICIENTS AND CROP CONSUMPTIVE USE ARE BOTH SPECIFIED IN BLOCK.'//NL//'THESE TWO VALUES ARE ADDED TO GET THE FINAL CONSUMPTIVE USE. IN OTHERWORDS THIS MEANS:'//BLN//'CUfinal = CU*AREA + Kc*ETref*AREA',INLINE=TRUE)
      !WRITE(BL%IOUT,'(/,3(A/),/)') 'FMP CROP BLOCK WARNING: CROP COEFICIENTS AND CROP CONSUMPTIVE USE ARE BOTH SPECIFIED IN BLOCK.','THESE TWO VALUES ARE ADDED TO GET THE FINAL CONSUMPTIVE USE THIS MEANS:','CUfinal = CU*AREA + Kc*ETref*AREA'
    !
    !   (CDAT%MULTI_CROP_CELLS .AND. CDAT%FRAC%TRANSIENT)
    IF( .NOT. CDAT%MULTI_CROP_CELLS .AND. .NOT. CDAT%CID%INUSE ) CALL WARN%ADD(NL//'FMP CROP BLOCK: WHEN KEYWORD "SINGLE_LAND_USE_PER_CELL" IS USED, THEN WHEN NCROP > 0 THE KEYWORD "LOCATION" MUST BE DEFINED TO INDICATE THE LOCATION OF CROPS.'//NL)
    !
    IF(.NOT. CDAT%GW_INTER%INUSE) THEN
        CDAT%GW_ROOT_INTERACTION = TRUE
        !
        CALL CDAT%GW_INTER%INIT('GWRT',5, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL)  !DEFUALT TO FULL INTERACTION
    END IF
    !
    IF(.NOT. CDAT%ROOT%INUSE .AND. CDAT%GW_ROOT_INTERACTION)  CALL WARN%ADD(NL//'FMP CROP ERROR. THERE IS INTERACTION BETWEEN THE THE CROP ROOTS AND GROUNDWATER LEVEL TO CALCULATE TRANSPIRATION (DEFAULT BEHAIVOR).'//NL//'THIS REQUIRES THE CROP ROOT DEPTH TO BE SPECIFRIED WITH "ROOT DEPTH" OR "ROOT_DEPTH" KEYWORD IN CROP BLOCK.'//NL//'EITHER SPECIFY ROOT DEPTHS OR USE KEYWORD "GROUNDWATER_ROOT_INTERACTION"'//NL//'AND SET ALL VALUES TO ONE TO DISABLE ANY GROUNDWATER ROOT INTERACTION'//NL//'(THUS NEGATING THE NEED FOR SPECIFYING ROOT DEPTHS).'//NL)
    !
    CALL WARN%CHECK(INFILE=BL%IU,OUTPUT=CDAT%LOUT, KILL=TRUE) !FOUND FATAL ERRORS
    !
    IF( .NOT. CDAT%CF%INUSE   .AND. .NOT. CDAT%Kc%INUSE  ) CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "CROP_COEFFICIENT" OR "CONSUMPTIVE_USE" KEYWORD IN CROP BLOCK, POTENTIAL CONSUMPTIVE USE IS SET TO ZERO FOR ALL TIME                                       (i.e. CONSUMPTIVE_USE=0.0)'//NL)
    !
    IF( .NOT. CDAT%IRR%INUSE    .AND.     CDAT%NIRRG > Z ) CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "IRRIGATION" KEYWORD IN CROP BLOCK, EVEN THOUGH NIRRIGATE > 0, IT WILL BE AUTOMATICALLY SET TO 0 FOR ALL CROPS                                            (i.e. IRRIGATION=0)'//NL)
    IF( .NOT. CDAT%FEI%INUSE    .AND.     CDAT%NIRRG > Z ) CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "EVAPORATION_IRRIGATION_FRACTION" (OR "FEI") KEYWORD IN CROP BLOCK, EVEN THOUGH NIRRIGATE > 0, IT WILL BE AUTOMATICALLY SET TO -1 FOR ALL CROPS           (i.e. FEI=1-FTR)'//NL)
    !
    IF( .NOT. CDAT%FTR%INUSE    )                          CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "TRANSPIRATION_FRACTION" (OR "FTR") KEYWORD IN CROP BLOCK, THIS WILL AUTOMATICALLY BE SET TO ZERO MAKING THE ENTIRE MODEL BARE SOIL                       (i.e. FTR=0.0).'//NL)
    IF( .NOT. CDAT%FIESWI%INUSE .AND.     CDAT%NIRRG > Z ) CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "SURFACEWATER_LOSS_FRACTION_IRRIGATION" (OR "FIESWI") KEYWORD IN CROP BLOCK, EVEN THOUGH NIRRIGATE > 0, IT WILL BE AUTOMATICALLY SET TO 0.0 FOR ALL CROPS TO FORCE ALL EXCESS IRRIGATED WATER TO INFILTRATE (i.e. FIESWI=0.0)'//NL)
    IF( .NOT. CDAT%FIESWP%INUSE )                          CALL WARN%ADD(NL//'FMP CROP BLOCK: FAILED TO LOCATE "SURFACEWATER_LOSS_FRACTION_PRECIPITATION" (OR "FIESWP") KEYWORD IN CROP BLOCK, IT WILL BE AUTOMATICALLY SET TO 1.0 FOR ALL CROPS, IF SFR IS NOT AVAILIBLE THEN IT WILL BE AUTOMATICALLY SET TO 0.0 (IF SFR := FIESWP=1.0, ELSE FIESWP=0.0)'//NL)
    !
    CALL WARN%CHECK(INFILE=BL%IU,OUTPUT=CDAT%LOUT) !FOUND WARNINGS
    !
    IF(CDAT%PSI%INUSE) THEN
        WRITE(CDAT%IOUT,'(//8x,A/,A/)') '--- FMP CROP CONSUMPTIVE USE WILL USE CONCEPT ONE ---','--- FMP WILL USE 4 POINT ROOT PRESSURES AND SOIL PROPERTIES TO DETERMINE CROP TRANPIRATION AND ROOT UPTAKE --'
    ELSE
        WRITE(CDAT%IOUT,'(//8x,A/,A/)') '--- FMP CROP CONSUMPTIVE USE WILL USE CONCEPT TWO ---','--- FMP WILL USE GROUDNWATER LEVEL TO DETERMINE CROP TRANPIRATION AND ROOT UPTAKE --'
    END IF
    !
    IF( .NOT. CDAT%CF%INUSE .AND. .NOT. CDAT%Kc%INUSE  )   CALL CDAT%CF%INIT('CF', DZ, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    IF( .NOT.       CDAT%IRR%INUSE ) THEN
                                     CALL CDAT%IRR%INIT('IRR', Z, BL%IOUT, BL%IU, CDAT%NCROP, ONE, NROW, NCOL)
    END IF
    !
    IF( .NOT.       CDAT%FEI%INUSE ) CALL CDAT%FEI%INIT('FEI_BYCROP', DNEG, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !    
    IF( .NOT.    CDAT%FIESWP%INUSE .AND. HAS_SFR) CALL CDAT%FIESWP%INIT('FIESWP', 0.8D0, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    IF( .NOT.    CDAT%FIESWP%INUSE              ) CALL CDAT%FIESWP%INIT('FIESWP',    DZ, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    IF( .NOT.    CDAT%FIESWI%INUSE ) CALL CDAT%FIESWI%INIT('FIESWI_BYCROP', DZ, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    IF(.NOT. CDAT%PRINT_CROP%INUSE ) CALL CDAT%PRINT_CROP%INIT('PRINT_CROP', ONE, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    !IF(.NOT. CDAT%FEI_CHECK%INUSE ) CALL CDAT%FEI_CHECK%INIT('FEI_CHECK', Z,         BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
    IF(.NOT.       CDAT%ADMD%INUSE ) THEN
                            CALL CDAT%ADMD%INIT('ADMD', DZ, BL%IOUT, BL%IU, CDAT%NCROP, FDIM%NFARM, Z, Z, LISTARRAY=TRUE)
                            CDAT%DEMAND_EXT_FLUX = FALSE
    END IF
    !
    !!!IF( .NOT.    CDAT%CON_PRECIP_FRAC%INUSE ) CALL CDAT%CON_PRECIP_FRAC%INIT('PCF', UNO, BL%IOUT, BL%IU, CDAT%NCROP, ONE, Z, Z)
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_TIME_STEP(CDAT, WBS)
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    !
    IF(CDAT%NCROP > Z) CALL CDAT%SETUP_CROP_EFFICIENCY(WBS,TRUE)
    !
    CDAT%RELAX = CDAT%RELAX_FACT
    !
  END SUBROUTINE
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(CDAT, WBS, CLIM, SOIL, LOAD)
    !
    !  NOTE THAT WBS%IRR_AREA, AND WBS%CROP ARE POPULATED HERE!
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    TYPE(CLIMATE_DATA), INTENT(IN   ):: CLIM
    TYPE(SOIL_DATA),    INTENT(IN   ):: SOIL
    LOGICAL, OPTIONAL,  INTENT(IN   ):: LOAD !WHEN NOT PRESENT SET TRUE..THIS ALLOWS THE SUBROUTINE TO BE CALLED WITH OUT RUNNING THE NEXT() METHODS. THUS REINITIALIZTING ALL THE ARRAYS VALUES
    DOUBLE PRECISION:: P
    INTEGER:: I, K, R, C, F, IRR
    LOGICAL:: UPDATE, LOAD_NEXT, NEW_IRR!, HAS_CON_PRECIP_FRAC
    TYPE(WARNING_TYPE):: WRN
    CHARACTER(:),ALLOCATABLE:: ERROR
    LOGICAL, DIMENSION(CDAT%NCROP):: PRNT
    !
    ERROR = NL
    !
    CALL WRN%INIT()
    !
    IF(CDAT%NCROP == Z) THEN !-----------------------------------------------------------------------------------------------------------
        IF( .NOT. ALLOCATED(CDAT%ETOT)) THEN
            !
            CDAT%CHECK_BARE = CLIM%HAS_BARE_REF_ET
            CDAT%NCOL = WBS%NCOL
            CDAT%NROW = WBS%NROW
            !
            IF(CDAT%CHECK_BARE .AND. (.NOT. SOIL%HAS_SOIL .OR. .NOT. SOIL%HAS_FRINGE))  THEN
                CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP. EITHER NSOIL = 0 OR CAPILARY FRINGE WAS NOT SPECIFIED IN SOIL BLOCK, YET THE CLIMATE BLOCK SPECIFIED EITHER REFERENCE ET AND/OR BARE SOIL EVAPORATION INDICATING SIMULATION OF BARE SOIL EVAPORATION. THIS WILL BE DISABLED BECAUSE IT REQUIRES A CAPILARY FRINGE FOR EVAPORATION CALCULATIONS.')
                CDAT%CHECK_BARE = FALSE
            END IF
            !
            ALLOCATE(CDAT%TTOT(CDAT%NCOL,CDAT%NROW), CDAT%TGWA(CDAT%NCOL,CDAT%NROW),CDAT%ETOT(CDAT%NCOL,CDAT%NROW), CDAT%EGWA(CDAT%NCOL,CDAT%NROW), SOURCE=DZ) !AUTO ALLOCATES ALL TO ZERO
            !
            IF(CDAT%CHECK_BARE) ALLOCATE(CDAT%BARE_FRAC(CDAT%NCOL,CDAT%NROW), CDAT%BARE_FRAC_RUNOFF(CDAT%NCOL, CDAT%NROW), SOURCE=DZ)  !, CDAT%BARE_FRAC_PRECIP(CDAT%NCOL, CDAT%NROW)
        END IF
        !
        IF(.NOT. CDAT%TFR_READ) THEN
            CDAT%TFR_READ = TRUE
            WBS%IRR_AREA = DZ
        END IF
        !
        IF(CDAT%CHECK_BARE) THEN
                                CALL WBS%SETUP_FALLOW_FRACTION_ARRAY(WBS%BARE_FRAC_RUNOFF, CDAT%BARE_FRAC_RUNOFF, TRUE)
                                !CALL WBS%SETUP_FALLOW_FRACTION_ARRAY(WBS%BARE_FRAC_PRECIP, CDAT%BARE_FRAC_PRECIP, TRUE)
                                !
                                WHERE (WBS%FID_ARRAY > Z) 
                                                     CDAT%BARE_FRAC = UNO
                                                    !CDAT%BARE_FRAC_PRECIP = UNO
                                ELSEWHERE
                                                     CDAT%BARE_FRAC = DZ
                                                     !CDAT%BARE_FRAC_PRECIP = DZ
                                END WHERE
                                !
                                ! SET UP BARE ELEVATIONS
                                CALL SETUP_CROP_ELEVATION(CDAT, WBS)
        END IF
        !
    ELSE!--------------------------------------------------------------------------------------------------------------------------------
        !
        IF(CDAT%TFR_READ) THEN
            !
            IF(PRESENT(LOAD)) THEN; LOAD_NEXT = LOAD
            ELSE;                   LOAD_NEXT = TRUE
            END IF
            !
            IF(LOAD_NEXT) THEN  !FIRST INITIALIZED IN INIT ROUTINE FOR SP1 DUE TO POTENTIAL STATIC FLAG
                              CALL CDAT%CID   %NEXT()
                              CALL CDAT%FRAC  %NEXT()
                              CALL CDAT%IRR   %NEXT()
                              CALL CDAT%ROOT  %NEXT()
                              CALL CDAT%Kc    %NEXT()  !MUST BE BEFORE CF%NEXT
                              CALL CDAT%CF    %NEXT()
                              CALL CDAT%FTR   %NEXT()
                              CALL CDAT%FEI   %NEXT()
                              CALL CDAT%FIESWP%NEXT()
                              CALL CDAT%FIESWI%NEXT()
                              CALL CDAT%PSI   %NEXT()
                              CALL CDAT%POND  %NEXT()
                              CALL CDAT%ADMD  %NEXT()
                              CALL CDAT%GW_INTER       %NEXT()
                              CALL CDAT%PRINT_CROP     %NEXT()
                              CALL CDAT%FEI_CHECK      %NEXT()
                              !!!CALL CDAT%CON_PRECIP_FRAC%NEXT()
                              CALL CDAT%ZERO_CU_TO_BARE%NEXT()
                              !
                              UPDATE = CDAT%CID%TRANSIENT .OR. (CDAT%MULTI_CROP_CELLS .AND. CDAT%FRAC%TRANSIENT) .OR. WBS%NEW_FID
            ELSE
                              UPDATE = FALSE
            END IF
            !
            !
        ELSE
            CDAT%HAS_PSI = FALSE
            !
            IF(CDAT%PSI%INUSE) THEN
                IF(CDAT%PSI%TRANSIENT .OR. ANY(NOT_NEAR_ZERO(CDAT%PSI%ARRAY,NEARZERO_12))) CDAT%HAS_PSI = TRUE
            END IF
            !
            IF (CDAT%Kc%INUSE         .AND. .NOT.CLIM%HAS_REF_ET     )  CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. "COEFFICIENT" KEYWORD FOUND IN CROP BLOCK, WHICH REQUIRES "REFERENCE_ET" TO BE SPECIFIED IN THE CLIMATE BLOCK. PLEASE INCLUDE REFERENCE ET OR SWITCH TO SPECIFYING CUNSUMPTIVE USE VALUES WITH "CONSUMPTIVE" KEYWORD.')
            IF (CDAT%MULTI_CROP_CELLS .AND. .NOT.CLIM%HAS_BARE_REF_ET)  CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. CROP BLOCK SPECIFIED KEYWORD "FRACTION" WHICH REQUIRES THAT THE CLIMATE BLOCK SPECIFY EITHER A THE KEYWORD "REFERENCE_ET" OR "POTENTIAL_EVAPORATION_BARE" SO THAT EVAPORATION OF PRECIPITATION AND/OR GROUNDWATER OVER BARE/FALLOW LAND CAN BE CALCULATED.')
            !
            IF(CDAT%MIN_BARE > NEAR_inf .AND. CLIM%HAS_BARE_REF_ET) THEN
                CDAT%MIN_BARE = NEARZERO_12  ! Enable MIN_BARE if undefined and BARE_REF_ET is defined
                WRITE(CDAT%IOUT,'(/2A, /A/)') 'MINIMUM BARE FRACTION IS: ', NUM2STR(CDAT%MIN_BARE),'ANY FRACTIONS LESS THAN THIS WILL BE AUTOMATICALLY SET TO ZERO.'
            END IF
            !
            IF(.NOT. SOIL%HAS_SOIL)  CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. CROP BLOCK IN USE BUT SOIL BLOCK WAS EITHER NOT SPECIFIED OR NSOIL = 0, YOU MUST SPECIFY AT LEAST ONE SOIL TYPE AND A CAPILARY FRINGE WHERE EVER THERE IS A CROP GROWN.')
            IF(.NOT. SOIL%HAS_FRINGE)CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. CROP BLOCK IN USE BUT SOIL BLOCK DID NOT SPECIFY A "CAPILLARY_FRINGE". YOU MUST SPECIFY AT LEAST ONE SOIL TYPE AND A CAPILARY FRINGE WHERE EVER THERE IS A CROP GROWN.')
            !
            IF(      SOIL%HAS_SOIL_COEF .AND. CDAT%HAS_PSI) THEN; WRITE(CDAT%LOUT,'(/A,/A/)') 'SOIL COEFICENTS AND CROP STRESS RESPONSE PRESSURES SPECIFIED.','FMP CROP CONSUMPTIVE USE CONCEPT ONE WILL BE USED'
            ELSE;                                                 WRITE(CDAT%LOUT,'(/A,/A/)') 'EITHER SOIL COEFICENTS AND/OR CROP STRESS RESPONSE PRESSURES --NOT-- SPECIFIED.','FMP CROP CONSUMPTIVE USE CONCEPT TWO WILL BE USED'
            END IF
            IF(.NOT. SOIL%HAS_SOIL_COEF .AND. CDAT%HAS_PSI) CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP SOIL AND CROP ERROR. CROP BLOCK SPECIFIED THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4) WITH KEYWORD "ROOT PRESSURE", BUT SOIL BLOCK DID NOT CONTAIN THE "COEFFICIENT" KEYWORD TO SPECIFY THE SOIL COEFICIENTS A, B, C, D, AND E (OR WITH KEYWORDS "SILT", "SANDYLOAM", OR "SILTYCLAY").')
            IF(CDAT%HAS_POND            .AND. CDAT%HAS_PSI) CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP BLOCK SPECIFIED "POND" KEYWORD AND THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4) WITH KEYWORD "ROOT PRESSURE" WHICH INDICATES CONCEPT 1.'//NL//'POND DEPTH IS ONLY APPLIED TO CROPS THAT USE CONCEPT 2'//NL//'WHICH OCCURS ONLY WHEN ALL FOUR PRESSURES SET TO ZERO'//NL//'(viz. [PSI1, PSI2, PSI3, PSI4] = [0,0,0,0]).', INLINE=TRUE)
            !WRITE(CDAT%LOUT,'(/A,/A/)')  'FMP CROP WARNING. CROP BLOCK SPECIFIED "POND" KEYWORD AND THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4) WITH KEYWORD "ROOT PRESSURE" WHICH INDICATES CONCEPT 1.','POND DEPTH IS ONLY APPLIED TO CROPS THAT USE CONCEPT 2, WHICH OCCURS ONLY WHEN ALL FOUR PRESSURES SET TO ZERO (viz. [PSI1, PSI2, PSI3, PSI4] = [0,0,0,0]).' !CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. CROP BLOCK SPECIFIED "POND" KEYWORD AND THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4) WITH KEYWORD "ROOT PRESSURE". THESE TWO FEATURES CAN NOT BE TURNED ON AT THE SAME TIME. PLEASE REMOVE THE PONDING DEPTH OR ROOT PRESSURES.')
            !IF(      SOIL%HAS_SOIL_COEF .AND. .NOT. CDAT%PSI%INUSE) CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP SOIL AND CROP ERROR. SOIL BLOCK SPECIFIED SOIL COEFICIENTS WITH "COEFFICIENT" KEYWORD WHICH REQUIRES THAT CROP BLOCK INCLUDE "ROOT PRESSURE" KEYWORD TO SEPCIFY THE FOUR WATER STRESS RESPONSE FUNCTION PRESSURES (PSI1, PSI2, PSI3, PSI4).')
            !
            CDAT%TFR_READ = TRUE
            UPDATE        = TRUE
            LOAD_NEXT     = TRUE
            !
            IF(CDAT%MIN_BARE .GE. UNO) CDAT%BARE_FRAC  = DZ  !NEVER SIMULATE BARE SOIL
            !
            IF(CLIM%HAS_PRECIP)  CDAT%HAS_Pe = CLIM%HAS_Pe
            !
            CDAT%TPOT_SHIFT_EPOT = CLIM%TPOT_SHIFT_EPOT
            !
        END IF
        !
        ! SET UP EACH CROPS ROW/COL FOR COMPRESSED STORAGE
        ! SET FARM ID LOCATION BY CROP  --MUST BE DONE AFTER POPULATING ROW/COL BECAUSE THERE MAYBE SFAC USING BYFARM IN COPY_INPUT
        IF(UPDATE) THEN
            !
            CALL PARSE_CROP_ROW_COL(CDAT, WBS%FID_ARRAY, WBS%NEW_FID)  !POPULATE CDAT%CROP%RC AND CDAT%CRPID
            !
            CALL SETUP_CROP_WBS_ID(CDAT, WBS)
            !
            ! CHECK FOR FALLOW CELLS AND NO ET_REF
            IF(.NOT. CDAT%MULTI_CROP_CELLS .AND. .NOT. CLIM%HAS_BARE_REF_ET) THEN
                !
                DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%CRPID(C,R) < Z ) 
                                CALL WRN%ADD(NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL)
                END DO
                IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP ERROR. CROP BLOCK SPECIFIED KEYWORD "LOCATION" LOADED AN ARRAY WITH A NEGATIVE CROP ID TO INDICATE FALLOW/BARE LAND.'//NL//  &
                                                   'THIS REQUIRES THAT THE CLIMATE BLOCK SPECIFY EITHER A THE KEYWORD "REFERENCE_ET" OR "POTENTIAL_EVAPORATION_BARE"'//NL//             &
                                                   'SO THAT EVAPORATION OF PRECIPITATION AND/OR GROUNDWATER OVER BARE/FALLOW LAND CAN BE CALCULATED.'//NL//                               &
                                                   'THE FOLLOWING ARE THE PROBLEM CROPS:'//NL// &
                                                   'CROP ROW       COLUMN',                     &
                                                    OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE ,KILL=TRUE)
                
            END IF
        END IF
        !
        NEW_IRR = FALSE
        IF( UPDATE .OR. (CDAT%IRR%TRANSIENT .AND. LOAD_NEXT) )  CALL CDAT%COPY_AND_SETUP_IRRIGATION(NEW_IRR)
        !
        IF( UPDATE .OR. (CDAT%GW_INTER%TRANSIENT .AND. LOAD_NEXT) ) CALL CDAT%CROP%COPY_INPUT(CDAT%GW_INTER)
        !
        IF( UPDATE .OR. (CDAT%FRAC  %TRANSIENT .AND. LOAD_NEXT) ) CALL CDAT%CROP%COPY_INPUT(CDAT%FRAC  )
        IF( UPDATE .OR. (CDAT%PSI   %TRANSIENT .AND. LOAD_NEXT) ) CALL CDAT%CROP%COPY_INPUT(CDAT%PSI   )
        IF( UPDATE .OR. (CDAT%FIESWP%TRANSIENT .AND. LOAD_NEXT) ) CALL CDAT%CROP%COPY_INPUT(CDAT%FIESWP)
        !
        IF( UPDATE .OR. (CDAT%FIESWI%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FIESWI%SFAC%HAS_EX3) &
                   .OR. (NEW_IRR .AND. 'FIESWI_BYIRR' == CDAT%FIESWI%TYP)                                     ) CALL CDAT%CROP%COPY_INPUT(CDAT%FIESWI)
        !
        IF( UPDATE .OR. (CDAT%ROOT  %TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ROOT  %SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%ROOT  )
        IF( UPDATE .OR. (CDAT%Kc    %TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%Kc    %SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%Kc    )
        IF( UPDATE .OR. (CDAT%CF    %TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%CF    %SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%CF    )
        IF( UPDATE .OR. (CDAT%POND  %TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%POND  %SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%POND  )
        !
        IF( UPDATE .OR. (CDAT%FTR%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FTR%SFAC%HAS_EX3)  ) CALL CDAT%CROP%COPY_INPUT(CDAT%FTR   )
        IF( UPDATE .OR. (CDAT%FTR%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FTR%SFAC%HAS_EX3) &
                   .OR. (CDAT%FEI%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FEI%SFAC%HAS_EX3) &
                   .OR. (NEW_IRR .AND. 'FEI_BYIRR' == CDAT%FIESWI%TYP)                                   ) CALL CDAT%CROP%COPY_INPUT(CDAT%FEI   )
        !
        IF( UPDATE .OR. (CDAT%ADMD%TRANSIENT.AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ADMD%SFAC%HAS_EX3) ) CALL CDAT%CROP%COPY_INPUT(CDAT%ADMD  )
        !
        !!!HAS_CON_PRECIP_FRAC = CDAT%CON_PRECIP_FRAC%INUSE
        !!!!
        !!!IF(HAS_CON_PRECIP_FRAC) THEN
        !!!   IF( UPDATE .OR. (CDAT%CON_PRECIP_FRAC%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%CON_PRECIP_FRAC%SFAC%HAS_EX3) ) THEN
        !!!       !
        !!!       CALL CDAT%CROP%COPY_INPUT(CDAT%CON_PRECIP_FRAC)
        !!!       !
        !!!       IF(CDAT%PCF_IS_FRAC ) THEN
        !!!           DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
        !!!           DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )  
        !!!                                                 IF    ( CDAT%CROP(I)%CON_PRECIP_FRAC(K) > UNO         ) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) = UNO
        !!!                                                 ELSEIF( CDAT%CROP(I)%CON_PRECIP_FRAC(K) <  NEARZERO_15) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) =  DZ
        !!!                                                 END IF
        !!!           END DO 
        !!!           END DO
        !!!       ELSE
        !!!           DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
        !!!           DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
        !!!                                                 IF    ( CDAT%CROP(I)%CON_PRECIP_FRAC(K) > UNO) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) = UNO
        !!!                                                 ELSEIF( CDAT%CROP(I)%CON_PRECIP_FRAC(K) <  NEGNEARZERO_15) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) =  D100
        !!!                                                 ELSEIF( CDAT%CROP(I)%CON_PRECIP_FRAC(K) <     NEARZERO_15) THEN
        !!!                                                         CDAT%CROP(I)%CON_PRECIP_FRAC(K) =  DZ
        !!!                                                 END IF
        !!!           END DO 
        !!!           END DO
        !!!       END IF
        !!!   END IF
        !!!END IF
        !
        !
        ! CHECK IF ROOT PRESSURES ARE IN DESCENDING ORDER. IF NOT THEN SORT AND WARN
        !
        IF( CDAT%PSI%INUSE .AND. (UPDATE .OR. (CDAT%PSI%TRANSIENT .AND. LOAD_NEXT)) ) THEN
              
              DO I=ONE, CDAT%NCROP
                 IF(CDAT%CROP(I)%N > Z) THEN
                     ASSOCIATE( PSI => CDAT%CROP(I)%PSI )
                         !
                         DO K=ONE, FOUR
                                  IF( ABS(PSI(K)) < NEARZERO_12 ) PSI(K) = DZ
                         END DO
                         !
                         IF( ANY(PSI .NE. DZ) ) THEN  
                                  DO K = ONE, THREE
                                        IF(PSI(K) < PSI(K+1)) THEN
                                            ERROR = ERROR//'ROOT PRESSURES (PSI) ARE NOT IN DESCENDING ORDER FOR CROP '//NUM2STR(I,-8)//' THEY WILL BE SORTED TO BE IN DECENDING ORDER (PLEASE CHECK YOUR INPUT).'//NL
                                            CALL SORT(PSI)
                                            EXIT
                                        END IF
                                  END DO
                         END IF
                     END ASSOCIATE
                 END IF
              END DO
              !
              IF (ERROR.NE.NL) THEN
                  CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=ERROR)
                  ERROR = NL
              END IF
        END IF
        !
        ! ALLOCATE NECESSARY ARRAYS
        IF (UPDATE) THEN
              DO I=ONE, CDAT%NCROP
              IF( CDAT%CROP(I)%N>Z ) THEN
                  IF( .NOT. ALLOCATED(CDAT%CROP(I)%AREA) .OR. CDAT%CROP(I)%N .NE. SIZE(CDAT%CROP(I)%AREA) ) THEN
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%T_CONCEPT, CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%AREA,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%CECT,   CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%CIR_INI,CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%CIR,    CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%EFF,    CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%RNOFF,  CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%DPERC,  CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%RNOFF_EXT, CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%DPERC_EXT,CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%ADRF,     CDAT%CROP(I)%N, SRC=TENTH)  !NOTE THAT THE DEFAULT IS 0.1
                                                                  !CALL ALLOC(CDAT%CROP(I)%EFL,    CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%DEMAND, CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%DEMAND_EXT,     CDAT%CROP(I)%N, SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%DEMAND_EXT_INI, CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%EGW,    CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TGW,    CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%EGWA,   CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TGWA,   CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TSURF,  CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TI,     CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%TP,     CDAT%CROP(I)%N,     SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%ANOX_LOSS,CDAT%CROP(I)%N,   SRC=DZ)
                                                                  CALL ALLOC(CDAT%CROP(I)%SOIL_LOSS,CDAT%CROP(I)%N,   SRC=DZ)
                                                                  !
                                                                  !CALL ALLOC(CDAT%CROP(I)%TSUR,  CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%TPPOT,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%EPPOT,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%EP,      CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%PRECIP,  CDAT%CROP(I)%N)  !Total Precip = CROP(I)%PRECIP + CROP(I)%RNOFF_Peff
                                                                  !CALL ALLOC(CDAT%CROP(I)%PSIA,  CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%GSE,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%SS,    CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%LXX,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%XX,    CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%THI,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%THD,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%EHI,   CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%EHD,   CDAT%CROP(I)%N)
                                                                  !
                                                                  CALL ALLOC(CDAT%CROP(I)%NOT_FALLOW, CDAT%CROP(I)%N)
                                                                  CALL ALLOC(CDAT%CROP(I)%NOT_FALLOW_SP, CDAT%CROP(I)%N)
                                                                  !
                                                                  IF(CDAT%HAS_Pe) CALL ALLOC(CDAT%CROP(I)%RNOFF_Peff,CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  !CALL ALLOC(CDAT%CROP(I)%GW_INTER, CDAT%CROP(I)%N)
                                                                  !
                                                                  IF(CDAT%HAS_PSI) THEN
                                                                                       CALL ALLOC(CDAT%CROP(I)%UXX, CDAT%CROP(I)%N)
                                                                                       CALL ALLOC(CDAT%CROP(I)%MXX, CDAT%CROP(I)%N)
                                                                  END IF
                                                                  !
                                                                  IF(CDAT%ITER_CALC_EGW_TGW_LOCK < inf_I) CALL ALLOC(CDAT%CROP(I)%TI_BAK, CDAT%CROP(I)%N, SRC=DZ)
                                                                  !
                                                                  ! THESE REQUIRE INITIALIZATION
                                                                  CDAT%CROP(I)%EHI = DZ
                                                                  CDAT%CROP(I)%EHD = DZ
                                                                  CDAT%CROP(I)%THI = DZ
                                                                  CDAT%CROP(I)%THD = DZ
                  END IF
              END IF
              END DO
              !
              ! SET UP CROP AREA
              !
              IF(CDAT%FRAC%INUSE) THEN
                               DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
                               DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )  
                                                                     CDAT%CROP(I)%AREA(K) = WBS%AREA(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) * CDAT%CROP(I)%FRAC(K)
                               END DO; END DO
              ELSE             
                               DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
                               DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N ) 
                                                                     CDAT%CROP(I)%AREA(K) = WBS%AREA(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))
                               END DO; END DO
              END IF
        END IF
        !
        ! SET UP ROOT-GROUNDWATER INTERACTION FLAG
        !
        IF( UPDATE .OR. (CDAT%GW_INTER%TRANSIENT .AND. LOAD_NEXT) ) THEN
            !
            CDAT%GW_ROOT_INTERACTION = FALSE
            GW_ROOT: DO I=ONE, CDAT%NCROP
                     DO K=ONE, CDAT%CROP(I)%N
                         IF(CDAT%CROP(I)%GW_INTER(K) > ONE) THEN
                               CDAT%GW_ROOT_INTERACTION = TRUE
                               EXIT GW_ROOT
                         END IF
                     END DO
                     END DO GW_ROOT
            !
            IF(.NOT. CDAT%ROOT%INUSE .AND. CDAT%GW_ROOT_INTERACTION)  THEN  !CHECK IF ROOT DEPTH IS REQUIRED
                IF(CDAT%HAS_PSI) THEN
                    ERROR = 'FMP CROP ERROR. THERE IS INTERACTION BETWEEN THE THE CROP ROOTS AND GROUNDWATER LEVEL TO CALCULATE TRANSPIRATION (DEFAULT BEHAIVOR).'//NL// &
                            'THAT IS "GROUNDWATER_ROOT_INTERACTION" = 2, 3, 4, OR 5 FOR SOME OF THE CROPS. --NOTE 5 IS THE DEFAULT WHEN NOT SPECIFIED.'//NL//  &
                            'THIS REQUIRES THE CROP ROOT DEPTH TO BE SPECIFRIED WITH "ROOT DEPTH" OR "ROOT_DEPTH" KEYWORD IN CROP BLOCK FOLLOWED BY EACH CROPS ROOT DEPTH THAT IS GREATER THAN ZERO (>0).'//NL// &
                            'EITHER SPECIFY POSITIVE NON-ZERO ROOT DEPTHS OR USE KEYWORD "GROUNDWATER_ROOT_INTERACTION" AND SET IT TO ONE TO INDICATE THERE IS NO GROUNDWATER ROOT INTERACTION.'
                    CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG=ERROR)
                ELSE
                    CALL CDAT%ROOT%INIT('ROOT', DZ, CDAT%IOUT, Z, CDAT%NCROP, ONE, Z, Z)
                    CALL CDAT%CROP%COPY_INPUT(CDAT%ROOT  )
                END IF
            END IF
        END IF
        !
        IF( CDAT%HAS_PSI .AND. CDAT%GW_ROOT_INTERACTION .AND. &
                                                        (     &
            UPDATE                                   .OR.     &
           (CDAT%GW_INTER%TRANSIENT .AND. LOAD_NEXT) .OR.     & 
           (CDAT%ROOT    %TRANSIENT .AND. LOAD_NEXT) .OR.     &
           (NEW_IRR .AND. CDAT%ROOT%SFAC%HAS_EX3)        )    &
          ) THEN
            !
            PRNT = FALSE
            IF(CDAT%HAS_PSI) THEN
               ROOT_LOOP: DO I=ONE,CDAT%NCROP
                            IF(ANY(NOT_NEAR_ZERO(CDAT%PSI%ARRAY(:,I),NEARZERO_12))) THEN 
                               DO K=ONE,CDAT%CROP(I)%N
                                     IF(CDAT%CROP(I)%GW_INTER(K) > ONE .AND. CDAT%CROP(I)%ROOT(K) .LE. DZ ) THEN
                                         PRNT(I) = TRUE
                                         CYCLE ROOT_LOOP
                                     END IF
                               END DO 
                            END IF
                          END DO ROOT_LOOP
               IF(ANY(PRNT)) THEN
                   ERROR='FMP CROP -- CHECK FOR VALID ROOT DEPTHS FOUND CROPS THAT HAD EITHER ZER0 OR LESS THAN ZER0 ROOT DEPTHS,'//NL//'WHICH IS NOT ALLOWED WHEN THERE IS A GROUNDWATER-ROOT INTERACTION FLAG GREATER THAN ONE (>1)'//NL//'THAT IS "GROUNDWATER_ROOT_INTERACTION" = 2, 3, 4, OR 5. --NOTE 5 IS THE DEFAULT WHEN NOT SPECIFIED.'//NL//'THE FOLLOWING IS A LIST OF CROPS THAT CONTAINED A ROOT DEPTH LESS THAN OR EQUAL TO ZER0 AND A GROUNDWATER_ROOT_INTERACTION GREATER THAN ONE:'//BLN//' CROP_ID '//BLN
                   DO I=ONE,CDAT%NCROP
                       IF(PRNT(I)) ERROR = ERROR//NUM2STR(I,-8)//NL
                   END DO
                   CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG=ERROR)
               END IF
            END IF
        END IF
        !
        !IF (UPDATE .AND. CDAT%GW_INTER%INUSE) THEN
        !   IF(CDAT%GW_INTER%LISTLOAD) THEN
        !       DO CONCURRENT ( I=ONE:CDAT%NCROP ); CDAT%CROP(I)%GW_INTER = CDAT%GW_INTER%LIST(I)
        !       END DO
        !   ELSE
        !                      DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
        !                      DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N ) 
        !                                                               R = CDAT%CROP(I)%RC(ONE,K) + CDAT%CROP(I)%LD - ONE  !LD=1 FOR NORMAL NROWxNCOL ARRAYS OTHERWISE IT POINTS TO THE CORRECT ROW FOR SPECIFIC CROW DUE TO FRACTIONAL LOADING.
        !                                                               C = CDAT%CROP(I)%RC(TWO,K)
        !                                                               CDAT%CROP(I)%GW_INTER(K) = CDAT%GW_INTER%ARRAY(C,R)
        !       END DO; END DO
        !   END IF
        !ELSEIF(UPDATE) THEN
        !       DO CONCURRENT ( I=ONE:CDAT%NCROP ); CDAT%CROP(I)%GW_INTER = TWO  !NOT SPECIFIED SO DO FULL INTERACTION
        !       END DO
        !END IF
        !
        IF(UPDATE .AND. WBS%HAS_WATERSTACK) CALL SETUP_CROP_FALLOW_RANK(CDAT, WBS)
        !
        ! CALCULATE CONSUMPTIVE USE IF USED. CALCULATE CROP COEFICIENTS*ETR IF USED
        !
        IF (UPDATE .OR. ((CDAT%Kc%TRANSIENT .OR. CDAT%CF%TRANSIENT) .AND. LOAD_NEXT) .OR. CLIM%REF_ET_TFR%TRANSIENT .OR. CLIM%REF_ET_BARE_TFR%TRANSIENT .OR. (NEW_IRR .AND. CDAT%Kc%SFAC%HAS_EX3) .OR. (NEW_IRR .AND. CDAT%CF%SFAC%HAS_EX3) ) THEN
            !
            DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z ) 
                                                                CDAT%CROP(I)%NOT_FALLOW_SP = TRUE  ! IF WATER STACKING IS ALLOWED SETUP RANKING. BY DEFAULT ALL CROPS ARE NOT CONSIDERD FALLOWED
            END DO
            !
            IF (CDAT%CF%INUSE) THEN
                  DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )   !, CDAT%CROP(I)%N>Z
                                                    !
                                                    IF(CDAT%CROP(I)%CF(K) > NEARZERO_30) THEN
                                                             CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%CF(K) * CDAT%CROP(I)%AREA(K)
                                                    ELSE
                                                             CDAT%CROP(I)%CU(K) = DZ
                                                    END IF
                  END DO; END DO
            ELSE
                  DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z ) 
                                                             CDAT%CROP(I)%CU = DZ
                  END DO
            END IF
            !
            IF     (CDAT%Kc%INUSE .AND. CDAT%ZERO_CU_TO_BARE%INUSE) THEN
                  DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N ) !  CU + Kc * Area* ETR
                                                    IF( (CDAT%CROP(I)%Kc(K) < NEARZERO_30 .AND. CDAT%CROP(I)%CU(K) < NEARZERO_30) ) THEN  ! CROP HAS BEEN FALLOWED -- .OR. CDAT%CROP(I)%FTR(K) < NEARZERO_30
                                                        IF(CDAT%ZERO_CU_TO_BARE%LIST(I) == ONE) THEN
                                                            CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%AREA(K) * CLIM%BARE_POT_EVAP(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))  !CLIM%REF_ET(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))
                                                            !CDAT%CROP(I)%FTR(K) = DZ
                                                        ELSE
                                                            CDAT%CROP(I)%CU(K)  = DZ
                                                            !CDAT%CROP(I)%FTR(K) = DZ
                                                            WRN%RAISED = TRUE
                                                        END IF
                                                        CDAT%CROP(I)%NOT_FALLOW_SP(K) = FALSE
                                                    ELSE
                                                        CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%CU(K) + ( CDAT%CROP(I)%Kc(K) * CDAT%CROP(I)%AREA(K) * CLIM%REF_ET(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) )
                                                    END IF   
                  END DO; END DO
            ELSEIF (CDAT%Kc%INUSE) THEN
                  DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N ) !  CU + Kc * Area* ETR
                                                    IF( (CDAT%CROP(I)%Kc(K) < NEARZERO_30 .AND. CDAT%CROP(I)%CU(K) < NEARZERO_30) ) THEN  ! CROP HAS BEEN FALLOWED -- .OR. CDAT%CROP(I)%FTR(K) < NEARZERO_30
                                                        CDAT%CROP(I)%CU(K)  = DZ
                                                        !CDAT%CROP(I)%FTR(K) = DZ
                                                        CDAT%CROP(I)%NOT_FALLOW_SP(K) = FALSE
                                                        WRN%RAISED = TRUE
                                                    ELSE
                                                        CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%CU(K) + ( CDAT%CROP(I)%Kc(K) * CDAT%CROP(I)%AREA(K) * CLIM%REF_ET(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) )
                                                    END IF   
                  END DO; END DO
            ELSEIF(CLIM%HAS_BARE_REF_ET .AND. CDAT%ZERO_CU_TO_BARE%INUSE) THEN
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%CU(K) < NEARZERO_30 ) ! CROP HAS BEEN FALLOWED  -- .OR. CDAT%CROP(I)%FTR(K) < NEARZERO_30
                                                       IF(CDAT%ZERO_CU_TO_BARE%LIST(I) == ONE) THEN
                                                            CDAT%CROP(I)%CU(K) = CDAT%CROP(I)%AREA(K) * CLIM%BARE_POT_EVAP(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))       !CLIM%REF_ET(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))
                                                            !CDAT%CROP(I)%FTR(K) = DZ
                                                        ELSE
                                                            CDAT%CROP(I)%CU(K)  = DZ
                                                            !CDAT%CROP(I)%FTR(K) = DZ
                                                            WRN%RAISED = TRUE
                                                        END IF
                                                        CDAT%CROP(I)%NOT_FALLOW_SP(K) = FALSE
                  END DO; END DO
            ELSE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%CU(K) < NEARZERO_30 ) ! .OR. CDAT%CROP(I)%FTR(K) < NEARZERO_30
                      !CALL WRN%ADD(NUM2STR(I,-8)//' '//NUM2STR(CDAT%CROP(I)%RC(ONE,K),-10)//' '//NUM2STR(CDAT%CROP(I)%RC(TWO,K),-10)//NL)
                      CDAT%CROP(I)%CU(K)  = DZ
                      !CDAT%CROP(I)%FTR(K) = DZ
                      CDAT%CROP(I)%NOT_FALLOW_SP(K) = FALSE
                      WRN%RAISED = TRUE
                  END DO; END DO
                  !CALL WRN%CHECK(HED='FMP CROP WARNING. FOUND EITHER A CONSUMPTIVE USE (CU) LESS THAN OR EQUAL TO ZERO.'//NL// &
                  !                       'THIS INDICATES THAT THE CROP IS FALLOWED OR BAREN LAND.'//NL//                                          &
                  !                       'HOWEVER, NEITHER A BARE SOIL POTENTIAL EVAPORATION (PAN EVAPORATION) OR REFERENCE ET WAS SPECIFIED.'//NL// &
                  !                       'THIS PREVENTS ANY BARE SOIL EVAPORATION CALCULATION.'//NL//                                                &
                  !                       'THIS WARNING IS TO POINT OUT THAT THE FOLLOWING CROPs WILL NOT HAVE ANY EVAPORATION OR TRANPIRATION ACROSS THE SPECIFIED ROW AND COLUMN.'//BLN// &
                  !                       ' CROP_ID ROW        COLUMN',  &
                  !                       OUTPUT=CDAT%LOUT, TAIL=NL, INIT=TRUE)
            END IF
            IF (WRN%RAISED) THEN
                WRN%RAISED = FALSE
                CALL WARNING_MESSAGE(OUTPUT=CDAT%IOUT, &
                                     MSG='FMP CROP WARNING. Found one or more crops (or crop locations) that had, one or both, its Consumptive Use (CU) and its Crop Coefficient (KC) less than or equal to zero.'//NL// &
                                     'NO EVAPORATION OR TRANSPIRATION CAN OCCUR AT THE LOCATIONS WITH ZERO VALUES.'//NL//                                          &
                                     'If you wish to have these converted to bare soil evaporation calculation, then you must specify "ZERO_CONSUMPTIVE_USE_BECOMES_BARE_SOIL" for the crop with a zero value'//NL// &
                                     'and either include in the input "POTENTIAL_EVAPORATION_BARE" or "REFERENCE_ET".'//BLN//'This is just a warning in case input intentionallys does not want to allow any evapotranspiration at specific locations in the model.')
            END IF
        END IF
        !
        ! -----------------------------------------------------
        DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z ) 
                                                            CDAT%CROP(I)%NOT_FALLOW    = CDAT%CROP(I)%NOT_FALLOW_SP
        END DO
        ! -----------------------------------------------------
        !
        ! CALCULATE ADDITIONAL DEMAND AS VOLUME IF SPECIFIED AS FLUX
        !
        IF(CDAT%DEMAND_EXT_FLUX) THEN
           IF( UPDATE .OR. (CDAT%ADMD%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ADMD%SFAC%HAS_EX3) ) THEN
               DO CONCURRENT ( I=ONE:CDAT%NCROP     ) 
               DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                    CDAT%CROP(I)%ADMD(K) = CDAT%CROP(I)%ADMD(K) * CDAT%CROP(I)%AREA(K)
               END DO; END DO
           END IF
        END IF
        !
        ! IF DEMAND NEAR ZERO, SET TO ZERO TO IMPROVE SIMULATION SPEED
        !
        IF(CDAT%HAS_DEMAND_EXT) THEN
           IF( UPDATE .OR. (CDAT%ADMD%TRANSIENT.AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ADMD%SFAC%HAS_EX3) ) THEN
               DO CONCURRENT (I=ONE:CDAT%NCROP)
               DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, NEAR_ZERO(CDAT%CROP(I)%ADMD(K), NEARZERO_10) )
                     CDAT%CROP(I)%ADMD(K) = DZ
               END DO; END DO
           END IF
        END IF
        !
        !###########################################################################################################
        ! CHECK FOR BAD INPUT EFF>1, FTR>1, FTR+FEI  (EFFICIENCIES)
        !
        IF(UPDATE .OR. NEW_IRR) THEN
                  DO I=ONE, CDAT%NCROP
                  DO K=ONE, CDAT%CROP(I)%N
                      IF( CDAT%CROP(I)%IRR(K) > CDAT%NIRRG .OR. CDAT%CROP(I)%IRR(K) < Z ) THEN
                                                                                R   = CDAT%CROP(I)%RC(ONE,K)
                                                                                C   = CDAT%CROP(I)%RC(TWO,K)
                                                                                IRR = CDAT%CROP(I)%IRR(K)
                                                                                CALL WRN%ADD(BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(R,-10)//BLNK//NUM2STR(C,-10)//BLNK//NUM2STR(IRR,-10)//NL)
                      END IF
                  END DO; END DO
                  IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP ERROR. IRRIGATION FLAG GREATER THAN GLOBAL DIMENSION "NIRRIGATE" OR LESS THAN ZERO (NEGATIVE INTEGER),'//NL// &
                                                     'THIS WILL RESULT IN A BAD INDEX FOR THE EFFICIENCY ARRAY. PLEASE SET THE IRRIGATION FLAG BETWEEN 0 AND '//NUM2STR(CDAT%NIRRG)//BLN//  &
                                                     'INPUT MUST BE FIXED TO CONTINUE SIMULATION.'      //BLN//  &
                                                     'HERE IS A LIST OF CROPS AND THEIR IRRIGATION FLAG'//BLN//  &
                                                     ' CROP_ID  ROW      COLUMN   IRR_FLAG',                   &
                                                      OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE ,KILL=TRUE)
        END IF
        !
        IF(UPDATE .OR. (CDAT%FTR%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FTR%SFAC%HAS_EX3)) THEN
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FTR(K) > UNO )
                                                                          CDAT%CROP(I)%FTR(K) = UNO
                                                                       IF(CDAT%CROP(I)%FTR(K) > NEAR_ONE) THEN
                                                                              IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF TRANPIRATION (FTR) > 1.0, RESET TO 1.0'//NL
                                                                              PRNT(I) = FALSE
                                                                       END IF
                  END DO; END DO
                  !
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FTR(K) < DZ )
                                                              CDAT%CROP(I)%FTR(K)  = DZ
                                                              IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF TRANPIRATION (FTR) < 0.0, RESET TO 0.0'//NL
                                                              PRNT(I) = FALSE
                  END DO; END DO
        END IF
        !
        IF(UPDATE .OR. ((CDAT%FTR%TRANSIENT.OR.CDAT%FEI%TRANSIENT) .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FTR%SFAC%HAS_EX3) .OR. (NEW_IRR .AND. CDAT%FEI%SFAC%HAS_EX3) .OR. (NEW_IRR .AND. 'FEI_BYIRR' == CDAT%FEI%TYP) ) THEN !CORRECTION FOR NEGATIVE FEI
                  !PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FEI(K)  < DZ )
                                                                          CDAT%CROP(I)%FEI(K)  = UNO - CDAT%CROP(I)%FTR(K)
                                                                          !IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF EVAPORATION FROM IRRIGATION (FEI) < 0.0, SO IT WAS SET TO 1 - FRACTION OF TRANPIRATION (FTR)'//NL
                                                                          !PRNT(I) = FALSE
                  END DO; END DO
                  !
                  IF(CDAT%FEI_CHECK%INUSE) THEN
                  !  PRNT = TRUE
                    DO CONCURRENT (I=ONE:CDAT%NCROP, CDAT%FEI_CHECK%LIST(I) == ONE ) !CHECK IF FTR + FEI > 1
                    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FTR(K) + CDAT%CROP(I)%FEI(K) > NEAR_ONE )
                                                                        CDAT%CROP(I)%FEI(K) = UNO - CDAT%CROP(I)%FTR(K) 
                                                                        !
                                                                        IF(CDAT%CROP(I)%FEI(K) < DZ) CDAT%CROP(I)%FEI(K) = DZ
                                                                        !
                                                                        !P = CDAT%CROP(I)%FTR(K) + CDAT%CROP(I)%FEI(K)
                                                                        !CDAT%CROP(I)%FTR(K) = CDAT%CROP(I)%FTR(K) / P
                                                                        !CDAT%CROP(I)%FEI(K) = CDAT%CROP(I)%FEI(K) / P
                                                                        !IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF TRANPIRATION (FTR) + FRACTION OF EVAPORATION FROM IRRIGATION (FEI) > 1.0, PROPERTIES SCALED TO MAKE SUM EQUAL TO 1.0'//NL
                                                                        !PRNT(I) = FALSE
                    END DO; END DO
                  END IF
        END IF
        !
        IF(UPDATE .OR. (CDAT%FIESWP%TRANSIENT .AND. LOAD_NEXT)) THEN
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FIESWP(K) < DZ )
                                                                          CDAT%CROP(I)%FIESWP(K) = DZ
                                                                          IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF INEFFICIENT LOSSES FROM PRECIP (FIESWP) < 0.0, RESET TO 0.0'//NL
                                                                          PRNT(I) = FALSE
                  END DO; END DO
                  !
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FIESWP(K) > UNO )
                                                                          CDAT%CROP(I)%FIESWP(K) = UNO
                                                                       IF(CDAT%CROP(I)%FIESWP(K) > NEAR_ONE) THEN
                                                                              IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF INEFFICIENT LOSSES FROM PRECIP (FIESWP) < 1.0, RESET TO 1.0'//NL
                                                                              PRNT(I) = FALSE
                                                                       END IF
                  END DO
                  END DO
        END IF
        !
        IF(UPDATE .OR. (CDAT%FIESWI%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%FIESWI%SFAC%HAS_EX3)) THEN
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FIESWI(K) < DZ )
                                                                          CDAT%CROP(I)%FIESWI(K)  = DZ
                                                                          IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF INEFFICIENT LOSSES FROM IRRIGATION (FIESWI) < 0.0, RESET TO 0.0'//NL
                                                                          PRNT(I) = FALSE
                  END DO
                  END DO
                  !
                  PRNT = TRUE
                  DO CONCURRENT (I=ONE:CDAT%NCROP)
                  DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FIESWI(K) > UNO )
                                                                          CDAT%CROP(I)%FIESWI(K) = UNO
                                                                       IF(CDAT%CROP(I)%FIESWI(K) > NEAR_ONE) THEN
                                                                              IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  FRACTION OF INEFFICIENT LOSSES FROM IRRIGATION (FIESWI) < 1.0, RESET TO 1.0'//NL
                                                                              PRNT(I) = FALSE
                                                                       END IF
                  END DO
                  END DO
        END IF
        !
        IF (UPDATE .OR. (CDAT%GW_INTER%TRANSIENT .AND. LOAD_NEXT)) THEN
                  DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                                                              SELECT CASE (CDAT%CROP(I)%GW_INTER(K))
                                                              !
                                                              CASE( Z, ONE, TWO, THREE, FOUR, FIVE );  CONTINUE
                                                              CASE DEFAULT
                                                                         CDAT%CROP(I)%GW_INTER(K) = FIVE
                                                                         IF(PRNT(I)) ERROR = ERROR//BLNK//NUM2STR(I,-8)//'  GROUNDWATER_ROOT_INTERACTION MUST BE SET TO 0, 1, 2, 3, 4 or 5 NOW SET TO 5'//NL
                                                                         PRNT(I) = FALSE
                                                              END SELECT
                  END DO
                  END DO
        END IF
        !
        IF (ERROR.NE.NL) THEN
                 ERROR='FMP CROP -- CHECK FOR VALID PROPERTY VALUES THE FOLLOWING WERE ADJUSTED TO BE CORRECT:'//BLN//' CROP_ID   ISSUE'//ERROR
                 CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=ERROR)
                 ERROR = NL
        END IF
        !
        IF(UPDATE .OR. WBS%EFF_TFR%TRANSIENT .OR. NEW_IRR) THEN
                  CALL SETUP_CROP_EFFICIENCY(CDAT, WBS, FALSE)  !ONLY CALLED FOR CHECKING PURPOSES (FALSE)
                  !
                  DO CONCURRENT ( I=ONE:CDAT%NCROP )
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%EFF(K) <= DZ .AND. CDAT%CROP(I)%IRR(K) > Z )
                                                        F   = CDAT%CROP(I)%FID(K)
                                                        IRR = CDAT%CROP(I)%IRR(K)
                                                        R = CDAT%CROP(I)%RC(ONE,K)
                                                        C = CDAT%CROP(I)%RC(TWO,K)
                                                        CALL WRN%ADD(BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(IRR,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//NL)
                                                        !CDAT%CROP(I)%EFF(K) = DZ
                                                        CDAT%CROP(I)%IRR(K) = Z
                  END DO
                  END DO
                  IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP WARNING EFFICIENCY <= 0.0 WITH IRRIGATION > 0'//NL//'*** IRRIGATION FOR CROP TURNED OFF DUE TO ZERO EFFECIENCY! ***'//BLN// &
                                                     ' CROP_ID  WBS      IRR      ROW      COLUMN',                   &
                                                      OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
                  !
                  DO CONCURRENT ( I=ONE:CDAT%NCROP )
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%EFF(K) > UNO .AND. CDAT%CROP(I)%IRR(K) > Z )
                                                     IF(CDAT%CROP(I)%EFF(K) > NEAR_ONE) THEN
                                                            F   = CDAT%CROP(I)%FID(K)
                                                            IRR = CDAT%CROP(I)%IRR(K)
                                                            R = CDAT%CROP(I)%RC(ONE,K)
                                                            C = CDAT%CROP(I)%RC(TWO,K)
                                                            CALL WRN%ADD(BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(IRR,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//NL)
                                                     END IF
                                                     CDAT%CROP(I)%EFF(K) = UNO
                  END DO
                  END DO
                  IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP WARNING EFFICIENCY > 1.0, '//NL//'EFFICIENCY RESET TO 1.0'//BLN// &
                                                     ' CROP_ID  WBS      IRR      ROW      COLUMN',                   &
                                                      OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
        END IF
        !
        ! SET ADRF AND CHECK FOR INPUT ERROR
        IF(WBS%ADRF_TFR%INUSE) THEN
          IF(UPDATE .OR. WBS%ADRF_TFR%TRANSIENT .OR. (NEW_IRR .AND. WBS%ADRF_TFR%SFAC%HAS_EX3)) THEN
                    !
                    DO CONCURRENT   ( I=ONE:CDAT%NCROP,    CDAT%CROP(I)%N > Z )
                      DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                          !
                          IF (CDAT%CROP(I)%IRR(K)>Z) THEN !                                           FID                 COL                    ROW             IRRIGATION TYPE
                                                          CDAT%CROP(I)%ADRF(K) = WBS%ADRF_TFR%GET( CDAT%CROP(I)%FID(K),CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K),CDAT%CROP(I)%IRR(K) )
                                                          !
                                                          IF(CDAT%CROP(I)%ADRF(K) .NE. CDAT%CROP(I)%ADRF(K)) CDAT%CROP(I)%ADRF(K) = DZ
                          ELSE
                                                          CDAT%CROP(I)%ADRF(K) = DZ
                          END IF
                      END DO
                      !
                      CALL CROP_INPUT_APPLY_SFAC( CDAT%CROP(I)%ADRF, WBS%ADRF_TFR%SFAC, CDAT%CROP(I)%N, I, CDAT%CROP(I)%FID, CDAT%CROP(I)%IRR )
                      !
                    END DO
                    !
                    !CHECK FOR BAD ADRF VALUES
                    DO CONCURRENT ( I=ONE:CDAT%NCROP )
                    DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%ADRF(K) < DZ .AND. CDAT%CROP(I)%IRR(K) > Z )
                                                          CDAT%CROP(I)%ADRF(K) = DZ
                                                          IF(CDAT%CROP(I)%ADRF(K) < NEGNEARZERO_10) THEN
                                                             F   = CDAT%CROP(I)%FID(K)
                                                             IRR = CDAT%CROP(I)%IRR(K)
                                                             R = CDAT%CROP(I)%RC(ONE,K)
                                                             C = CDAT%CROP(I)%RC(TWO,K)
                                                             CALL WRN%ADD(BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(IRR,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//NL)
                                                          END IF
                    END DO
                    END DO
                    IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP WARNING ADDITIONAL_IRRIGATION_RUNOFF_FRACTION < 0.0, '//NL//'ADDITIONAL_IRRIGATION_RUNOFF_FRACTION RESET TO 0.0'//BLN// &
                                                       ' CROP_ID  WBS      IRR      ROW      COLUMN',                   &
                                                        OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
                    !
                    DO CONCURRENT ( I=ONE:CDAT%NCROP )
                    DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%ADRF(K) > UNO .AND. CDAT%CROP(I)%IRR(K) > Z )
                                                          CDAT%CROP(I)%ADRF(K) = UNO
                                                          IF(CDAT%CROP(I)%ADRF(K) > NEAR_ONE) THEN 
                                                              F   = CDAT%CROP(I)%FID(K)
                                                              IRR = CDAT%CROP(I)%IRR(K)
                                                              R = CDAT%CROP(I)%RC(ONE,K)
                                                              C = CDAT%CROP(I)%RC(TWO,K)
                                                              CALL WRN%ADD(BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(IRR,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//NL)
                                                          END IF
                    END DO
                    END DO
                    IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP WARNING ADDITIONAL_IRRIGATION_RUNOFF_FRACTION > 1.0, '//NL//'ADDITIONAL_IRRIGATION_RUNOFF_FRACTION RESET TO 1.0'//BLN// &
                                                       ' CROP_ID  WBS      IRR      ROW      COLUMN',                   &
                                                        OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
          END IF
        !ELSEIF(UPDATE) THEN
        !    DO CONCURRENT( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z ); CDAT%CROP(I)%ADRF = TENTH  !AUTOMATICALLY SET TO 0.1
        !    END DO
        END IF
        !
        IF (UPDATE .OR. (CDAT%ADMD%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. CDAT%ADMD%SFAC%HAS_EX3)) THEN
              DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
              DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%ADMD(K) .NE. DZ .AND. CDAT%CROP(I)%IRR(K) == Z )
                                                F   = CDAT%CROP(I)%FID(K)
                                                IRR = CDAT%CROP(I)%IRR(K)
                                                R = CDAT%CROP(I)%RC(ONE,K)
                                                C = CDAT%CROP(I)%RC(TWO,K)
                                                CALL WRN%ADD(BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//BLNK//NUM2STR(CDAT%CROP(I)%ADMD(K))//NL)
                                                CDAT%CROP(I)%ADMD(K) = DZ
              END DO
              END DO
              IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP -- CHECK FOR VALID "ADDED_DEMAND" HAD CROPS WITH DEMANDS THAT DO NOT HAVE AN IRRIGATION TYPE'//NL// &
                                                 'SPECIFICALLY IT HAD "IRRIGATION=0" SO NO WAY TO SATISFY THE ADDITIONAL DEMAND.'//NL// &
                                                 'THE FOLLOWING CROPS HAD THEIR "ADDED_DEMAND" SET TO ZER0 DUE TO IRRIGATION=0:'//BLN// &
                                                 ' CROP_ID  WBS      ROW      COLUMN   ADDED_DEMAND',                   &
                                                  OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
        END IF
        !
        IF(WBS%HAS_CROP_FLUX .OR. WBS%HAS_CROP_VOLR) THEN
           IF(UPDATE .OR. WBS%CROP_VOLR_TFR%TRANSIENT .OR. WBS%CROP_FLUX_TFR%TRANSIENT .OR. NEW_IRR) THEN
               !
               CALL CHECK_WBS_ADDED_DEMAND(CDAT,WBS)  !THE ADDED DEMAND IS ACTUALLY ADDED IN THE FMP_MAIN_DRIVER
               !
           END IF
        END IF
        !
        !!!IF(WBS%EFL_TFR%INUSE) THEN
        !!!  IF(UPDATE .OR. WBS%EFL_TFR%TRANSIENT) THEN
        !!!            !
        !!!            DO CONCURRENT   ( I=ONE:CDAT%NCROP,    CDAT%CROP(I)%N > Z )
        !!!              DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
        !!!                  !
        !!!                  IF (CDAT%CROP(I)%IRR(K)>Z) THEN !                                           FID                 COL                    ROW             IRRIGATION TYPE
        !!!                                                  CDAT%CROP(I)%EFL(K) = WBS%EFL_TFR%GET( CDAT%CROP(I)%FID(K),CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K),CDAT%CROP(I)%IRR(K) )
        !!!                                                  !
        !!!                                                  IF(CDAT%CROP(I)%EFL(K) .NE. CDAT%CROP(I)%EFL(K)) CDAT%CROP(I)%EFL(K) = DZ
        !!!                  ELSE
        !!!                                                  CDAT%CROP(I)%EFL(K) = DZ
        !!!                  END IF
        !!!              END DO
        !!!              !
        !!!              CALL CROP_INPUT_APPLY_SFAC( CDAT%CROP(I)%EFL, WBS%EFL_TFR%SFAC, CDAT%CROP(I)%N, I, CDAT%CROP(I)%FID, CDAT%CROP(I)%IRR )
        !!!              !
        !!!            END DO
        !!!            !
        !!!            DO CONCURRENT ( I=ONE:CDAT%NCROP )
        !!!            DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%EFL(K) < DZ .AND. CDAT%CROP(I)%IRR(K) > Z )
        !!!                                                  CDAT%CROP(I)%EFL(K) = DZ
        !!!                                                  R = CDAT%CROP(I)%FID(K)
        !!!                                                  C = CDAT%CROP(I)%IRR(K)
        !!!                                                  ERROR = ERROR//BLNK//NUM2STR(I,-8)//NUM2STR(R,-8)//NUM2STR(C,-8)//'  EFFICIENCY < 0.0, RESET TO 0.0'//NL
        !!!            END DO
        !!!            END DO
        !!!            !
        !!!            IF (ERROR.NE.NL)  ERROR = ERROR//BLN
        !!!  END IF
        !!!  !
        !!!  IF (ERROR.NE.NL) THEN
        !!!           ERROR='FMP CROP -- CHECK FOR VALID EVAPORATION_LOSS_FRACTION REQUIED THE FOLLOWING TO BE SET TO ZERO BECAUSE THEY WERE NEGATIVE VALUES:'//BLN//' CROP_ID    WBS  IRR   ISSUE'//ERROR
        !!!           CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=ERROR)
        !!!           ERROR = NL
        !!!  END IF
        !!!ELSEIF(UPDATE) THEN
        !!!    DO CONCURRENT( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z ); CDAT%CROP(I)%EFL = DZ
        !!!    END DO
        !!!END IF
        !
        !###########################################################################################################
        !
        ! SET UP TRANSPIRATION MODEL USED -----
        !
        IF( UPDATE                           &
                .OR. WBS%EFF_TFR%TRANSIENT   &
                .OR. CDAT%FTR%TRANSIENT      &
                .OR. NEW_IRR                 &
                .OR. CDAT%GW_INTER%TRANSIENT &
                .OR. CDAT%PSI%TRANSIENT      &
                .OR. CDAT%CF%TRANSIENT       &
                .OR. CDAT%Kc%TRANSIENT       &
          ) THEN
            !
            ! REUSING PRNT VARIABLE TO FOR IF CROP HAS ROOT PRESSURES
            PRNT = FALSE
            IF(CDAT%HAS_PSI) THEN
               DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
                   IF(ANY(CDAT%CROP(I)%PSI .NE. DZ)) THEN
                       PRNT(I)=TRUE
                   ELSE
                       PRNT(I)=FALSE
                   END IF
                   !IF(ALL(NEAR_ZERO(CDAT%CROP(I)%PSI, NEARZERO_12))) THEN
                   !                                                      PRNT(I)=FALSE
                   !ELSE
                   !                                                      PRNT(I)=TRUE
                   !END IF
               END DO
            END IF
            !
            DO CONCURRENT (I=ONE:CDAT%NCROP)
            DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
                ! 0 = No T/No CU
                ! 1 = No GW Interaction/Full CU from Surf/No  Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
                ! 2 = No GW Uptake/ HAS Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
                ! 3 = No Anoxia/No Soil Stress - But has GW Uptake
                ! 4 = No Anoxia - But has Soil Stress and GW Uptake
                ! 5 = Full Interaction HAS Anoxia/Soil Stress Reducation, HAS Root-Groundwater Uptake  
                !
                ! 100 = Linear Crop Model (CONCEPT 2)
                ! 200 = Empirical Steady State Model (Concept 1)
                !
                ! Sum indicates crop T
                IF(.NOT. CDAT%CROP(I)%NOT_FALLOW_SP(K) .OR.   &
                         CDAT%CROP(I)%GW_INTER(K) == Z .OR.   &
                         CDAT%CROP(I)%FTR(K)      == DZ ) THEN    !No Crop/Bare land/No CU
                                                          CDAT%CROP(I)%T_CONCEPT(K) = Z
                ELSEIF(CDAT%CROP(I)%GW_INTER(K) == ONE) THEN    !No Crop-Root GW Interaction -- Full CU
                                                          CDAT%CROP(I)%T_CONCEPT(K) = ONE
                ELSEIF(PRNT(I)) THEN  !HAS PSI
                                                          CDAT%CROP(I)%T_CONCEPT(K) = 200 + CDAT%CROP(I)%GW_INTER(K) !Uses root pressurews
                ELSE
                                                          CDAT%CROP(I)%T_CONCEPT(K) = 100 + CDAT%CROP(I)%GW_INTER(K)     !uses linear model
                END IF
                !
            END DO; END DO
        END IF
        !
        !###########################################################################################################
        !
        !
        ! CALCULATE CECT = FEI/FTR
        !
        IF( UPDATE .OR. (CDAT%FTR%TRANSIENT.OR.CDAT%FEI%TRANSIENT .AND. LOAD_NEXT) .OR. (NEW_IRR .AND. (CDAT%FTR%SFAC%HAS_EX3 .OR. CDAT%FEI%SFAC%HAS_EX3)) ) THEN
              DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
              DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                                                                      IF(CDAT%CROP(I)%FTR(K) > DZ) THEN
                                                                          CDAT%CROP(I)%CECT(K) = CDAT%CROP(I)%FEI(K)/CDAT%CROP(I)%FTR(K)  !RATIO USED BY A NUMBER OF CALCULATIONS, KEEP IN MEMORY FOR SPEED
                                                                      ELSE
                                                                          CDAT%CROP(I)%CECT(K) = DZ
                                                                      END IF
              END DO; END DO
        END IF
        !
        !###########################################################################################################
        !
        !
        ! CALCULATE EGW, TGW
        !
        !===== FOR CROP CONDITIONS:                                                             ====================
        !        CALCULATE POTENTIAL TRANSPIRATORY AND EVAPORATIVE CONSUMPTIVE USE, AS WELL AS
        !        MAXIMUM TRANSPIRATION AND MAXIMUM EVAPORATION FROM GROUNDWATER.
        !       FOR NON-CROP FALLOW CONDITIONS:
        !        SET POTENTIAL TRANSPIRATION = 0, AND POTENTIAL EVAPORATION EQUAL TO
        !         PRECIPTIATION OR REFERENCE ET, WHICH EVER IS LESS.
        !       (if consumptive use and precipitation were read for every stress period; however
        !        if calculated as time step averages --> AD ROUTINE)
        !        Note: the 2D-CU array and therefore also the max.-TGW array ignores
        !              small scale 'no-flow and constant head details,' because
        !              net-recharge will not be calculated for such cells.
        !
        DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
        DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
            !
            IF(CDAT%CROP(I)%T_CONCEPT(K) == Z) THEN
               CDAT%CROP(I)%TGW(K) = DZ
            ELSE
               CDAT%CROP(I)%TGW(K) = CDAT%CROP(I)%FTR(K)  * CDAT%CROP(I)%CU(K) 
               !
               IF(CDAT%CROP(I)%TGW(K) < NEARZERO_15) CDAT%CROP(I)%TGW(K) = DZ
            END IF
            !
            !IF(.NOT. CDAT%TPOT_SHIFT_EPOT) THEN
            !   !CDAT%CROP(I)%EGW(K) = (UNO - CDAT%CROP(I)%FTR(K)) * CDAT%CROP(I)%CU(K)
            !   CDAT%CROP(I)%EGW(K) = CDAT%CROP(I)%CU(K) - CDAT%CROP(I)%TGW(K)
            !   !
            !   IF(CDAT%CROP(I)%EGW(K) < NEARZERO_15) CDAT%CROP(I)%EGW(K) = DZ
            !END IF
            !
        END DO; END DO
        !
        !WBS%TPRECIP = DZ
        !WBS%EPRECIP = DZ
        IF(CLIM%HAS_PRECIP) THEN  !Note that, Crop Total Precip = CROP(I)%PRECIP + CROP(I)%RNOFF_Peff, cause PRECIP_EFFECTIVE is subtracted out
            !
            DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
            DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                           CDAT%CROP(I)%PRECIP(K) = CLIM%PRECIP(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) * CDAT%CROP(I)%AREA(K)
            END DO
            END DO
            !
            IF(CDAT%HAS_Pe) THEN
               DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
               DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                              !
                              P = CLIM%PRECIP_EFFECTIVE(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) * CDAT%CROP(I)%AREA(K)
                              !
                              IF (CDAT%CROP(I)%PRECIP(K) - P > NEARZERO_15) THEN
                                  !
                                  CDAT%CROP(I)%RNOFF_Peff(K) = CDAT%CROP(I)%PRECIP(K) - P  !Excess precip from effective table
                                  CDAT%CROP(I)%PRECIP(K) = P                               !Precip that is consumable is less
                              ELSE
                                  CDAT%CROP(I)%RNOFF_Peff(K) = DZ
                              END IF
               END DO
               END DO
            END IF
            !                               !Parse precipit for consumption
            DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
            DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
                !
                P = CDAT%CROP(I)%PRECIP(K)
                !
                IF( CDAT%CROP(I)%T_CONCEPT(K) == Z ) THEN
                    CDAT%CROP(I)%TPPOT(K) = DZ
                ELSE
                    CDAT%CROP(I)%TPPOT(K) = CDAT%CROP(I)%FTR(K) * P
                END IF
                
                CDAT%CROP(I)%EPPOT(K) = P - CDAT%CROP(I)%TPPOT(K)
                !
                IF(CDAT%CROP(I)%TPPOT(K) > CDAT%CROP(I)%TGW(K)) CDAT%CROP(I)%TPPOT(K) = CDAT%CROP(I)%TGW(K)
                !
                IF(CDAT%CROP(I)%TPPOT(K) < NEARZERO_15) CDAT%CROP(I)%TPPOT(K) = DZ
                IF(CDAT%CROP(I)%EPPOT(K) < NEARZERO_15) CDAT%CROP(I)%EPPOT(K) = DZ
                !
            END DO; END DO
            !!!DO CONCURRENT ( I=ONE:CDAT%NCROP ) 
            !!!DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
            !!!    !
            !!!    P = CLIM%PRECIP(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K)) * CDAT%CROP(I)%AREA(K)
            !!!    !
            !!!    IF(P < NEARZERO_15) P = DZ
            !!!    !
            !!!    CDAT%CROP(I)%PRECIP(K) = P
            !!!    !
            !!!    IF(HAS_CON_PRECIP_FRAC) THEN
            !!!          !
            !!!          IF    (CDAT%CROP(I)%CON_PRECIP_FRAC(K) < NEARZERO_15 .OR. P < NEARZERO_15 ) THEN
            !!!                                                                    P = DZ
            !!!          ELSEIF(CDAT%PCF_IS_FRAC) THEN
            !!!                                   IF(CDAT%CROP(I)%CON_PRECIP_FRAC(K) < SUB_ONE_5) THEN
            !!!                                          !
            !!!                                          P = P * CDAT%CROP(I)%CON_PRECIP_FRAC(K)  !ADJUST TO ONLY ALLOW FOR CONSUMABLE PRECIP
            !!!                                          !
            !!!                                          IF( P < NEARZERO_15 ) P = DZ
            !!!                                   END IF
            !!!          ELSEIF(CDAT%CROP(I)%CON_PRECIP_FRAC(K) < D29) THEN
            !!!              DTMP = CDAT%CROP(I)%CON_PRECIP_FRAC(K) * CDAT%CROP(I)%AREA(K)  !PRECIP CONSUMPTION POTENTIAL
            !!!              !
            !!!              IF(P > DTMP) P = DTMP
            !!!          END IF
            !!!    END IF
            !!!    !
            !!!    CDAT%CROP(I)%TPPOT(K) = CDAT%CROP(I)%FTR(K) * P
            !!!    CDAT%CROP(I)%EPPOT(K) = P - CDAT%CROP(I)%TPPOT(K)
            !!!    !
            !!!    IF(CDAT%CROP(I)%TPPOT(K) > CDAT%CROP(I)%TGW(K)) CDAT%CROP(I)%TPPOT(K) = CDAT%CROP(I)%TGW(K)
            !!!    !IF(CDAT%CROP(I)%EPPOT(K) > CDAT%CROP(I)%EGW(K)) CDAT%CROP(I)%EPPOT(K) = CDAT%CROP(I)%EGW(K)
            !!!    !
            !!!    !CDAT%CROP(I)%TPPOT(K) = MIN( P *        CDAT%CROP(I)%FTR(K),  CDAT%CROP(I)%TGW(K) ) 
            !!!    !CDAT%CROP(I)%EPPOT(K) = MIN( P * (UNO - CDAT%CROP(I)%FTR(K)), CDAT%CROP(I)%EGW(K) )
            !!!    !
            !!!    IF(CDAT%CROP(I)%TPPOT(K) < NEARZERO_15) CDAT%CROP(I)%TPPOT(K) = DZ
            !!!    IF(CDAT%CROP(I)%EPPOT(K) < NEARZERO_15) CDAT%CROP(I)%EPPOT(K) = DZ
            !!!    !
            !!!END DO; END DO
        ELSE
            DO CONCURRENT ( I=ONE:CDAT%NCROP)
                !
                CDAT%CROP(I)%TPPOT  = DZ 
                CDAT%CROP(I)%EPPOT  = DZ
                CDAT%CROP(I)%PRECIP = DZ
                ! 
            END DO
        END IF
        !
        ! SET BARE LAND (FALLOW) FRACTIONS --REQUIRES FRAC TO BE POPULATED
        IF (UPDATE .AND. CDAT%MIN_BARE < UNO) THEN
              !
              CDAT%BARE_FRAC = UNO
              IF(CDAT%FRAC%INUSE) THEN
                               DO CONCURRENT (I=ONE:CDAT%NCROP    )
                               DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
                                     !
                                     R = CDAT%CROP(I)%RC(ONE,K)
                                     C = CDAT%CROP(I)%RC(TWO,K)
                                     !
                                     CDAT%BARE_FRAC(C,R) = CDAT%BARE_FRAC(C,R) - CDAT%CROP(I)%FRAC(K)
                               END DO; END DO
                               !0.000001
                               DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) < CDAT%MIN_BARE .OR. WBS%FID_ARRAY(C,R) < ONE )
                                     !
                                     IF(CDAT%BARE_FRAC(C,R) < NEGNEARZERO_3) CALL WRN%ADD(NUM2STR(R,-5)//' '//NUM2STR(C,-5)//' '//NUM2STR(UNO-CDAT%BARE_FRAC(C,R))//NL)
                                     !
                                     CDAT%BARE_FRAC(C,R) = DZ
                               END DO
                               IF (WRN%RAISED) CALL WRN%CHECK(HED='FMP CROP FRACTION FOR A ROW/COLUMN HAD A SUM GREATER THEN ONE ACROSS ALL CROPS.'//NL// &
                                                                  'THE FALLOW/BARE PORTION IS ASSUMED TO BE ZERO AND THE FOLLOWING ARE THE PROBLEM MODEL CELLS:'//BLN// &
                                                                  'ROW   COL   SUMMED_FRACTION',                   &
                                                                   OUTPUT=CDAT%LOUT, TAIL=NL, NO_NL=TRUE, INIT=TRUE)
              ELSE             
                               DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%CRPID(C,R) > Z .OR. WBS%FID_ARRAY(C,R) < ONE );   CDAT%BARE_FRAC(C,R) = DZ
                               END DO
              END IF
              !
              IF(CLIM%HAS_BARE_REF_ET) THEN
                                           CDAT%CHECK_BARE = ANY(CDAT%BARE_FRAC > DZ)
              ELSE
                                           CDAT%CHECK_BARE = FALSE
              END IF
              !
        ELSEIF(.NOT. CLIM%HAS_BARE_REF_ET) THEN
            CDAT%CHECK_BARE = FALSE
            !CDAT%BARE_FRAC  = DZ
        END IF
        !
        !
        ! CALCULATE CROP ELEVATIONS  --REQUIRES CDAT%CHECK_BARE FLAG
        !
        IF(UPDATE) CALL SETUP_CROP_ELEVATION(CDAT, WBS)
        !
        IF(UPDATE .OR. (CDAT%ROOT%TRANSIENT.AND.LOAD_NEXT) .OR. SOIL%CAPILLARY_TFR%TRANSIENT .OR. (NEW_IRR .AND. CDAT%ROOT%SFAC%HAS_EX3) ) THEN
           DO CONCURRENT (I=ONE:CDAT%NCROP)
           DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)  
                                                                   R = CDAT%CROP(I)%RC(ONE,K)
                                                                   C = CDAT%CROP(I)%RC(TWO,K)
                                                                   !
                                                                   CDAT%CROP(I)%SS(K)   = CDAT%CROP(I)%GSE(K) - CDAT%CROP(I)%ROOT(K)
                                                                   CDAT%CROP(I)%LXX(K)  = CDAT%CROP(I)%GSE(K) - CDAT%CROP(I)%ROOT(K) - SOIL%CAPILLARY_FRINGE(C,R)
                                                                   !
                                                                   IF(SOIL%CAPILLARY_FRINGE(C,R) > NEARZERO_3) THEN
                                                                            CDAT%CROP(I)%XX(K)   = CDAT%CROP(I)%GSE(K) - SOIL%CAPILLARY_FRINGE(C,R)
                                                                   ELSE
                                                                            CDAT%CROP(I)%XX(K)   = CDAT%CROP(I)%GSE(K)
                                                                   END IF
                                                                   !CDAT%CROP(I)%PSIA(K) = SOIL%CAPILLARY_FRINGE(C,R)
                                                                   !
           END DO; END DO
        END IF
        !
        IF(CDAT%HAS_PSI) CALL CDAT%CROP%SETUP_UXX_MXX(SOIL,CDAT%MLT)
        !
    END IF !-------------------------------------------------------------------------------------------------------------------------------- IF(CDAT%NCROP == Z) THEN ; ELSE ; END IF
    !
    !
    IF(CDAT%CHECK_BARE) THEN
         !
         IF(.NOT. ALLOCATED(CDAT%BARE_PRECEP_EXCESS) ) THEN
             !
             ALLOCATE( CDAT%BARE_PRECEP_EXCESS (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_TOT_PRECEP    (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_POT_EVAP      (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_EVAP          (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_EVAP_EHI      (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_EVAP_EHD      (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_EVAP_PRECIP   (CDAT%NCOL,CDAT%NROW), &
                       CDAT%BARE_FRAC_RUNOFF   (CDAT%NCOL,CDAT%NROW), &
                       !CDAT%BARE_FRAC_PRECIP(CDAT%NCOL,CDAT%NROW), &
                                                                   SOURCE=DZ)
             !
             IF(CDAT%HAS_Pe) ALLOCATE(CDAT%BARE_RNOFF_Peff(CDAT%NCOL,CDAT%NROW), SOURCE=DZ)
         ELSE
             CDAT%BARE_EVAP_EHI = DZ
             CDAT%BARE_EVAP_EHD = DZ
             CDAT%BARE_EVAP     = DZ
         END IF
         !
         CALL WBS%SETUP_FALLOW_FRACTION_ARRAY(WBS%BARE_FRAC_RUNOFF,CDAT%BARE_FRAC_RUNOFF,UPDATE)       !POPULATES ARRAY OF FRACTIONS OF RUNOFF TO DP FOR BARE/FALLOW LAND
         !CALL WBS%SETUP_FALLOW_FRACTION_ARRAY(WBS%BARE_FRAC_PRECIP,CDAT%BARE_FRAC_PRECIP,UPDATE) 
         !
         IF(CLIM%HAS_PRECIP) THEN
                             CDAT%BARE_TOT_PRECEP = CDAT%BARE_FRAC * WBS%AREA * CLIM%PRECIP
                             !
                             WHERE(CDAT%BARE_TOT_PRECEP < DZ); CDAT%BARE_TOT_PRECEP = DZ
                             END WHERE
                             !
                             IF(CDAT%HAS_Pe) THEN
                                DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL)
                                    !
                                    P = CLIM%PRECIP_EFFECTIVE(C,R) * CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                                    !
                                    IF (CDAT%BARE_TOT_PRECEP(C,R) - P > NEARZERO_15) THEN
                                        !
                                        CDAT%BARE_RNOFF_Peff(C,R) = CDAT%BARE_TOT_PRECEP(C,R) - P  !Excess precip from effective table
                                        CDAT%BARE_TOT_PRECEP(C,R) = P                              !Precip that is consumable is less
                                    ELSE
                                        CDAT%BARE_RNOFF_Peff(C,R) = DZ
                                    END IF
                                END DO
                             END IF
         ELSE
                             CDAT%BARE_TOT_PRECEP = DZ
         END IF
         !
         CDAT%BARE_POT_EVAP = CDAT%BARE_FRAC * WBS%AREA * CLIM%BARE_POT_EVAP
         !
         WHERE(CDAT%BARE_POT_EVAP < DZ); CDAT%BARE_POT_EVAP = DZ
         END WHERE
         !
         DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL)
            !
            IF(CDAT%BARE_FRAC(C,R) > DZ) THEN
                  !
                  P = CDAT%BARE_TOT_PRECEP(C,R) ! * CDAT%BARE_FRAC_PRECIP(C,R)  !Precip availible for consumption
                  IF(P < DZ) P = DZ
                  !
                  IF(P > CDAT%BARE_POT_EVAP(C,R)) THEN  !Precip availible for consumption greater then potential evap
                      !
                      CDAT%BARE_PRECEP_EXCESS(C,R)  = CDAT%BARE_TOT_PRECEP(C,R) - CDAT%BARE_POT_EVAP(C,R)
                      IF(CDAT%BARE_PRECEP_EXCESS(C,R) < NEARZERO_12) CDAT%BARE_PRECEP_EXCESS(C,R) = DZ
                      !
                      CDAT%BARE_EVAP_PRECIP(C,R)    = CDAT%BARE_POT_EVAP(C,R)
                      CDAT%BARE_POT_EVAP(C,R)       = DZ
                  ELSE
                      CDAT%BARE_PRECEP_EXCESS(C,R) = DZ
                      CDAT%BARE_EVAP_PRECIP(C,R)   = P
                      CDAT%BARE_POT_EVAP(C,R)      = CDAT%BARE_POT_EVAP(C,R) - P
                  END IF
                  !
            ELSE
                      CDAT%BARE_PRECEP_EXCESS(C,R) = DZ
                      CDAT%BARE_EVAP_PRECIP(C,R)   = DZ
                      CDAT%BARE_POT_EVAP(C,R)      = DZ
            END IF
         END DO
    !ELSE
    !    CDAT%BARE_PRECEP_EXCESS    = DZ
    !    CDAT%BARE_POT_EVAP  = DZ
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_ET(CDAT, WBS, CLIM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(IN   ):: WBS
    TYPE(CLIMATE_DATA), INTENT(IN   ):: CLIM
    INTEGER,            INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,   INTENT(IN   ):: DELT
    DOUBLE PRECISION,   INTENT(IN   ):: DYEAR
    CHARACTER(*),       INTENT(IN   ):: DATE
    DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: Area, ETref, ETpot, ETact
    INTEGER:: IU, R, C, I, K, F, L, nfarm, ncrop
    CHARACTER(17):: DT
    CHARACTER(20):: BARE
    !
    IF(.not. CDAT%OUT_ET%IS_OPEN) RETURN
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    !
    nfarm = wbs%nfarm
    ncrop = cdat%ncrop
    !
    BARE = 'BARE_LAND'
    L    = CDAT%CROP_NAME_LEN
    !
    allocate( ETref(0:ncrop, nfarm) )
    allocate( ETpot(0:ncrop, nfarm) )
    allocate( ETact(0:ncrop, nfarm) )
    allocate(  Area(0:ncrop, nfarm) )
    ETpot = DZ
    ETact = DZ
    Area  = DZ
    !
    CALL CDAT%OUT_ET%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    IU = CDAT%OUT_ET%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                                                                                                                                                                                                           
            CALL CDAT%OUT_ET%SET_HEADER( '    PER    STP    WBS   CROP  CROP_NAME'//REPEAT(' ',L+4)//'AREA            ETref            ETpot            ETact             DELT   DYEAR            DATE_START' )
    END IF
    !
    DO I=ONE, ncrop    
    DO K=ONE, CDAT%CROP(I)%N
        F = CDAT%CROP(I)%FID(K) 
        IF( F < ONE .OR. WBS%NFARM < F) CYCLE
        !
         Area(I,F) =  Area(I,F) + CDAT%CROP(I)%AREA(K)
        ETpot(I,F) = ETpot(I,F) + CDAT%CROP(I)%CU(K)
        ETact(I,F) = ETact(I,F) + CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K)
    END DO 
    END DO
    !
    IF(.NOT. CLIM%HAS_REF_ET) THEN
       BLOCK
           DOUBLE PRECISION:: DTMP, NaN
           NaN = IEEE_VALUE(DTMP, IEEE_QUIET_NAN)
           ETref = NaN
       END BLOCK
    ELSE
       Etref = DZ
       DO I=ONE, ncrop    
       DO K=ONE, CDAT%CROP(I)%N
           F = CDAT%CROP(I)%FID(K) 
           IF( Z < F .and. F <= WBS%NFARM ) THEN
               R = CDAT%CROP(I)%RC(ONE,K)
               C = CDAT%CROP(I)%RC(TWO,K)
               !
               ETref(I,F) = ETref(I,F) + CDAT%CROP(I)%AREA(K) * CLIM%REF_ET(C,R)
           END IF
       END DO 
       END DO
    END IF
    !
    IF(CDAT%CHECK_BARE) THEN
       DO R=ONE, CDAT%NROW
       DO C=ONE, CDAT%NCOL
          !
          F = WBS%FID_ARRAY(C,R)
          IF( F < ONE .OR. WBS%NFARM < F) CYCLE
          !
          IF(CDAT%BARE_FRAC(C,R) > DZ)  THEN
                                         Area(Z,F) =  Area(Z,F) + CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                                        ETpot(Z,F) = ETpot(Z,F) + CDAT%BARE_POT_EVAP(C,R)
                                        ETact(Z,F) = ETact(Z,F) + CDAT%BARE_EVAP(C,R)
          END IF
       END DO 
       END DO
       !
       IF(CLIM%HAS_REF_ET) THEN
          DO R=ONE, CDAT%NROW
          DO C=ONE, CDAT%NCOL
             F = WBS%FID_ARRAY(C,R)
             !
             IF( Z < F .and. F <= WBS%NFARM .and. CDAT%BARE_FRAC(C,R) > DZ ) ETref(Z,F) = ETref(Z,F) + CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R) * CLIM%REF_ET(C,R)
          END DO 
          END DO
       END IF
    END IF
    !
    !
    DO F=ONE, WBS%NFARM
       !
       IF(WBS%FID(F)%COUNT < ONE) CYCLE
       !
       IF(   Area(Z,F) > DZ) WRITE(IU, '(4I7, 2x,A, 5A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, Z,              BARE(:L), NUM2STR(Area(Z,F)), NUM2STR(ETref(Z,F)), NUM2STR(ETpot(Z,F)), NUM2STR(ETact(Z,F)), DT, DYEAR, DATE
       !
       DO I=ONE, ncrop
          IF(Area(I,F) > DZ) WRITE(IU, '(4I7, 2x,A, 5A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, I, CDAT%CROP_NAME(I)(:L), NUM2STR(Area(I,F)), NUM2STR(ETref(I,F)), NUM2STR(ETpot(I,F)), NUM2STR(ETact(I,F)), DT, DYEAR, DATE
       END DO
       !
    END DO 
    !
  END SUBROUTINE
  !
  SUBROUTINE PARSE_CROP_ROW_COL(CDAT, FID, NEW_FID)
    !USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
    CLASS(CROP_DATA),                    INTENT(INOUT):: CDAT
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: FID
    LOGICAL,                             INTENT(IN   ):: NEW_FID
    INTEGER:: I, J, K, NR, NC, LD, ID, N, M, P  !LD = LEADING DIMENSION
    !DOUBLE PRECISION:: NaN
    LOGICAL:: REALLOCATE, UPDATE_CID
    TYPE(WARNING_TYPE):: WRN
    !
    !TOL = 1D-30
    NC = CDAT%NCOL
    NR = CDAT%NROW
    CALL WRN%INIT()
    !
    UPDATE_CID = FALSE
    IF(.NOT. CDAT%MULTI_CROP_CELLS) THEN
                                IF (NEW_FID) THEN
                                                       UPDATE_CID = TRUE
                                ELSEIF(CDAT%CID%HAS_IXJ) THEN
                                                 ASSOCIATE(DIM => CDAT%CID%IXJ%N, DAT => CDAT%CID%IXJ%DAT)
                                                          !
                                                          UPDATE_CID = FALSE
                                                          !
                                                          DO P=ONE, DIM
                                                                K = DAT(P)%I(1)
                                                                I = DAT(P)%I(2)
                                                                J = DAT(P)%I(3)
                                                                !
                                                                IF(K .NE. CDAT%CRPID(J,I)) THEN
                                                                    UPDATE_CID = TRUE
                                                                    EXIT
                                                                END IF
                                                          END DO
                                                 END ASSOCIATE
                                    
                                ELSE
                                                       UPDATE_CID = ANY(CDAT%CID%ARRAY .NE. CDAT%CRPID)
                                END IF
    END IF
    !
    IF(CDAT%MULTI_CROP_CELLS) THEN
        !
        !NaN = IEEE_VALUE(NaN, IEEE_QUIET_NAN)
        !WHERE ( CDAT%FRAC%ARRAY < NEARZERO_30 ) CDAT%FRAC%ARRAY = DZ !NaN  !-NEARZERO_30 < CDAT%FRAC%ARRAY .AND. 
        !
        IF(CDAT%FRAC%HAS_IXJ) THEN
          !
          ASSOCIATE(DIM => CDAT%FRAC%IXJ%N, POS=>CDAT%FRAC%IXJ%P, DAT => CDAT%FRAC%IXJ%DAT)
             !
             DO P=ONE, DIM
                 IF    (DAT(P)%X(1) < NEARZERO_30) THEN
                                                                DAT(P)%X(1) = DZ
                 ELSEIF(DAT(P)%X(1) > UNO        ) THEN
                                                                DAT(P)%X(1) = UNO
                 END IF
             END DO
             !
             DO ID=ONE, CDAT%NCROP
                !
                N   = Z  !CURRENT COUNT OF CROP ID WITH FID>0
                M   = Z  !TOTAL COUNT OF CROP ID
                !
                DO P=ONE, DIM
                    IF(     DAT(P)%I(1) == ID .AND. DAT(P)%X(1) > DZ) THEN
                        I = DAT(P)%I(2) 
                        J = DAT(P)%I(3)
                        M = M + ONE
                        !
                        IF(FID(J,I) > Z) N = N + ONE
                    END IF
                END DO
                !
                REALLOCATE = N .NE. CDAT%CROP(ID)%N
                CDAT%CROP(ID)%N = N
                !
                IF( N > Z) THEN 
                               IF ( REALLOCATE ) THEN
                                                     CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
                                                     !
                                                     CDAT%CROP(ID)%N = N                              !DEALLOCATE_CROP_PROP MADE CDAT%CROP(ID)%N = 0, HAVE TO RESET IT
                                                     ALLOCATE(CDAT%CROP(ID)%RC(TWO,CDAT%CROP(ID)%N))
                                                     !ALLOCATE(CDAT%CROP(ID)%FRAC(CDAT%CROP(ID)%N))
                                                     !
                                                     CALL ALLOC(CDAT%CROP(ID)%FRAC, N)
                               END IF
                               !
                               CALL CDAT%FRAC%IXJ%START_ID(ID, ONE) !Sets IXJ%P to correct location, which is also equal to POS
                               !
                               K = Z
                               DO LD = ONE, M     ! M IS TOTAL COUNT OF ID  
                                   I = DAT(POS)%I(2) 
                                   J = DAT(POS)%I(3)
                                   IF(FID(J,I) > Z .AND. DAT(POS)%X(1) > DZ) THEN
                                                        K=K+ONE
                                                        CDAT%CROP(ID)%RC(ONE,K) = I
                                                        CDAT%CROP(ID)%RC(TWO,K) = J
                                                        CDAT%CROP(ID)%FRAC(K)   = DAT(POS)%X(1)
                                   ELSEIF(DAT(POS)%X(1) > DZ) THEN
                                                        CALL WRN%ADD(NUM2STR(ID,-5)//' '//NUM2STR(I,-10)//' '//NUM2STR(J,-10)//NL)
                                   END IF
                                   !
                                   CALL CDAT%FRAC%IXJ%NEXT_ID(ID, ONE)
                               END DO
                ELSE   ! NO CROPS FOUND, SO NO ALLOCATION!
                               CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
                END IF
             END DO
          END ASSOCIATE
        ELSE
           DO CONCURRENT (J=ONE:SIZE(CDAT%FRAC%ARRAY,TWO), I=ONE:SIZE(CDAT%FRAC%ARRAY,ONE), CDAT%FRAC%ARRAY(I,J).NE.DZ)
                 IF    (CDAT%FRAC%ARRAY(I,J) < NEARZERO_30) THEN
                                                                CDAT%FRAC%ARRAY(I,J) = DZ
                 ELSEIF(CDAT%FRAC%ARRAY(I,J) > UNO ) THEN
                                                                CDAT%FRAC%ARRAY(I,J) = UNO
                 END IF
           END DO
           !
           DO CONCURRENT (ID=ONE:CDAT%NCROP)  ! FRAC_LOOP
              !
              LD = CDAT%CROP(ID)%LD - ONE 
              !CDAT%CROP(ID)%ID = ID
              !LD = (ID-ONE)*NR
              !
              !N = Z
              !DO CONCURRENT(J=1:NC, I=1:NR, CDAT%FRAC%ARRAY(J,LD+I) == CDAT%FRAC%ARRAY(J,LD+I) )
              !                N = N + ONE
              !END DO
              N = COUNT( CDAT%FRAC%ARRAY(:, LD+ONE:LD+NR) >= NEARZERO_30 .AND.  FID > Z)  !CDAT%FRAC%ARRAY(:,LD:LD+NR)==CDAT%FRAC%ARRAY(:,LD:LD+NR)
              !
              REALLOCATE = N .NE. CDAT%CROP(ID)%N
              CDAT%CROP(ID)%N = N
              !
              IF( N > Z) THEN 
                             IF ( REALLOCATE ) THEN
                                                   CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
                                                   !
                                                   CDAT%CROP(ID)%N = N                              !DEALLOCATE_CROP_PROP MADE CDAT%CROP(ID)%N = 0, HAVE TO RESET IT
                                                   ALLOCATE(CDAT%CROP(ID)%RC(TWO,CDAT%CROP(ID)%N))
                                                   !ALLOCATE(CDAT%CROP(ID)%FRAC(CDAT%CROP(ID)%N))
                             END IF
                             !
                             K = 0
                             DO CONCURRENT(I=ONE:NR, J=ONE:NC, CDAT%FRAC%ARRAY(J,LD+I) > NEARZERO_30)
                                 IF(FID(J,I) > Z) THEN
                                                      K=K+ONE
                                                      CDAT%CROP(ID)%RC(ONE,K) = I
                                                      CDAT%CROP(ID)%RC(TWO,K) = J
                                                      !CDAT%CROP%FRAC(K) = CDAT%FRAC%ARRAY(J,LD+I)
                                 ELSE
                                                      !CDAT%FRAC%ARRAY(J,LD+I) = DZ  --NEED TO HOLD VALUE INCASE OF REPEAT
                                                      CALL WRN%ADD(NUM2STR(ID,-5)//' '//NUM2STR(I,-10)//' '//NUM2STR(J,-10)//NL)
                                                      
                                 END IF
                             END DO
              ELSE   ! NO CROPS FOUND, SO NO ALLOCATION!
                             CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
              END IF
           END DO !FRAC_LOOP
        END IF
        !
    ELSEIF(UPDATE_CID) THEN
        !
        IF(CDAT%CID%HAS_IXJ) THEN
            !
            CALL SET_ZERO(NC, NR, CDAT%CRPID)
            !
            ASSOCIATE(DIM => CDAT%FRAC%IXJ%N, DAT => CDAT%FRAC%IXJ%DAT)
                     !
                     DO P=ONE, DIM
                           K = DAT(P)%I(1)
                           I = DAT(P)%I(2)
                           J = DAT(P)%I(3)
                           !
                           IF(Z < K .AND. K <= CDAT%NCROP) CDAT%CRPID(J,I) = K
                           !
                     END DO
            END ASSOCIATE
        ELSE
            DO CONCURRENT(I=ONE:NR, J=ONE:NC)
                IF(CDAT%CID%ARRAY(J,I) > CDAT%NCROP) THEN
                                                         CDAT%CRPID(J,I)     = Z
                                                         CDAT%CID%ARRAY(J,I) = Z
                ELSEIF(CDAT%CID%ARRAY(J,I) .NE. Z) THEN
                                                         CDAT%CRPID(J,I) = CDAT%CID%ARRAY(J,I)
                ELSE
                                                         CDAT%CRPID(J,I) = Z
                END IF
            END DO
        END IF
        !
        DO CONCURRENT(I=ONE:NR, J=ONE:NC, FID(J,I)==Z .AND. CDAT%CRPID(J,I) > Z)
               !
               CALL WRN%ADD(NUM2STR(CDAT%CRPID(J,I),-5)//' '//NUM2STR(I,-10)//' '//NUM2STR(J,-10)//NL)
               CDAT%CRPID(J,I) = Z
        END DO
        !
        CID_LOOP: DO CONCURRENT (ID=ONE:CDAT%NCROP)
           !
           !CDAT%CROP(ID)%ID = ID
           N  = COUNT(ID == CDAT%CRPID)
           !
           REALLOCATE = N .NE. CDAT%CROP(ID)%N
           CDAT%CROP(ID)%N = N
           !
           IF( N > Z ) THEN
                           !
                           IF(REALLOCATE) THEN 
                               CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
                               CDAT%CROP(ID)%N = N
                               ALLOCATE(CDAT%CROP(ID)%RC(TWO,CDAT%CROP(ID)%N))
                           END IF
                           !
                           K = 0
                           DO CONCURRENT(I=ONE:NR, J=ONE:NC, ID == CDAT%CRPID(J,I))
                               K=K+ONE
                               CDAT%CROP(ID)%RC(ONE,K) = I
                               CDAT%CROP(ID)%RC(TWO,K) = J
                           END DO
           ELSE   ! NO CROPS FOUND, SO NO ALLOCATION!
                          CALL DEALLOCATE_CROP_PROP(CDAT%CROP(ID))
           END IF
        END DO CID_LOOP
    END IF
    !
    IF (WRN%RAISED) THEN
        CALL WRN%CHECK(HED='FMP CROP: FOUND CROP IDs THAT ARE GREATER THAN ZERO LOCATED IN CELLS THAT HAVE WBS ID EQUAL TO ZERO.'//NL//     &
                                                     'TO FIX THIS PROBLEM THE CROP ID IS SET TO ZERO OR ITS FRACTION IS SET TO 0.0'//BLN//   &
                                                     'THE FOLLOWING IS A LIST OF THE PROBLEM CELLS LOADED AND SET TO ZERO:'//NL//            &
                                                     'CROP  ROW     COLUMN',                                                                 &
                                                      OUTPUT=CDAT%LOUT,TAIL=NL,NO_NL=TRUE)
        !CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP: FOUND CROP IDs THAT ARE GREATER THAN ZERO LOCATED IN CELLS THAT HAVE FARM ID EQUAL TO ZERO.'//NL//  &
        !                                             'TO FIX THIS PROBLEM THE CROP ID IS SET TO ZERO OR ITS FRACTION IS SET TO 0.0'//BLN//                         &
        !                                             'THE FOLLOWING IS A LIST OF THE PROBLEM CELLS LOADED AND SET TO ZERO:'//NL//                                  &
        !                                             'CROP  ROW     COLUMN'//ERROR)
        !WRITE(CDAT%LOUT,'(4(/ A), A /)')'FMP CROP: FOUND CROP IDs THAT ARE GREATER THAN ZERO LOCATED IN CELLS THAT HAVE FARM ID EQUAL TO ZERO.', &
        !                                             'TO FIX THIS PROBLEM THE CROP ID IS SET TO ZERO OR ITS FRACTION IS SET TO 0.0','THE FOLLOWING IS A LIST OF THE PROBLEM CELLS LOADED AND SET TO ZERO:', &
        !                                             'CROP  ROW     COLUMN',  ERROR
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_CROP_WBS_ID(CDAT, WBS)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    INTEGER:: I, K, F
    INTEGER,DIMENSION(WBS%NFARM):: CNT
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
                                    CALL ALLOC(CDAT%CROP(I)%FID, CDAT%CROP(I)%N)
    END DO
    !
    CNT = Z
    !
    DO I=ONE, CDAT%NCROP
    DO K=ONE, CDAT%CROP(I)%N
          !                                                     COL                   ROW
          CDAT%CROP(I)%FID(K) = WBS%FID_TFR%GET(Z, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), Z)
          !
          IF(CDAT%CROP(I)%FID(K) > Z) CNT(CDAT%CROP(I)%FID(K)) = CNT(CDAT%CROP(I)%FID(K)) + ONE
          !
    END DO
    END DO
    !
    DO F=ONE, WBS%NFARM
        IF(CNT(F)>Z) THEN
            CALL ALLOC(WBS%CROP(F)%PNT, FOUR, CNT(F))
            WBS%CROP(F)%N = CNT(F)
        ELSE
            WBS%CROP(F)%N = Z
        END IF
    END DO
    !
    CNT = Z
    !
    DO I=ONE, CDAT%NCROP
    DO K=ONE, CDAT%CROP(I)%N
    IF(CDAT%CROP(I)%FID(K) > Z) THEN
          !
          F = CDAT%CROP(I)%FID(K) 
          
          !
          CNT(F) = CNT(F) + ONE
          !
          WBS%CROP(F)%PNT(ONE,  CNT(F)) = I
          WBS%CROP(F)%PNT(TWO,  CNT(F)) = K
          WBS%CROP(F)%PNT(THREE,CNT(F)) = CDAT%CROP(I)%RC(ONE,K)
          WBS%CROP(F)%PNT(FOUR, CNT(F)) = CDAT%CROP(I)%RC(TWO,K)
    END IF
    END DO
    END DO
    !    
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_CROP_EFFICIENCY(CDAT, WBS, RANGE_CHECK)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),INTENT(IN   ):: WBS
    LOGICAL,       INTENT(IN   ):: RANGE_CHECK
    INTEGER:: I, K
    !
    DO CONCURRENT   ( I=ONE:CDAT%NCROP,    CDAT%CROP(I)%N > Z )
      DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
          !
          IF (CDAT%CROP(I)%IRR(K)>Z) THEN !                                           FID                 COL                    ROW             IRRIGATION TYPE
                                          CDAT%CROP(I)%EFF(K) = WBS%EFF_TFR%GET( CDAT%CROP(I)%FID(K),CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K),CDAT%CROP(I)%IRR(K) )
                                          !
                                          IF(CDAT%CROP(I)%EFF(K) .NE. CDAT%CROP(I)%EFF(K)) CDAT%CROP(I)%EFF(K) = DZ
          ELSE
                                          CDAT%CROP(I)%EFF(K) = DZ
          END IF
      END DO
      !
      CALL CROP_INPUT_APPLY_SFAC( CDAT%CROP(I)%EFF, WBS%EFF_TFR%SFAC, CDAT%CROP(I)%N, I, CDAT%CROP(I)%FID, CDAT%CROP(I)%IRR )
      !
    END DO
    !
    IF(RANGE_CHECK) THEN
                  !
                  DO CONCURRENT ( I=ONE:CDAT%NCROP )
                  DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z )
                                 !
                                 IF(    CDAT%CROP(I)%EFF(K) <  DZ) THEN
                                                                        CDAT%CROP(I)%EFF(K) = DZ
                                 ELSEIF(CDAT%CROP(I)%EFF(K) >  UNO) THEN
                                                                        CDAT%CROP(I)%EFF(K) = UNO
                                 END IF
                  END DO
                  END DO
    END IF
    !    
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_CROP_ELEVATION(CDAT, WBS)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(IN   ):: WBS
    INTEGER:: I, K, LD, R, C
    DOUBLE PRECISION:: TMP
    DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE:: ARR
    !
    IF(CDAT%CHECK_BARE) THEN  !ONLY DO THIS FOR FIRST CALL OF NEXT() ROUTINE
          IF(.NOT.ALLOCATED(CDAT%BARE_GSE)) THEN
                                                ALLOCATE(CDAT%BARE_GSE(CDAT%NCOL, CDAT%NROW)); CDAT%BARE_GSE = WBS%GSE
          ELSEIF(CDAT%SPEC_GSE%TRANSIENT .OR. CDAT%GSE_OFFSET%TRANSIENT)  THEN
                                                         CDAT%BARE_GSE = WBS%GSE
          END IF
    END IF
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP    )
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)  
                                                            CDAT%CROP(I)%GSE(K) = WBS%GSE(CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K))
    END DO; END DO
    !
    !
    IF(CDAT%SPEC_GSE%INUSE) THEN
          DO CONCURRENT (I=Z:CDAT%NCROP)
              LD = Z
              DO K=ONE, CDAT%NCROP_ELEV
                  IF(CDAT%GSE_CID%LIST(K)==I) THEN
                      LD = K
                      EXIT
                  END IF
              END DO
              !
              IF (LD > Z) THEN
                  IF(CDAT%MULTI_CROP_CELLS) THEN
                     LD = (LD-ONE) * CDAT%NROW  !NOTE LD=0 FOR R,C = 1,1
                  ELSE
                     LD = Z
                  END IF
                  IF (I > Z) THEN
                         !
                         DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N)  
                                                               R = CDAT%CROP(I)%RC(ONE,K)
                                                               C = CDAT%CROP(I)%RC(TWO,K)
                                                               CDAT%CROP(I)%GSE(K) = CDAT%SPEC_GSE%ARRAY(C,R+LD)
                                                               CALL CROP_INPUT_APPLY_SFAC_SINGLE(CDAT%CROP(I)%GSE(K), CDAT%SPEC_GSE%SFAC, I, CDAT%CROP(I)%FID(K) )
                         END DO
                  ELSEIF (CDAT%CHECK_BARE .AND. I == Z ) THEN
                                                               CDAT%BARE_GSE = CDAT%SPEC_GSE%ARRAY(:,LD+ONE:LD+CDAT%NROW)
                                                               CALL CROP_INPUT_APPLY_SFAC_SINGLE(CDAT%BARE_GSE, CDAT%SPEC_GSE%SFAC, Z, WBS%FID_ARRAY )
                  END IF
              END IF
          END DO
    END IF
    !
    IF(CDAT%GSE_OFFSET%INUSE) THEN
          DO CONCURRENT (I=Z:CDAT%NCROP)
              LD = Z
              DO K=ONE, CDAT%NCROP_ELEV
                  IF(CDAT%GSE_CID%LIST(K)==I) THEN
                      LD = K
                      EXIT
                  END IF
              END DO
              !
              IF (LD > Z) THEN
                  IF (I > Z) THEN
                         !
                         DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N) 
                                                               TMP = CDAT%GSE_OFFSET%LIST(LD)
                                                               CALL CROP_INPUT_APPLY_SFAC_SINGLE(TMP, CDAT%GSE_OFFSET%SFAC, I, CDAT%CROP(I)%FID(K) )
                                                               CDAT%CROP(I)%GSE(K) = CDAT%CROP(I)%GSE(K) + TMP
                         END DO
                  ELSEIF (CDAT%CHECK_BARE .AND. I == Z ) THEN
                                                               ALLOCATE(ARR, MOLD=CDAT%BARE_GSE)
                                                               ARR = CDAT%GSE_OFFSET%LIST(LD)
                                                               CALL CROP_INPUT_APPLY_SFAC_SINGLE(ARR, CDAT%GSE_OFFSET%SFAC, Z, WBS%FID_ARRAY )
                                                               CDAT%BARE_GSE = CDAT%BARE_GSE + ARR
                                                               DEALLOCATE(ARR)
                  END IF
              END IF
          END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_CROP_FALLOW_RANK(CDAT, WBS)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA), INTENT(IN   ):: WBS
    INTEGER:: I, K, NORANK
    !
    NORANK = HUGE(NORANK) - ONE
    !
    DO CONCURRENT   ( I=ONE:CDAT%NCROP     )
      DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
          !                                                              FID                 COL                ROW                CROP
              CDAT%CROP(I)%FALLOW_RANK(K) = WBS%FALLOW_RANK_TFR%GET( CDAT%CROP(I)%FID(K),CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K),I )
          IF (CDAT%CROP(I)%FALLOW_RANK(K) < ONE) CDAT%CROP(I)%FALLOW_RANK(K) = NORANK
      END DO
      !
    END DO
    !    
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_CROP_INPUT_TO_CROP_PROP(CPR, CPI)
    CLASS(CROP_PROP),       INTENT(INOUT):: CPR
    TYPE(LIST_ARRAY_INPUT), INTENT(IN   ):: CPI
    INTEGER:: K, ID, LD  ! LD => LEADING DIMENSION
    !
    IF (CPR%N > Z .AND. CPI%INUSE) THEN
       !
       ID = CPR%ID
       LD = CPR%LD
       !
       SELECT CASE(CPI%TYP)
       CASE('ROOT'  )
                      CALL ALLOC(CPR%ROOT, CPR%N)  !IF ROOT ALREADY ALLOCATED AND OVERDIMENSIONED, DONT BOTHER REALLOCATING
                      IF(CPI%LISTLOAD) THEN
                                           CPR%ROOT = CPI%LIST(ID)
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%ROOT, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%ROOT, CPI%ARRAY(:,LD:))
                      END IF
                      !    CROP_INPUT_APPLY_SFAC(SFAC, PROP, N, CID, FID, [IRR])
                      CALL CROP_INPUT_APPLY_SFAC( CPR%ROOT, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
                      !
                      WHERE( CPR%ROOT < NEARZERO_30 );  CPR%ROOT = NEARZERO_30   !THIS IS TO PREVENT ANY DIV/0 ERRORS
                      END WHERE
                      
       CASE('MULTI_FRAC')
                      !
                      IF(.NOT. CPI%HAS_IXJ) THEN !ASSUMES THAT PARSE_CROP_ROW_COL SET UP FRACTIONS ALREADY
                          CALL ALLOC(CPR%FRAC, CPR%N)
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FRAC, CPI%ARRAY(:,LD:))
                      END IF
                      !
                      CALL CROP_INPUT_APPLY_SFAC( CPR%FRAC, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('SINGLE_FRAC')
                      CALL ALLOC(CPR%FRAC, CPR%N)
                      !
                      IF(CPI%LISTLOAD) THEN
                                           CPR%FRAC = CPI%LIST(ID)
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FRAC, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FRAC, CPI%ARRAY(:,LD:))
                      END IF
                      !
                      CALL CROP_INPUT_APPLY_SFAC( CPR%FRAC, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('Kc'    )
                      CALL ALLOC(CPR%Kc, CPR%N);  CALL ALLOC(CPR%CU, CPR%N)
                      !
                      IF(CPI%LISTLOAD) THEN
                                           CPR%Kc = CPI%LIST(ID)
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%Kc, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%Kc, CPI%ARRAY(:,LD:))
                      END IF
                      !
                      CALL CROP_INPUT_APPLY_SFAC( CPR%Kc, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('CF'    )
                      CALL ALLOC(CPR%CF, CPR%N);  CALL ALLOC(CPR%CU, CPR%N)
                      !
                      IF(CPI%LISTLOAD) THEN
                                           CPR%CF = CPI%LIST(ID)
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%CF, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%CF, CPI%ARRAY(:,LD:))
                      END IF 
                      !
                      CALL CROP_INPUT_APPLY_SFAC(CPR%CF, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('FTR' )
                      CALL ALLOC(CPR%FTR, CPR%N)
                      IF(CPI%LISTLOAD) THEN
                                           CPR%FTR = CPI%LIST(ID)
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FTR, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FTR, CPI%ARRAY(:,LD:))
                      END IF
                      !
                      CALL CROP_INPUT_APPLY_SFAC(CPR%FTR, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       !!!CASE('FEI'   )
       !!!               CALL ALLOC(CPR%FEI, CPR%N)
       !!!               IF(CPI%LISTLOAD) THEN
       !!!                                    CPR%FEI = CPI%LIST(ID)
       !!!               ELSEIF(CPI%HAS_IXJ) THEN
       !!!                   CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FEI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
       !!!               ELSE
       !!!                   CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FEI, CPI%ARRAY(:,LD:))
       !!!               END IF
       !!!               !
       !!!               CALL CROP_INPUT_APPLY_SFAC(CPR%FEI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('FEI_BYCROP')
                      CALL ALLOC(CPR%FEI, CPR%N)
                      IF(CPI%LISTLOAD) THEN
                                           CPR%FEI = CPI%LIST(ID)
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FEI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FEI, CPI%ARRAY(:,LD:))
                      END IF
                      !FEI_BYCROP FEI_BYIRR
                      CALL CROP_INPUT_APPLY_SFAC(CPR%FEI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('FEI_BYIRR')
                      CALL ALLOC(CPR%FEI, CPR%N)
                      IF(CPI%LISTLOAD) THEN
                                      DO CONCURRENT(K=ONE:CPR%N)
                                                       IF(CPR%IRR(K) > Z) THEN
                                                           CPR%FEI(K) = CPI%LIST(CPR%IRR(K))
                                                       ELSE
                                                           CPR%FEI(K) = DZ
                                                       END IF
                                      END DO
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FEI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FEI, CPI%ARRAY(:,LD:))
                      END IF
                      ! 
                      CALL CROP_INPUT_APPLY_SFAC(CPR%FEI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('FIESWP')
                      CALL ALLOC(CPR%FIESWP, CPR%N)
                      IF(CPI%LISTLOAD) THEN
                                           CPR%FIESWP = CPI%LIST(ID)
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FIESWP, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FIESWP, CPI%ARRAY(:,LD:))
                      END IF
                      !
                      CALL CROP_INPUT_APPLY_SFAC( CPR%FIESWP, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('FIESWI_BYCROP')
                      CALL ALLOC(CPR%FIESWI, CPR%N)
                      IF(CPI%LISTLOAD) THEN
                                           CPR%FIESWI = CPI%LIST(ID)
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FIESWI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FIESWI, CPI%ARRAY(:,LD:))
                      END IF
                      !FIESWI_BYCROP FIESWI_BYIRR
                      CALL CROP_INPUT_APPLY_SFAC(CPR%FIESWI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('FIESWI_BYIRR')
                      CALL ALLOC(CPR%FIESWI, CPR%N)
                      IF(CPI%LISTLOAD) THEN
                                      DO CONCURRENT(K=ONE:CPR%N)
                                                       IF(CPR%IRR(K) > Z) THEN
                                                           CPR%FIESWI(K) = CPI%LIST(CPR%IRR(K))
                                                       ELSE
                                                           CPR%FIESWI(K) = DZ
                                                       END IF
                                      END DO
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%FIESWI, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%FIESWI, CPI%ARRAY(:,LD:))
                      END IF
                      ! 
                      CALL CROP_INPUT_APPLY_SFAC(CPR%FIESWI, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       !CASE('PCF')
       !               CALL ALLOC(CPR%CON_PRECIP_FRAC, CPR%N)
       !               IF(CPI%LISTLOAD) THEN
       !                                    CPR%CON_PRECIP_FRAC = CPI%LIST(ID)
       !               ELSEIF(CPI%HAS_IXJ) THEN
       !                   CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%CON_PRECIP_FRAC, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
       !               ELSE
       !                   CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%CON_PRECIP_FRAC, CPI%ARRAY(:,LD:))
       !               END IF
       !               !
       !               CALL CROP_INPUT_APPLY_SFAC(CPR%CON_PRECIP_FRAC, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('PSI'   )
                      IF(.NOT. ALLOCATED(CPR%PSI)) ALLOCATE(CPR%PSI(4))
                      CPR%PSI = CPI%ARRAY(:,ID)
                      CALL CROP_INPUT_APPLY_SFAC(CPR%PSI, CPI%SFAC, 4, ID )
       CASE('POND')
                      CALL ALLOC(CPR%POND, CPR%N)
                      CPR%POND = CPI%LIST(ID)
                      CALL CROP_INPUT_APPLY_SFAC(CPR%POND, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
       CASE('ADMD')
                      CALL ALLOC(CPR%ADMD, CPR%N)
                      IF(CPI%LISTARRAY) THEN
                                           DO CONCURRENT(K=ONE:CPR%N)
                                                CPR%ADMD(K) = CPI%ARRAY(CPR%FID(K), ID)
                                           END DO
                      ELSEIF(CPI%HAS_IXJ) THEN
                          CALL CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, CPR%N, CPR%RC, CPR%ADMD, CPI%IXJ%DIM(1), CPI%IXJ%N, CPI%IXJ%SIZ, CPI%IXJ%DAT)
                      ELSE
                          CALL CROP_INPUT_ARRAY_TO_PROP(CPR%N,   CPR%RC, CPR%ADMD, CPI%ARRAY(:,LD:))
                      END IF
                      !
                      CALL CROP_INPUT_APPLY_SFAC(CPR%ADMD, CPI%SFAC, CPR%N, ID, CPR%FID, CPR%IRR )
                      !
       END SELECT
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_APPLY_SFAC(PROP, SFAC, N, CID, FID, IRR)
    INTEGER,                         INTENT(IN   ):: N
    DOUBLE PRECISION, DIMENSION(N),  INTENT(INOUT):: PROP
    !
    TYPE(SFAC_DATA),                 INTENT(IN   ):: SFAC
    INTEGER,                         INTENT(IN   ):: CID
    INTEGER, DIMENSION(N), OPTIONAL, INTENT(IN   ):: FID
    INTEGER, DIMENSION(N), OPTIONAL, INTENT(IN   ):: IRR
    INTEGER:: I
    !
    IF (SFAC%HAS_ALL) PROP = PROP * SFAC%ALL
    !
    IF (SFAC%HAS_EX1) THEN  ! SCALE BYFARM
          DO CONCURRENT (I=ONE:N, FID(I)>Z)
                      PROP(I) = PROP(I) * SFAC%EX1(FID(I))
          END DO
    END IF
    !
    IF (SFAC%HAS_EX2) PROP = PROP * SFAC%EX2(CID)  !SCALE BYCROP
    !
    IF (SFAC%HAS_EX3) THEN  ! SCALE BYIRRIGAT
          DO CONCURRENT (I=ONE:N, IRR(I)>Z)
                      PROP(I) = PROP(I) * SFAC%EX3(IRR(I))  !CODE EXPECTS USER PASSES IRR IF THERE IS A CHANCE OF EX3
          END DO
    END IF
    !
  END SUBROUTINE
  !
  ELEMENTAL SUBROUTINE CROP_INPUT_APPLY_SFAC_SINGLE(PROP, SFAC, CID, FID, IRR)
    DOUBLE PRECISION, INTENT(INOUT):: PROP
    !
    TYPE(SFAC_DATA),   INTENT(IN   ):: SFAC
    INTEGER,           INTENT(IN   ):: CID
    INTEGER,           INTENT(IN   ):: FID
    INTEGER, OPTIONAL, INTENT(IN   ):: IRR
    !
    IF (SFAC%HAS_ALL)             PROP = PROP * SFAC%ALL
    !
    IF (SFAC%HAS_EX1 .AND. FID>Z) PROP = PROP * SFAC%EX1(FID)  ! SCALE BYFARM
    !
    IF (SFAC%HAS_EX2 .AND. CID>Z) PROP = PROP * SFAC%EX2(CID)  !SCALE BYCROP
    !
    IF (SFAC%HAS_EX3 .AND. IRR>Z) PROP = PROP * SFAC%EX3(IRR)  !CODE EXPECTS USER PASSES IRR IF THERE IS A CHANCE OF EX3
    !
  END SUBROUTINE
  !
!!!  PURE SUBROUTINE CROP_INPUT_CAS_TO_PROP(N, ID, RC, PROP, CAS)
!!!    INTEGER,                            INTENT(IN ):: N, ID
!!!    INTEGER,          DIMENSION(TWO,N), INTENT(IN ):: RC
!!!    DOUBLE PRECISION, DIMENSION(N),     INTENT(OUT):: PROP
!!!    CLASS(COMPRESSED_ARRAY_STORAGE),    INTENT(IN ):: CAS
!!!    INTEGER:: I, J, K, M
!!!    LOGICAL:: FOUND
!!!    !
!!!    I=CAS%FIND_IDX(ID)  !SHOULD NEVER BE ZERO -- WHICH INDICATES NOT FOUND!!!
!!!    !
!!!    IF(I==Z) THEN
!!!        PROP = DZ
!!!    ELSE
!!!        DO CONCURRENT (K=ONE:N)
!!!            !
!!!            FOUND = FALSE
!!!            !
!!!            IF(K<=CAS%LOC(I)%N) THEN    !SHOULD BE ONE-ONE RELATIONSHIP, BUT CHECK ANYWAYS
!!!                  J = CAS%LOC(I)%VEC(K)
!!!                  IF(CAS%ROW(J)==RC(ONE,K) .AND. CAS%COL(J)==RC(TWO,K)) THEN
!!!                      PROP(K) = CAS%VAL( J )
!!!                      FOUND = TRUE
!!!                  END IF
!!!            END IF
!!!            !
!!!            IF(.NOT. FOUND) THEN
!!!                  DO M=ONE, CAS%LOC(I)%N
!!!                        J=CAS%LOC(I)%VEC(M)
!!!                        IF(CAS%ROW(J)==RC(ONE,K) .AND. CAS%COL(J)==RC(TWO,K)) THEN
!!!                            PROP(K) = CAS%VAL( J )
!!!                            FOUND = TRUE
!!!                            EXIT
!!!                        END IF
!!!                  END DO
!!!            END IF
!!!            !
!!!            IF(.NOT. FOUND) PROP(K) = DZ
!!!            !    
!!!        END DO
!!!    END IF
!!!    !
!!!  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, N, RC, PROP, DIM1, NREC, NDAT, DAT)
    INTEGER,                                  INTENT(IN ):: ID, N
    INTEGER,                DIMENSION(TWO,N), INTENT(IN ):: RC
    DOUBLE PRECISION,       DIMENSION(N),     INTENT(OUT):: PROP
    INTEGER,                                  INTENT(IN ):: DIM1, NREC, NDAT
    TYPE(IXJ_SINGLE_ENTRY), DIMENSION(NDAT),  INTENT(IN ):: DAT  !COULD USE (IN), BUT SINCE CUR=> COMPILER  CAN NOT HONOR IN STATUS
    !
    INTEGER:: K,P
    !
    PROP = DZ
    !
    IF    (DIM1 == 2) THEN
                          DO CONCURRENT(K=1:N, P=ONE:NREC, RC(1,K) == DAT(P)%I(2) .AND. RC(2,K) == DAT(P)%I(3))
                              !
                              PROP(K) = PROP(K) + DAT(P)%X(1)
                              !
                          END DO
    ELSEIF(DIM1 == 3) THEN
                          DO CONCURRENT(K=1:N, P=ONE:NREC, ID == DAT(P)%I(1) .AND. RC(1,K) == DAT(P)%I(2) .AND. RC(2,K) == DAT(P)%I(3))
                              !
                              PROP(K) = PROP(K) + DAT(P)%X(1)
                              !
                          END DO
                          !
                          !DO K=1, N
                          !DO P=ONE, NREC
                          !    IF(ID == DAT(P)%I(1) .AND. RC(1,K) == DAT(P)%I(2) .AND. RC(2,K) == DAT(P)%I(3))  PROP(K) = PROP(K) + DAT(P)%X(1)
                          !END DO
                          !END DO
    END IF
    !
  END SUBROUTINE
  !
  !!!PURE RECURSIVE SUBROUTINE RECORD_3WAY_SEARCH(CUR, I, NREC, I1, I2, I3, VAL)
  !!!  TYPE(IXJ_SINGLE_ENTRY), INTENT(IN   ):: CUR  
  !!!  INTEGER,                INTENT(INOUT):: I
  !!!  INTEGER,                INTENT(IN   ):: NREC, I1, I2, I3
  !!!  DOUBLE PRECISION,       INTENT(INOUT):: VAL
  !!!  !
  !!!  IF(I <= NREC) THEN
  !!!      IF( I1 == CUR%I(1) .AND. I2 == CUR%I(2) .AND. I3 == CUR%I(3) ) THEN
  !!!          VAL = CUR%X(1)
  !!!      ELSE
  !!!          I = I + ONE
  !!!          CALL RECORD_3WAY_SEARCH(CUR%NXT, I, NREC, I1, I2, I3, VAL)
  !!!      END IF
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !!!!
  !!!PURE RECURSIVE SUBROUTINE RECORD_2WAY_SEARCH(CUR, I, NREC, I1, I2, VAL)
  !!!  TYPE(IXJ_SINGLE_ENTRY), INTENT(IN   ):: CUR  
  !!!  INTEGER,                        INTENT(INOUT):: I
  !!!  INTEGER,                        INTENT(IN   ):: NREC, I1, I2
  !!!  DOUBLE PRECISION,               INTENT(INOUT):: VAL
  !!!  !
  !!!  IF(I <= NREC) THEN
  !!!      IF( I1 == CUR%I(1) .AND. I2 == CUR%I(2) ) THEN
  !!!          VAL = CUR%X(1)
  !!!      ELSE
  !!!          I = I + ONE
  !!!          CALL RECORD_2WAY_SEARCH(CUR%NXT, I, NREC, I1, I2, VAL)
  !!!      END IF
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !
!!!  PURE SUBROUTINE CROP_INPUT_IXJ_STRUCTURE_TO_PROP(ID, N, RC, PROP, DIM1, NREC, HED_REC) !USE IF STACK OVERFLOW OCCURS
!!!    INTEGER,                                INTENT(IN   ):: ID, N
!!!    INTEGER,          DIMENSION(TWO,N),     INTENT(IN   ):: RC
!!!    DOUBLE PRECISION, DIMENSION(N),         INTENT(OUT  ):: PROP
!!!    INTEGER,                                INTENT(IN   ):: DIM1, NREC
!!!    TYPE(IXJ_SINGLE_ENTRY), TARGET, INTENT(INOUT):: HED_REC  !COULD USE (IN), BUT SINCE CUR=> COMPILER  CAN NOT HONOR IN STATUS
!!!    !
!!!    TYPE(IXJ_SINGLE_ENTRY), POINTER:: CUR
!!!    INTEGER:: I,J
!!!    !
!!!    PROP = DZ
!!!    !
!!!    IF(DIM1 == 2) THEN
!!!        DO I=1, N
!!!            !
!!!            CUR => HED_REC
!!!            !
!!!            DO J=1, NREC
!!!                IF( RC(1,I) == CUR%I(1) .AND. RC(2,I) == CUR%I(2) ) THEN
!!!                    PROP(I) = CUR%X(1)
!!!                    EXIT
!!!                END IF
!!!                CUR => CUR%NXT 
!!!            END DO
!!!        END DO
!!!    ELSEIF(DIM1 == 3) THEN
!!!        DO I=1, N
!!!            !
!!!            CUR => HED_REC
!!!            !
!!!            DO J=1, NREC
!!!                IF( ID == CUR%I(1) .AND. RC(1,I) == CUR%I(2) .AND. RC(2,I) == CUR%I(3) ) THEN
!!!                    PROP(I) = CUR%X(1)
!!!                    EXIT
!!!                END IF
!!!                CUR => CUR%NXT 
!!!            END DO
!!!        END DO
!!!    END IF
!!!    !
!!!  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_ARRAY_TO_PROP(N, RC, PROP, ARRAY)
    INTEGER,                            INTENT(IN ):: N
    INTEGER,          DIMENSION(TWO,N), INTENT(IN ):: RC
    DOUBLE PRECISION, DIMENSION(N),     INTENT(OUT):: PROP
    DOUBLE PRECISION, DIMENSION(:,:),   INTENT(IN ):: ARRAY
    CONTIGUOUS:: ARRAY
    INTEGER:: K
    !
    DO CONCURRENT (K=ONE:N)
                         PROP(K) = ARRAY( RC(TWO,K), RC(ONE,K) )  !NOTE ARRAY IS STORED AS NCOL, NROW
    END DO
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_CROP_INPUT_TO_CROP_PROP_INT(CPR, CPI)
    CLASS(CROP_PROP),      INTENT(INOUT):: CPR
    TYPE(LIST_ARRAY_INPUT_INT), INTENT(IN   ):: CPI
    INTEGER:: ID, LD  ! LD => LEADING DIMENSION
    !
    IF (CPR%N > Z .AND. CPI%INUSE) THEN
       !
       ID = CPR%ID
       LD = CPR%LD
       !
       SELECT CASE(CPI%TYP)
       !!!CASE('IRR'    )
       !!!            CALL ALLOC(CPR%IRR, CPR%N)
       !!!            IF(CPI%LISTLOAD) THEN
       !!!                                    CPR%IRR = CPI%LIST(ID)
       !!!            ELSEIF(CPI%HAS_IXJ) THEN
       !!!                CONTINUE
       !!!            ELSE
       !!!                CALL CROP_INPUT_ARRAY_TO_PROP_INT(CPR%N,   CPR%RC, CPR%IRR, CPI%ARRAY(:,LD:))
       !!!            END IF
       CASE('GWRT'   )
                   CALL ALLOC(CPR%GW_INTER, CPR%N)
                   IF(CPI%LISTLOAD) THEN
                                           CPR%GW_INTER = CPI%LIST(ID)
                   ELSEIF(CPI%HAS_IXJ) THEN
                       CONTINUE
                   ELSE
                       CALL CROP_INPUT_ARRAY_TO_PROP_INT(CPR%N,   CPR%RC, CPR%GW_INTER, CPI%ARRAY(:,LD:))
                   END IF
       END SELECT
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE COPY_AND_SETUP_IRRIGATION_INPUT_TO_CROP_PROP(CDAT, NEW_IRR)
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    LOGICAL,            INTENT(INOUT):: NEW_IRR 
    INTEGER:: I,K,IRR,LD  ! LD => LEADING DIMENSION
    LOGICAL:: NEW_ALLOC
    !
    NEW_IRR = FALSE
    !
    DO I=ONE, CDAT%NCROP
     !
     CALL ALLOC(CDAT%CROP(I)%IRR, CDAT%CROP(I)%N, NEW_ALLOC=NEW_ALLOC)
     !
     IF(CDAT%CROP(I)%N > Z ) THEN
       !
       IF( NEW_ALLOC ) NEW_IRR = TRUE
       !  
       IF(CDAT%IRR%LISTLOAD) THEN
           IF(NEW_ALLOC) THEN !NOTE ENTIRE VECTOR SHOULD BE SAME VALUE
               !
               CDAT%CROP(I)%IRR = CDAT%IRR%LIST(I)
               !
           ELSEIF(CDAT%CROP(I)%IRR(ONE) .NE. CDAT%IRR%LIST(I)) THEN !NOTE ENTIRE VECTOR SHOULD BE SAME VALUE
               !
               NEW_IRR = TRUE
               !
               CDAT%CROP(I)%IRR = CDAT%IRR%LIST(I)
           END IF
       ELSE
           IF (CDAT%MULTI_CROP_CELLS) THEN
               LD = CDAT%CROP(I)%LD - ONE
               !
               DO  K=ONE, CDAT%CROP(I)%N
                   !
                   IRR = CDAT%IRR%ARRAY( CDAT%CROP(I)%RC(TWO,K), LD+CDAT%CROP(I)%RC(ONE,K) )
                   !
                   IF(.NOT. NEW_IRR) NEW_IRR = CDAT%CROP(I)%IRR(K) .NE. IRR
                   !
                   CDAT%CROP(I)%IRR(K) = IRR
               END DO
           ELSE
               DO  K=ONE, CDAT%CROP(I)%N
                   !
                   IRR = CDAT%IRR%ARRAY( CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K) )
                   !
                   IF(.NOT. NEW_IRR) NEW_IRR = CDAT%CROP(I)%IRR(K) .NE. IRR
                   !
                   CDAT%CROP(I)%IRR(K) = IRR
               END DO
           END IF
       END IF
     END IF
    END DO
    !
  END SUBROUTINE
  !
!!!  PURE SUBROUTINE CROP_INPUT_CAS_TO_PROP_INT(N, ID, RC, PROP, CAS)
!!!    INTEGER,                             INTENT(IN ):: N, ID
!!!    INTEGER,          DIMENSION(TWO,N),  INTENT(IN ):: RC
!!!    INTEGER, DIMENSION(N),               INTENT(OUT):: PROP
!!!    CLASS(COMPRESSED_ARRAY_STORAGE_INT), INTENT(IN ):: CAS
!!!    INTEGER:: I, J, K, M
!!!    LOGICAL:: FOUND
!!!    !
!!!    I=CAS%FIND_IDX(ID)  !SHOULD NEVER BE ZERO -- WHICH INDICATES NOT FOUND!!!
!!!    !
!!!    IF(I==Z) THEN
!!!        PROP = Z
!!!    ELSE
!!!        DO CONCURRENT (K=ONE:N)
!!!            !
!!!            FOUND = FALSE
!!!            !
!!!            IF(K<=CAS%LOC(I)%N) THEN    !SHOULD BE ONE-ONE RELATIONSHIP, BUT CHECK ANYWAYS
!!!                  J = CAS%LOC(I)%VEC(K)
!!!                  IF(CAS%ROW(J)==RC(ONE,K) .AND. CAS%COL(J)==RC(TWO,K)) THEN
!!!                      PROP(K) = CAS%VAL( J )
!!!                      FOUND = TRUE
!!!                  END IF
!!!            END IF
!!!            !
!!!            IF(.NOT. FOUND) THEN
!!!                  DO M=ONE, CAS%LOC(I)%N
!!!                        J=CAS%LOC(I)%VEC(M)
!!!                        IF(CAS%ROW(J)==RC(ONE,K) .AND. CAS%COL(J)==RC(TWO,K)) THEN
!!!                            PROP(K) = CAS%VAL( J )
!!!                            FOUND = TRUE
!!!                            EXIT
!!!                        END IF
!!!                  END DO
!!!            END IF
!!!            !
!!!            IF(.NOT. FOUND) PROP(K) = Z
!!!            !    
!!!        END DO
!!!    END IF
!!!    !
!!!  END SUBROUTINE
  !
  PURE SUBROUTINE CROP_INPUT_ARRAY_TO_PROP_INT(N, RC, PROP, ARRAY)
    INTEGER,                          INTENT(IN ):: N
    INTEGER,          DIMENSION(TWO,N), INTENT(IN ):: RC
    INTEGER, DIMENSION(N),            INTENT(OUT):: PROP
    INTEGER, DIMENSION(:,:),          INTENT(IN ):: ARRAY
    CONTIGUOUS:: ARRAY
    INTEGER:: K
    !
    DO CONCURRENT (K=ONE:N)
                         PROP(K) = ARRAY( RC(TWO,K), RC(ONE,K) )  !NOTE ARRAY IS STORED AS NCOL, NROW
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_WBS_IRRIGATED_AREA(CDAT,WBS)
    !
    CLASS(CROP_DATA), INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),   INTENT(INOUT):: WBS
    INTEGER:: I, K
    !
    WBS%IRR_AREA = DZ
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
          !
          WBS%IRR_AREA( CDAT%CROP(I)%FID(K) ) = WBS%IRR_AREA( CDAT%CROP(I)%FID(K) ) + CDAT%CROP(I)%AREA(K)
          !
    END DO; END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE CALC_WBS_EFFICIENCY(CDAT,WBS)
    !
    CLASS(CROP_DATA), INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),   INTENT(INOUT):: WBS
    DOUBLE PRECISION, DIMENSION(WBS%NFARM):: CIR, DMD
    INTEGER:: I, K
    !
    WBS%EFF = DZ
    CIR     = DZ
    DMD     = DZ
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
          !
          DMD(CDAT%CROP(I)%FID(K)) = DMD(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND(K)
          CIR(CDAT%CROP(I)%FID(K)) = CIR(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND(K) * CDAT%CROP(I)%EFF(K)
          !
    END DO; END DO
    !
    IF(CDAT%HAS_DEMAND_EXT) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP)
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%DEMAND_EXT(K) > NEARZERO_30)
                !
                DMD(CDAT%CROP(I)%FID(K)) = DMD(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND_EXT(K)
                CIR(CDAT%CROP(I)%FID(K)) = CIR(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND_EXT(K) * CDAT%CROP(I)%EFF(K)
                !
          END DO; END DO
    END IF
    !
    ! THIS ALREADY BE CORRECT, BUT RESET JUST TO BE SAFE
    WBS%CROP_DEMAND = DMD
    !
    DO CONCURRENT(I=ONE:WBS%NFARM, CIR(I) > NEARZERO_30);  WBS%EFF(I) = CIR(I)/DMD(I)
    END DO
    !
    END SUBROUTINE
  !
!!!  SUBROUTINE CALC_WBS_EFFICIENCY(CDAT,WBS)
!!!    !
!!!    CLASS(CROP_DATA), INTENT(IN   ):: CDAT
!!!    TYPE(WBS_DATA),   INTENT(INOUT):: WBS
!!!    DOUBLE PRECISION, DIMENSION(WBS%NFARM):: CIR, REDUCED_CIR
!!!    INTEGER:: I, K
!!!    !
!!!    WBS%EFF = DZ
!!!    CIR     = DZ
!!!    REDUCED_CIR = DZ
!!!    DO CONCURRENT (I=ONE:CDAT%NCROP, K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
!!!          !
!!!          CIR(CDAT%CROP(I)%FID(K)) = CIR(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%CIR(K)
!!!          !
!!!          REDUCED_CIR(CDAT%CROP(I)%FID(K)) = REDUCED_CIR(CDAT%CROP(I)%FID(K)) + CDAT%CROP(I)%DEMAND(K) * CDAT%CROP(I)%EFF(K)
!!!          !
!!!    END DO
!!!    !
!!!    DO CONCURRENT(I=ONE:WBS%NFARM, WBS%CROP_DEMAND(I) > NEARZERO_30)
!!!                                                           IF(WBS%CROP_DEMAND(I) > CIR(I)) THEN
!!!                                                                                                WBS%EFF(I) = CIR(I) / WBS%CROP_DEMAND(I)
!!!                                                           ELSEIF(REDUCED_CIR(I) > NEARZERO_30) THEN
!!!                                                                                                WBS%EFF(I) = REDUCED_CIR(I) / WBS%CROP_DEMAND(I)   !WBS%EFF(I) = (WBS%CROP_DEMAND(I) - CIR(I)) / CIR(I)
!!!                                                           END IF
!!!    END DO
!!!    !
!!!  END SUBROUTINE
  !
  SUBROUTINE UPDATE_TWGA_EGWA_BARE_EVAP(CDAT)  !ALSO CALCS WBS%TPRECIP, WBS%EPRECIP
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    INTEGER:: I, K, C, R
    DOUBLE PRECISION:: WT1
    !
    IF(CDAT%NCROP > Z) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP    )
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)   
              R = CDAT%CROP(I)%RC(ONE,K)
              C = CDAT%CROP(I)%RC(TWO,K)
              !
              IF(WTABLE(C,R) > NEAR_ninf) THEN
                  WT1 = WTABLE(C,R)
                  !
                  CDAT%CROP(I)%TGWA(K) = CDAT%CROP(I)%THI(K) - CDAT%CROP(I)%THD(K) * WT1
                  CDAT%CROP(I)%EGWA(K) = CDAT%CROP(I)%EHI(K) - CDAT%CROP(I)%EHD(K) * WT1
                  !
                  IF( CDAT%CROP(I)%TGWA(K) < DZ ) CDAT%CROP(I)%TGWA(K) = DZ
                  IF( CDAT%CROP(I)%EGWA(K) < DZ ) CDAT%CROP(I)%EGWA(K) = DZ
              ELSE
                  CDAT%CROP(I)%TGWA(K) = DZ
                  CDAT%CROP(I)%EGWA(K) = DZ
              END IF
          END DO; END DO
    END IF
    !
    IF(CDAT%CHECK_BARE) CALL CALC_BARE_EVAP_PASS(CDAT%NROW,CDAT%NCOL,CDAT%BARE_FRAC,CDAT%BARE_EVAP_EHI,CDAT%BARE_EVAP_EHD, WTABLE, CDAT%BARE_EVAP)  
    !
    !IF(CDAT%CHECK_BARE) THEN
    !      CDAT%BARE_EVAP = DZ
    !      DO CONCURRENT ( I = ONE:UPLAY_IDX%M)
    !          L = UPLAY_IDX%MAT(ONE,  I)
    !          R = UPLAY_IDX%MAT(TWO,  I)
    !          C = UPLAY_IDX%MAT(THREE,I)
    !          CDAT%BARE_EVAP(C,R)  = CDAT%BARE_EVAP_EHI(C,R) - CDAT%BARE_EVAP_EHD(C,R) * HNEW(C,R,L)
    !      END DO
    !      DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ .AND. WTABLE(C,R) > NEAR_ninf)
    !              !
    !              CDAT%BARE_EVAP(C,R)  = CDAT%BARE_EVAP_EHI(C,R) - CDAT%BARE_EVAP_EHD(C,R) * WTABLE(C,R)
    !      END DO
    !      !
    !      WHERE(CDAT%BARE_EVAP < DZ);  CDAT%BARE_EVAP = DZ 
    !      END WHERE
    !END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_BARE_EVAP_PASS(NROW,NCOL,BARE_FRAC,BARE_EVAP_EHI,BARE_EVAP_EHD, WT, BARE_EVAP)  
    !
    INTEGER,                                INTENT(IN ):: NCOL,NROW
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN ):: BARE_FRAC
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN ):: BARE_EVAP_EHI
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN ):: BARE_EVAP_EHD
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN ):: WT
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(OUT):: BARE_EVAP
    !
    WHERE(BARE_FRAC > DZ .AND. WT > NEAR_ninf)
             !
             BARE_EVAP = BARE_EVAP_EHI - BARE_EVAP_EHD * WT
    ELSEWHERE
             BARE_EVAP = DZ
    END WHERE
    !
    WHERE(BARE_EVAP < DZ);  BARE_EVAP = DZ
    END WHERE
    !
  END SUBROUTINE
  !
  SUBROUTINE CALC_TTOT_ETOT_TGWA_EGWA_TOTALS(CDAT, WBS, SKIP)  !ALSO CALCS WBS%TPRECIP, WBS%EPRECIP
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    CLASS(WBS_DATA),  INTENT(INOUT):: WBS
    LOGICAL,OPTIONAL, INTENT(IN   ):: SKIP
    INTEGER:: I, K, R, C, F
    !
    WBS%TIRR = DZ
    WBS%EIRR = DZ
    WBS%TPRECIP = DZ
    WBS%EPRECIP = DZ
    !
    WBS%TTOT = DZ
    WBS%TGWA = DZ
    WBS%ETOT = DZ
    WBS%EGWA = DZ
    !
    IF(CDAT%NCROP > Z) THEN
                                CDAT%TTOT = DZ
                                CDAT%TGWA = DZ
                                CDAT%ETOT = DZ
                                CDAT%EGWA = DZ
    ELSEIF(CDAT%CHECK_BARE) THEN
                                CDAT%ETOT = DZ
                                CDAT%EGWA = DZ
    END IF
    !
    IF(PRESENT(SKIP)) THEN; IF(SKIP) RETURN  !PASSED INPUT_CHECK VARIABLE
    END IF
    !
    IF(CDAT%NCROP > Z) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP)
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N) 
              !
              R = CDAT%CROP(I)%RC(ONE,K)
              C = CDAT%CROP(I)%RC(TWO,K)
              F = CDAT%CROP(I)%FID(K) 
              !
              !
              !IF (CDAT%CROP(I)%NOT_FALLOW(K)) THEN   !TI = CDAT%CROP(I)%CIR(K)/(UNO + CDAT%CROP(I)%CECT(K))  !NOTE CIR = (CROP%TSUR(K) - CROP%TPPOT(K)) * (UNO + CROP%CECT(K))
              !    !
              !    IF( CDAT%CROP(I)%TPPOT(K) >= CDAT%CROP(I)%TSUR(K) ) THEN
              !       TP = CDAT%CROP(I)%TSUR(K)                          !PLANT CONSUMED ALL ITS TRANSPIRATION FROM PRECIP
              !       TI = DZ
              !    ELSE
              !       TP = CDAT%CROP(I)%TPPOT(K)                         !PLANT CONSUMED ITS FULL PRECIP TRANSPIRATION POTENTIAL
              !       TI = CDAT%CROP(I)%TI(K) - CDAT%CROP(I)%TPPOT(K)
              !    END IF
              !ELSE   !FALLOWED CROP HAS NO TRANSPIRATION
              !       TI = DZ
              !       TP = DZ
              !END IF
              !
              CDAT%TGWA(C,R) = CDAT%TGWA(C,R) + CDAT%CROP(I)%TGWA(K)
              CDAT%TTOT(C,R) = CDAT%TTOT(C,R) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)   !  CDAT%CROP(I)%TSUR(K) = TI + TP
              !
              CDAT%EGWA(C,R) = CDAT%EGWA(C,R) + CDAT%CROP(I)%EGWA(K)
              CDAT%ETOT(C,R) = CDAT%ETOT(C,R) + CDAT%CROP(I)%EGWA(K) +  CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TI(K)*CDAT%CROP(I)%CECT(K)   !EI = TI*CECT
              !
              WBS%EIRR(F)    = WBS%EIRR(F)    + CDAT%CROP(I)%TI(K)*CDAT%CROP(I)%CECT(K)
              !
              WBS%TIRR(F)    = WBS%TIRR(F)    + CDAT%CROP(I)%TI(K) 
              WBS%TPRECIP(F) = WBS%TPRECIP(F) + CDAT%CROP(I)%TP(K)
              WBS%EPRECIP(F) = WBS%EPRECIP(F) + CDAT%CROP(I)%EP(K)
          END DO; END DO
    END IF
    !
    IF(CDAT%CHECK_BARE) THEN
          DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ)
              CDAT%EGWA(C,R) = CDAT%EGWA(C,R) + CDAT%BARE_EVAP(C,R)
              CDAT%ETOT(C,R) = CDAT%ETOT(C,R) + CDAT%BARE_EVAP(C,R) + CDAT%BARE_EVAP_PRECIP(C,R)
          END DO
          !
          DO CONCURRENT (I=ONE:WBS%NFARM)
          DO CONCURRENT (K=ONE:WBS%FID(I)%Count)
                                                 WBS%EPRECIP(I) = WBS%EPRECIP(I) + CDAT%BARE_EVAP_PRECIP( WBS%FID(I)%RC(TWO,K), WBS%FID(I)%RC(ONE,K) )
          END DO; END DO
    END IF
    !
    IF(CDAT%NCROP > Z) THEN
                                !DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, WBS%FID_ARRAY(C,R) > Z)
                                !    WBS%TTOT( WBS%FID_ARRAY(C,R) ) = WBS%TTOT( WBS%FID_ARRAY(C,R) ) + CDAT%TTOT(C,R)
                                !    WBS%TGWA( WBS%FID_ARRAY(C,R) ) = WBS%TGWA( WBS%FID_ARRAY(C,R) ) + CDAT%TGWA(C,R)
                                !    WBS%ETOT( WBS%FID_ARRAY(C,R) ) = WBS%ETOT( WBS%FID_ARRAY(C,R) ) + CDAT%ETOT(C,R)
                                !    WBS%EGWA( WBS%FID_ARRAY(C,R) ) = WBS%EGWA( WBS%FID_ARRAY(C,R) ) + CDAT%EGWA(C,R)
                                !END DO
                                DO CONCURRENT (I=ONE:WBS%NFARM)
                                DO CONCURRENT (K=ONE:WBS%FID(I)%Count)
                                    R = WBS%FID(I)%RC(ONE,K)
                                    C = WBS%FID(I)%RC(TWO,K)
                                    WBS%TTOT(I) = WBS%TTOT(I) + CDAT%TTOT(C,R)
                                    WBS%TGWA(I) = WBS%TGWA(I) + CDAT%TGWA(C,R)
                                    WBS%ETOT(I) = WBS%ETOT(I) + CDAT%ETOT(C,R)
                                    WBS%EGWA(I) = WBS%EGWA(I) + CDAT%EGWA(C,R)
                                END DO
                                END DO
    ELSEIF(CDAT%CHECK_BARE) THEN
                                DO CONCURRENT (I=ONE:WBS%NFARM)
                                DO CONCURRENT (K=ONE:WBS%FID(I)%Count)
                                    R = WBS%FID(I)%RC(ONE,K)
                                    C = WBS%FID(I)%RC(TWO,K)
                                    WBS%ETOT(I) = WBS%ETOT(I) + CDAT%ETOT(C,R)
                                    WBS%EGWA(I) = WBS%EGWA(I) + CDAT%EGWA(C,R)
                                END DO
                                END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CALC_EGW_TGW(CDAT, SOIL, KITER)
    !USE UTIL_INTERFACE, ONLY: LRC_TO_CELLID, CELLID_TO_LRC
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
    INTEGER,          INTENT(IN   )::KITER
    DOUBLE PRECISION:: RELAX
    LOGICAL:: NO_HD_TERM
    INTEGER:: I
    !TYPE(GENERIC_OUTPUT_FILE),SAVE:: ET1,ET2,BAR1,BAR2
    !INTEGER, SAVE:: KPER=1,KSTP=0
    !INTEGER:: LLOC, I, K, R, C, ID
    !
    !IF(KITER==3) THEN
    !    KSTP=KSTP+1
    !    IF(KSTP==3) THEN
    !        KPER=KPER+1
    !        KSTP=1
    !    END IF
    !END IF
    !!
    !IF(.NOT. ET1%IS_OPEN) THEN
    !    LLOC = 1
    !    CALL ET1 %OPEN(LLOC,'ET1.txt',CDAT%IOUT,0)
    !    LLOC = 1
    !    CALL ET2 %OPEN(LLOC,'ET2.txt',CDAT%IOUT,0)
    !    LLOC = 1
    !    CALL BAR1%OPEN(LLOC,'BR1.txt',CDAT%IOUT,0)
    !    LLOC = 1
    !    CALL BAR2%OPEN(LLOC,'BR2.txt',CDAT%IOUT,0)
    !    !
    !    CALL ET1 %SET_HEADER(' CROP ID KPER KSTP KITER IRR EGW EGWA TGWA TSURF TI TP EP ANOX SOIL THI THD EHI EHD')
    !    CALL ET2 %SET_HEADER(' CROP ID KPER KSTP KITER IRR EGW EGWA TGWA TSURF TI TP EP ANOX SOIL THI THD EHI EHD')
    !    CALL BAR1%SET_HEADER(' KPER KSTP KITER EVAP  EHI  EHD')
    !    CALL BAR2%SET_HEADER(' KPER KSTP KITER EVAP  EHI  EHD')
    !END IF
    !!
    !IF(KITER>51) THEN
    !    DO I=ONE,CDAT%NCROP    
    !    DO K=ONE,CDAT%CROP(I)%N 
    !                       R = CDAT%CROP(I)%RC(ONE,K)
    !                       C = CDAT%CROP(I)%RC(TWO,K)
    !                       CALL LRC_TO_CELLID(ID, 1, R, C, 1, CDAT%NROW, CDAT%NCOL)
    !                       WRITE(ET2%IU,'(7I8, *(1x,ES14.7))') I, CDAT%CROP(I)%FID(K), ID, KPER, KSTP, KITER-1, CDAT%CROP(I)%IRR(K), CDAT%CROP(I)%EGW(K),CDAT%CROP(I)%EGWA(K),CDAT%CROP(I)%TGWA(K),CDAT%CROP(I)%TSURF(K),CDAT%CROP(I)%TI(K),CDAT%CROP(I)%TP(K),CDAT%CROP(I)%EP(K),CDAT%CROP(I)%ANOX_LOSS(K),CDAT%CROP(I)%SOIL_LOSS(K),CDAT%CROP(I)%THI(K),CDAT%CROP(I)%THD(K),CDAT%CROP(I)%EHI(K),CDAT%CROP(I)%EHD(K)
    !    END DO
    !    END DO
    !    IF(CDAT%CHECK_BARE) THEN
    !    DO I=ONE,CDAT%NROW
    !    DO K=ONE,CDAT%NCOL
    !                       WRITE(BAR2%IU,'(1x,3I8, *(1x,ES14.7))') KPER, KSTP, KITER-1, CDAT%BARE_EVAP(K,I),CDAT%BARE_EVAP_EHI(K,I),CDAT%BARE_EVAP_EHD(K,I)
    !    END DO
    !    END DO
    !    END IF
    !END IF
    !
    IF(KITER >= CDAT%ITER_AVE_HEAD) THEN
        BLOCK
            INTEGER:: R,C
            DOUBLE PRECISION:: N, M
            N =  UNO / DBLE(KITER - CDAT%ITER_AVE_HEAD + ONE)
            M =  UNO - N
            !N = DBLE(KITER - CDAT%ITER_AVE_HEAD + ONE)
            !M = (N-UNO)/N
            !N = UNO / N
            DO CONCURRENT (R=ONE:CDAT%NROW)
            DO CONCURRENT (C=ONE:CDAT%NCOL, WTABLE(C,R) > NEAR_ninf)
                               CDAT%AVE_HEAD(C,R) = N*WTABLE(C,R) + M*CDAT%AVE_HEAD(C,R)
            END DO
            END DO
        END BLOCK
    ENDIF
    IF(KITER > CDAT%ITER_AVE_HEAD) THEN
        CDAT%HAS_AVE_HEAD = TRUE
    ELSE
        CDAT%HAS_AVE_HEAD = FALSE
    END IF
    !
    IF(    KITER <  CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
                                                     RELAX = CDAT%RELAX
                                                     NO_HD_TERM = FALSE
    ELSEIF(KITER == CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
                                                     RELAX = HALF
                                                     NO_HD_TERM = TRUE
    ENDIF
    !
    IF(KITER <=  CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
        !
        IF(CDAT%NCROP > Z)  CALL CALC_TRANSPIRATION(CDAT, SOIL, RELAX, NO_HD_TERM)
                            !
                            CALL CALC_EGW(CDAT, SOIL, RELAX, NO_HD_TERM)  !MUST CALL AFTER CALC_TRANSPIRATION
    END IF
    !
    ! CHECK IF LOCKING TI FOR REST OF TIME STEP
    !
    IF    (KITER == CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
           DO CONCURRENT (I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z ); CDAT%CROP(I)%TI_BAK = CDAT%CROP(I)%TI
           END DO
    ELSEIF(KITER > CDAT%ITER_CALC_EGW_TGW_LOCK) THEN
           DO CONCURRENT (I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z ); CDAT%CROP(I)%TI = CDAT%CROP(I)%TI_BAK
           END DO
    ENDIF
    !
    !IF(KITER>50) THEN
    !    DO I=ONE,CDAT%NCROP    
    !    DO K=ONE,CDAT%CROP(I)%N 
    !                       R = CDAT%CROP(I)%RC(ONE,K)
    !                       C = CDAT%CROP(I)%RC(TWO,K)
    !                       CALL LRC_TO_CELLID(ID, 1, R, C, 1, CDAT%NROW, CDAT%NCOL)
    !                       WRITE(ET1%IU,'(7I8, *(1x,ES14.7))') I, CDAT%CROP(I)%FID(K), ID, KPER, KSTP, KITER, CDAT%CROP(I)%IRR(K), CDAT%CROP(I)%EGW(K),CDAT%CROP(I)%EGWA(K),CDAT%CROP(I)%TGWA(K),CDAT%CROP(I)%TSURF(K),CDAT%CROP(I)%TI(K),CDAT%CROP(I)%TP(K),CDAT%CROP(I)%EP(K),CDAT%CROP(I)%ANOX_LOSS(K),CDAT%CROP(I)%SOIL_LOSS(K),CDAT%CROP(I)%THI(K),CDAT%CROP(I)%THD(K),CDAT%CROP(I)%EHI(K),CDAT%CROP(I)%EHD(K)
    !    END DO
    !    END DO
    !    IF(CDAT%CHECK_BARE) THEN
    !    DO I=ONE,CDAT%NROW
    !    DO K=ONE,CDAT%NCOL
    !                       WRITE(BAR1%IU,'(1x,3I8, *(1x,ES14.7))') KPER, KSTP, KITER, CDAT%BARE_EVAP(K,I),CDAT%BARE_EVAP_EHI(K,I),CDAT%BARE_EVAP_EHD(K,I)
    !    END DO
    !    END DO
    !    END IF
    !END IF
    !
  END SUBROUTINE
  !
!  SUBROUTINE CALC_EGW(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: EHI, EHD, PSIA, HH, GSE, EPOT, EPOT_OLD, HO, RELAX_HO, RELAX, EGWA, EGWA_OLD
!    !
!    IF(CDAT%NCROP > Z) THEN
!          !
!          RELAX = CDAT%RELAX
!          IF(RELAX>UNO) RELAX=UNO
!          RELAX_HO = UNO-RELAX
!          IF(RELAX_HO<NEARZERO_6) RELAX_HO = DZ
!          !
!          DO CONCURRENT   ( I=ONE:CDAT%NCROP, K=ONE:CDAT%CROP(I)%N ) 
!              !
!              R = CDAT%CROP(I)%RC(ONE,K)
!              C = CDAT%CROP(I)%RC(TWO,K)
!              L = UPLAY(C,R)
!              !
!              EHI = DZ
!              EHD = DZ
!              EGWA_OLD = DZ
!              EGWA = DZ
!              !
!              IF( CDAT%CROP(I)%EGW(K) < NEARZERO_30 .OR.                                    &        !NO EGW OR ALL EVAP COMES FROM PRECIP
!                  CDAT%CROP(I)%EGW(K) - CDAT%CROP(I)%EPPOT(K) < NEARZERO_30  .OR. L == Z    ) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  CDAT%CROP(I)%EGWA(K) = DZ
!              ELSE!------------------------------------------------------------------------------
!                  HO = HNEW_OLD(C,R,L)
!                  HH = HNEW(C,R,L)
!                  !
!                  GSE  = CDAT%CROP(I)%GSE(K)
!                  EPOT = CDAT%CROP(I)%EGW(K) - CDAT%CROP(I)%EPPOT(K)  !EPOT = EGW-EP
!                  PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                  !
!                  IF( HO > GSE ) THEN
!                      !
!                      EHI = EPOT*RELAX_HO
!                      EGWA_OLD = EHI
!                      !
!                  ELSEIF(HO < CDAT%CROP(I)%XX(K)) THEN  !GSE-CAP
!                      !
!                      EGWA_OLD = DZ
!                  ELSE
!                      !
!                      EHI = (        EPOT * ( UNO - GSE/PSIA) )*RELAX_HO
!                      EHD = ( DNEG * EPOT / PSIA              )*RELAX_HO
!                      !
!                      EGWA_OLD = EHI - EHD*HO
!                  END IF
!                  !
!                  IF( HH > GSE ) THEN
!                      !
!                      EHI = EHI + EPOT*RELAX
!                      !
!                      EGWA = EPOT*RELAX
!                      !
!                  ELSEIF(HH < CDAT%CROP(I)%XX(K)) THEN  !GSE-CAP
!                      !
!                      EGWA = DZ
!                  ELSE
!                      PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                      !
!                      EHI = EHI + (        EPOT * ( UNO - GSE/PSIA) )*RELAX
!                      EHD = EHD + ( DNEG * EPOT / PSIA              )*RELAX
!                      !
!                      !CDAT%CROP(I)%EGWA(K) = EHI - EHD*HH
!                      EGWA = ((EPOT*(UNO - GSE/PSIA)) + (HH*EPOT/PSIA ))*RELAX
!                  END IF
!                  !
!                  CDAT%CROP(I)%EGWA(K) = EGWA + EGWA_OLD
!              END IF
!              !
!              CDAT%CROP(I)%EHI(K) = EHI
!              CDAT%CROP(I)%EHD(K) = EHD
!          END DO 
!    END IF
!    !
!    IF(CDAT%CHECK_BARE) THEN
!         !
!         CDAT%BARE_EVAP = DZ
!         !
!         DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ)
!              !
!              L = UPLAY(C,R)
!              !
!              EHI = DZ
!              EHD = DZ
!              CDAT%BARE_EVAP(C,R) = DZ
!              !
!              IF( CDAT%BARE_POT_EVAP(C,R) > NEARZERO_30 .AND. L > Z) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  !
!                  HO = HNEW_OLD(C,R,L)
!                  HH = HNEW(C,R,L)
!                  GSE  = CDAT%BARE_GSE(C,R)
!                  EPOT = CDAT%BARE_POT_EVAP(C,R)
!                  PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                  !
!                  IF( HO > GSE ) THEN
!                      !
!                      EHI = EPOT*RELAX_HO
!                      EGWA_OLD = EHI
!                      !
!                  ELSEIF(HO > GSE - PSIA) THEN  !GSE-CAP
!                      !
!                      EHI = (        EPOT * ( UNO - GSE/PSIA) ) * RELAX_HO
!                      EHD = ( DNEG * EPOT / PSIA              ) * RELAX_HO
!                      !
!                      EGWA_OLD = EHI - EHD*HO
!                  END IF
!                  !
!                  IF( HH > GSE ) THEN
!                      !
!                      EHI = EHI + EPOT*RELAX
!                      EGWA = EHI
!                      !
!                  ELSEIF(HH > GSE - PSIA) THEN  !GSE-CAP
!                      !
!                      EHI = EHI + (        EPOT * ( UNO - GSE/PSIA) ) * RELAX
!                      EHD = EHD + ( DNEG * EPOT / PSIA              ) * RELAX
!                      !
!                      EGWA = EHI - EHD*HH
!                  END IF
!                  CDAT%BARE_EVAP(C,R) = EGWA + EGWA_OLD
!              END IF
!              !
!              CDAT%BARE_EVAP_EHI(C,R) = EHI
!              CDAT%BARE_EVAP_EHD(C,R) = EHD
!         END DO
!    END IF
!    !
!  END SUBROUTINE
!  !
!  SUBROUTINE CALC_EGW(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: EHI, EHD, PSIA, HH, GSE, EPOT
!    !
!    IF(CDAT%NCROP > Z) THEN
!          !
!          DO CONCURRENT   ( I=ONE:CDAT%NCROP, K=ONE:CDAT%CROP(I)%N ) 
!              !
!              R = CDAT%CROP(I)%RC(ONE,K)
!              C = CDAT%CROP(I)%RC(TWO,K)
!              L = UPLAY(C,R)
!              !
!              EHI = DZ
!              EHD = DZ
!              !
!              IF( CDAT%CROP(I)%EGW(K) < NEARZERO_30 .OR.                                    &        !NO EGW OR ALL EVAP COMES FROM PRECIP
!                  CDAT%CROP(I)%EGW(K) - CDAT%CROP(I)%EPPOT(K) < NEARZERO_30  .OR. L == Z    ) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  CDAT%CROP(I)%EGWA(K) = DZ
!              ELSE!------------------------------------------------------------------------------
!                  HH  = CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!                  GSE  = CDAT%CROP(I)%GSE(K)
!                  EPOT = CDAT%CROP(I)%EGW(K) - CDAT%CROP(I)%EPPOT(K)  !EPOT = EGW-EP
!                  !
!                  IF( HH > GSE ) THEN
!                      !
!                      EHI = EPOT
!                      CDAT%CROP(I)%EGWA(K) = EHI
!                      !
!                  ELSEIF(HH < CDAT%CROP(I)%XX(K)) THEN  !GSE-CAP
!                      !
!                      CDAT%CROP(I)%EGWA(K) = DZ
!                  ELSE
!                      PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                      !
!                      EHI =        EPOT * ( UNO - GSE/PSIA)
!                      EHD = DNEG * EPOT / PSIA  
!                      !
!                      CDAT%CROP(I)%EGWA(K) = EHI - EHD*HH
!                  END IF
!              END IF
!              !
!              CDAT%CROP(I)%EHI(K) = EHI
!              CDAT%CROP(I)%EHD(K) = EHD
!          END DO 
!    END IF
!    !
!    IF(CDAT%CHECK_BARE) THEN
!         !
!         CDAT%BARE_EVAP = DZ
!         !
!         DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ)
!              !
!              L = UPLAY(C,R)
!              !
!              EHI = DZ
!              EHD = DZ
!              !
!              IF( CDAT%BARE_POT_EVAP(C,R) > NEARZERO_30 .AND. L > Z) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  !
!                  HH  = CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!                  GSE  = CDAT%BARE_GSE(C,R)
!                  EPOT = CDAT%BARE_POT_EVAP(C,R)
!                  PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                  !
!                  IF( HH > GSE ) THEN
!                      !
!                      EHI = EPOT
!                      CDAT%BARE_EVAP(C,R) = EHI
!                      !
!                  ELSEIF(HH > GSE - PSIA) THEN  !GSE-CAP
!                      !
!                      EHI =        EPOT * ( UNO - GSE/PSIA)
!                      EHD = DNEG * EPOT / PSIA  
!                      !
!                      CDAT%BARE_EVAP(C,R) = EHI - EHD*HH
!                  END IF
!              END IF
!              !
!              CDAT%BARE_EVAP_EHI(C,R) = EHI
!              CDAT%BARE_EVAP_EHD(C,R) = EHD
!         END DO
!    END IF
!    !
!  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE CALC_CROP_OPTIMAL_UPTAKE_PRESSURE(CPR, SOIL, MLT, ONLY_K)
    !
    CLASS(CROP_PROP),  INTENT(INOUT):: CPR
    TYPE( SOIL_DATA),  INTENT(IN   ):: SOIL
    DOUBLE PRECISION,  INTENT(IN   ):: MLT
    INTEGER, OPTIONAL, INTENT(IN   ):: ONLY_K
    !
    DOUBLE PRECISION:: TPOT, PSI0, PSI1, PSI2, PSI3, XDRY, XWET, DRZ, NEXP
    DOUBLE PRECISION:: PSIWET, PSIDRY, PSI3_CM, PSIWET_CM, PSIDRY_CM
    INTEGER:: K, KK
    !
    IF(CPR%N==Z) RETURN
    !
    KK = Z
    IF(PRESENT(ONLY_K)) KK = ONLY_K
    !
    IF( ANY(NOT_NEAR_ZERO(CPR%PSI, NEARZERO_12)) ) THEN
      !
      PSI0 = DZ;  PSI1 = DZ;  PSI2 = DZ;  PSI3 = DZ
      !
      IF( CPR%PSI(ONE  ) < DZ )  PSI0 = CPR%PSI(ONE  ) * DNEG  !FLIP TO POSITIVE --SAME AS ABSOLUTE VALUE
      IF( CPR%PSI(TWO  ) < DZ )  PSI1 = CPR%PSI(TWO  ) * DNEG 
      IF( CPR%PSI(THREE) < DZ )  PSI2 = CPR%PSI(THREE) * DNEG
      IF( CPR%PSI(FOUR ) < DZ )  PSI3 = CPR%PSI(FOUR ) * DNEG
      !
      PSIWET = (PSI0+PSI1)/DOS    ! EVALUATE PRESSURE HEADS BETWEEN WHICH UPTAKE IS CONSIDERED OPTIMAL
      PSIDRY = (PSI2+PSI3)/DOS
      !
      PSI3_CM   = PSI3  *MLT
      PSIWET_CM = PSIWET*MLT
      PSIDRY_CM = PSIDRY*MLT
      !
      !DO CONCURRENT ( K=ONE:CPR%N, KK==Z .OR. KK==K )
      DO  K=ONE, CPR%N
      IF(KK==Z .OR. KK==K ) THEN
        !
        ASSOCIATE(GW_INTER=>CPR%GW_INTER(K), UXX=>CPR%UXX(K), MXX=>CPR%MXX(K), GSE=>CPR%GSE(K), SS=>CPR%SS(K), ROOT=>CPR%ROOT(K), AREA=>CPR%AREA(K), R=>CPR%RC(ONE,K), C=>CPR%RC(TWO,K))
                  !
                  TPOT = CPR%TGW(K)
                  !
                  UXX = GSE   !ONLY CHANGES IF THERE IS GROUNDWATER-ROOT INTERACTION
                  MXX = SS
                  !
                  !   GW_INTER =>
                  ! 0 = No T/No CU
                  ! 1 = No GW Interaction/Full CU from Surf/No  Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
                  ! 2 = No GW Uptake/ HAS Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
                  ! 3 = No Anoxia/No Soil Stress - But has GW Uptake
                  ! 4 = No Anoxia - But has Soil Stress and GW Uptake
                  ! 5 = Full Interaction HAS Anoxia/Soil Stress Reducation, HAS Root-Groundwater Uptake  
                  !
                  IF( AREA > DZ .AND. TPOT > DZ .AND. ANY(GW_INTER == [2,4,5]) ) THEN
                     !
                     !6B1C---CONVERT FLOWRATE OF ORIGINAL MAXIMUM TRANSPIRATION BACK TO FLUX (REASON: UXX AND MXX BELOW ARE FUNCTIONS OF T-FLUX NOT T-FLOWRATE; WITH:
                     !        UXX =    Head Elevation of Upper Extinction of Transpiration due to Anoxia
                     !        MXX =    Head Elevation of Elimination of crop-unproductive Wilting Zone)
                     !
                     !TPOT_AREA = MLT*TPOT/CPR%AREA(K)  !NOTE THIS IS A RATE RATHER THAN VOLUMETRIC RATE  --CONVERTED TO CM/T
                     !
                     !
                     DRZ =  SOIL%COEF(C,R)%A*LOG(ROOT*MLT) + SOIL%COEF(C,R)%B*LOG(MLT*TPOT/AREA) + SOIL%COEF(C,R)%C  !TAKE EXP AFTER USED FOR NEXP CALCULATION
                     NEXP = SOIL%COEF(C,R)%D*DRZ + SOIL%COEF(C,R)%E
                     DRZ  = EXP(DRZ)
                     !
                     IF(DRZ  > PSI3_CM)     DRZ  = PSI3_CM
                     IF(NEXP < NEARZERO_12) NEXP = NEARZERO_12
                     !
                     IF(PSIWET < NEARZERO_12) THEN
                         XWET = DZ
                     ELSE
                         !     
                         !6B1G---SOLVE ANALYTICAL FUNCTION FOR DEPTHS BETWEEN WHICH UPTAKE IS OPTIMAL:
                         !       ANALYTICAL FUNCTION: PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH)
                         !                            PSI(DEPTH)   IS SOLVED ITERATIVELY BY BISECTION-METHOD
                         !                                         FOR DEPTH(PSIWET) AND FOR DEPTH(PSIDRY)
                         XWET = RTFUNC(DRZ,PSI3_CM,NEXP,PSIWET_CM) / MLT
                         !
                         IF(XWET.NE.XWET) THEN
                             !CALL WARNING_MESSAGE(OUTPUT=LOUT,MSG='FMP CROP: SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XWET = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).'//NL// &
                             !                                          'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF UPPER EXTINCTION OF TRANSPIRATION DUE TO ANOXIA IS ASSUMED TO BE THE GROUND SURFACE.'//NL// &
                             !                                          'THIS PROBLEM OCCURED FOR CROP '//NUM2STR(I)//NL//' LOCATED IN ROW, COL: '//NUM2STR(R)//', '//NUM2STR(C), INLINE=TRUE)
                             XWET = DZ
                         ELSEIF(XWET < DZ)  THEN
                             XWET = DZ
                         END IF
                         !
                     ENDIF
                     !
                     IF    (XWET < NEARZERO_12 ) THEN
                                                UXX = GSE
                     ELSEIF(XWET > ROOT ) THEN
                                                UXX = SS
                     ELSEIF(XWET > PSIWET) THEN
                                                UXX = GSE - PSIWET
                     ELSE
                                                UXX = GSE - XWET
                     END IF
                     !
                     !
                     XDRY = RTFUNC(DRZ,PSI3_CM,NEXP,PSIDRY_CM) / MLT
                     !
                     !
                     IF(XDRY.NE.XDRY) THEN
                         !WRITE(CDAT%LOUT,'(/A/,A/,6A)') 'FMP CROP WARNING. SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XDRY = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).', &
                         !                               'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF ELIMINATION OF CROP-UNPRODUCTIVE WILTING ZONE IS ASSUMED TO BE THE AT THE BOTTOM OF THE ROOT ZONE.', &
                         !                               'THIS PROBLEM OCCURED FOR CROP ',NUM2STR(I),' LOCATED IN ROW, COL: ', NUM2STR(R), ', ', NUM2STR(C)
                         !CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP: SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XDRY = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).'//NL// &
                         !                                  'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF ELIMINATION OF CROP-UNPRODUCTIVE WILTING ZONE IS ASSUMED TO BE THE AT THE BOTTOM OF THE ROOT ZONE.'//NL// &
                         !                                  'THIS PROBLEM OCCURED FOR CROP '//NUM2STR(I)//NL//' LOCATED IN ROW, COL: '//NUM2STR(R)//', '//NUM2STR(C), INLINE=TRUE)
                         XDRY = ROOT
                     END IF
                     !
                     IF(XDRY >= ROOT) THEN
                         MXX = SS
                     ELSE
                         MXX = GSE - XDRY      
                     END IF
                     !
                     IF(MXX > UXX) MXX = UXX
                     !
                  END IF
        END ASSOCIATE
      END IF
      END DO
      !------------------------------------------------------------------------------------------------------------------
    ELSEIF(KK>Z) THEN
          CPR%UXX(KK) = CPR%GSE(KK)
          CPR%MXX(KK) = CPR%SS( KK)
         !---------------------------------------------------------------------------------------------------------------
    ELSE
          CPR%UXX = CPR%GSE
          CPR%MXX = CPR%SS
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CALC_TRANSPIRATION(CDAT, SOIL, RELAX, NO_HD_TERM)
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
    DOUBLE PRECISION, INTENT(IN   ):: RELAX
    LOGICAL,          INTENT(IN   ):: NO_HD_TERM
    !
    INTEGER:: I, K, R, C, T_CONCEPT
    DOUBLE PRECISION:: TPOT, TGWA, TSURF, ANOX_LOSS, SOIL_LOSS!,UXX, MXX, SS, LXX
    DOUBLE PRECISION:: THI, THD
    DOUBLE PRECISION:: PSIA, PSI0, PSI1, PSI0_PSI1
    DOUBLE PRECISION:: HH, WT0, WT1, GSE, TPOT_ROOT, GSE_POND, ROOT_POND
    DOUBLE PRECISION:: THI_SAT, THD_SAT, ALPHA, PRED, CORR
    LOGICAL:: HAS_TRANSPIRATION 
    !
    PRED = CDAT%HNEW_FACTOR
    CORR = UNO - PRED
    !
    DO I=ONE, CDAT%NCROP
    IF ( CDAT%CROP(I)%N > Z ) THEN
       !
       PSI0 = DZ;  PSI1 = DZ
       !
       IF(CDAT%HAS_PSI) THEN
          !CALL CDAT%CROP%SETUP_UXX_MXX(SOIL,CDAT%MLT)
          PSI0 = CDAT%CROP(I)%PSI(ONE)
          PSI1 = CDAT%CROP(I)%PSI(TWO)
          PSI0_PSI1 = PSI0-PSI1
          IF(PSI0_PSI1 < NEARZERO_12) PSI0_PSI1 = NEARZERO_12
       END IF
       !
       DO K=ONE, CDAT%CROP(I)%N
           !
           TPOT      = CDAT%CROP(I)%TGW(K)
           T_CONCEPT = CDAT%CROP(I)%T_CONCEPT(K)
           !
           HAS_TRANSPIRATION = TPOT >= NEARZERO_12 .AND. T_CONCEPT > Z ! .AND. CDAT%CROP(I)%AREA(K) > DZ .AND. CDAT%CROP(I)%NOT_FALLOW(K)
           !
           !########################################################################################
           !
      HAS_T: IF(HAS_TRANSPIRATION) THEN
                  !
                  R = CDAT%CROP(I)%RC(ONE,K)
                  C = CDAT%CROP(I)%RC(TWO,K)
                  !
                  !TSURF = TPOT  !DEFAULT WHEN NO GW INTERACTION
                  !
                  IF(T_CONCEPT > ONE) THEN
                      !HH  = WTABLE(C,R)
                      WT0 = WTABLE_OLD(C,R)
                      WT1 = WTABLE(C,R)
                      !
                      IF(WT0 < NEAR_ninf) WT0 = WT1
                      !
                      IF(WT1 > NEAR_ninf) THEN
                         IF(PRED > 0.99D0) THEN
                                           HH = WT1
                         ELSE
                                           HH = (WT0*CORR + WT1*PRED)
                         END IF
                         GSE = CDAT%CROP(I)%GSE(K)
                         !
                         !IF(CDAT%HAS_AVE_HEAD) THEN
                         !     HH  = CDAT%AVE_HEAD(C,R)
                         !ELSEIF(RELAX < SUB_ONE_5 .OR. NEAR_ONE_5 < RELAX) THEN
                         !     CALL RELAX_IT(HH, HNEW_OLD(C,R,UPLAY(C,R)), RELAX)  !RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD) 
                         !END IF
                      ELSE              !IBOUND = Z SO NO ROOT-GROUNDWATER INTERACTION
                          T_CONCEPT = ONE
                      END IF
                  END IF
                  !
     T_CALC:      SELECT CASE(T_CONCEPT)
                  CASE(Z) ! NO T AT ALL!!!
                      !
                      TSURF = DZ
                      !
                      THI = DZ
                      THD = DZ
                      TGWA = DZ
                      ANOX_LOSS = DZ
                      SOIL_LOSS = DZ
                      !
                  CASE(ONE) ! NO ROOT-GROUNDWATER INTERACTION -- FULL CU
                      !
                      TSURF = TPOT
                      !
                      THI   = DZ
                      THD   = DZ
                      TGWA  = DZ
                      ANOX_LOSS = DZ
                      SOIL_LOSS = DZ
                      !
                  CASE(202:205)  ! SOLVE WITH CONCEPT 2
                      !
                      THI = DZ
                      THD = DZ
                      TGWA = DZ
                      TSURF = DZ
                      ANOX_LOSS = DZ
                      SOIL_LOSS = DZ
                      !
                      ASSOCIATE(UXX=>CDAT%CROP(I)%UXX(K), MXX=>CDAT%CROP(I)%MXX(K), SS=>CDAT%CROP(I)%SS(K), LXX=>CDAT%CROP(I)%LXX(K), ROOT=>CDAT%CROP(I)%ROOT(K))
                         !
                         TPOT_ROOT = TPOT / ROOT
                         !
                         IF    (HH >= UXX ) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!  --LATTER ADD CORRECTION FOR PLANTS THAT DROWNING LIKE RICE/WILLIOWS
                               !
                               !TGWA  = DZ
                               !TSURF = DZ
                               ANOX_LOSS = TPOT
                               !
                         ELSEIF( LXX >= HH ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
                               !
                               !TGWA  = DZ
                               TSURF      = TPOT_ROOT * (UXX-SS)      !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
                               SOIL_LOSS  = TPOT - TSURF
                               !
                         ELSEIF(UXX  > HH .AND. HH > MXX) THEN !FULL UPTAKE/ANOXI Zone
                               !
                               THI = TPOT_ROOT * UXX   !TGWA = THI - THD*H = (TPOT/ROOT)*(UXX - H)
                               THD = TPOT_ROOT      
                               !
                               TGWA  = THI-THD*HH  !   TPOT_ROOT*(UXX-HH)                      !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)
                               !TSURF = DZ                                            !       Tgw-act = Tc-act
                               ANOX_LOSS = TPOT_ROOT*(HH-SS)
                               SOIL_LOSS = TPOT - TGWA - ANOX_LOSS
                               !
                         ELSEIF(MXX >= HH .AND. HH >= SS) THEN
                               !
                               THI = TPOT_ROOT*(UXX-MXX)
                               !
                               TGWA  = THI                                            !TACT = Tgw-act = Tgw-act-max < Tc-pot
                               TSURF = TPOT_ROOT*(UXX- HH) - TGWA                     !       Tgw-act < Tc-act (Tc-act varies linearly)
                               SOIL_LOSS  = TPOT - TSURF - TGWA
                               !ANOX_LOSS = DZ
                               !
                         ELSEIF(SS > HH .AND. HH > LXX) THEN
                               !
                               PSIA = SOIL%CAPILLARY_FRINGE(C,R)
                               !
                               THI =      TPOT_ROOT * (UXX-MXX) * (UNO - SS/PSIA)         !
                               THD = DNEG*TPOT_ROOT * (UXX-MXX) / PSIA                                    !IF NONLINEAR: THI & THD SEPARATION COULD BE SKIPPED:
                               !
                               TGWA  = THI-THD*HH                                                   !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)        !TACT=TMAX*(1-SS/PSIA+HH/PSIA)**2
                               TSURF = TPOT_ROOT * (UXX-SS) - TGWA                            !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
                               SOIL_LOSS  = TPOT - TSURF - TGWA
                               !
                         ENDIF
                         !-------------------------------------------------------------------------------------------------------------------------------------------------------
                         ! EVALUATE ADDITIONAL TRANSPIRATION FROM PLANTS THAT CAN TAKE DROWNING
                         IF( PSI0 > NEARZERO_12 .AND. PSI1 >= DZ ) THEN
                             !
                             !9E2----EVALUATE ACTUAL TRANSPIRATION (FULL UPTAKE) FROM THE SATURATED ROOT ZONE (TGWSAT1)
                             IF( MAX(SS, HH-PSI1) > MIN(GSE, HH) ) THEN
                                                             CONTINUE !TGWSAT1=DZ   --DO NOTHING
                             ELSEIF(HH > GSE) THEN !, THD_SAT
                                                   IF(SS >= HH-PSI1 )THEN
                                                             THI_SAT = TPOT   ! = TGWSAT1 RHSS=RHSS+TGWSAT1
                                                             !
                                                             THI = THI_SAT
                                                             !
                                                             TGWA  = THI  !THI_SAT
                                                             TSURF = DZ
                                                             ANOX_LOSS = DZ
                                                             SOIL_LOSS = DZ
                                                   ELSE!IF(HH-PSI1 > SS)THEN
                                                             THI_SAT = TPOT_ROOT*(GSE+PSI1)
                                                             THD_SAT = TPOT_ROOT
                                                             !                                                                   
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                   END IF
                             ELSE!IF(GSE > HH) ==> HH < GSE
                                                   IF(SS >= HH-PSI1)THEN
                                                             THI_SAT = DNEG * TPOT_ROOT * SS  !(TPOT/TRZ)*(TRZ-GSE))
                                                             THD_SAT = DNEG * TPOT_ROOT
                                                             !
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH 
                                                             TSURF = DZ
                                                             SOIL_LOSS = TPOT-TGWA
                                                             ANOX_LOSS = DZ
                                                   ELSE!IF(HH-PSI1 > SS)THEN
                                                             THI_SAT = TPOT_ROOT*PSI1
                                                             !
                                                             THI = THI + THI_SAT
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT  !RHSS=RHSS+THISAT1
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                   ENDIF
                             END IF
                             !
                             !9E3----EVALUATE ACTUAL TRANSPIRATION (PARTIAL UPTAKE) FROM SATURATED ROOT ZONE (TGWSAT2)
                             IF(MAX(HH-PSI0, SS) > MIN(HH-PSI1, GSE) ) THEN
                                                             CONTINUE !TGWSAT2=DZ   --DO NOTHING
                             ELSEIF(GSE > HH-PSI1) THEN
                                                        IF(HH-PSI0 >= SS)THEN
                                                             THI_SAT = TPOT_ROOT * PSI0_PSI1 / DOS
                                                             !
                                                             THI = THI + THI_SAT                                    !RHSS=RHSS+THISAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT 
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                        ELSE
                                                             ALPHA   = HALF + (PSI0-HH+SS)/(DOS*PSI0_PSI1)
                                                             THI_SAT = DNEG*TPOT_ROOT*ALPHA*(SS+PSI1)
                                                             THD_SAT = DNEG*TPOT_ROOT*ALPHA
                                                             !
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
                                                             TSURF = DZ
                                                             SOIL_LOSS = TPOT-TGWA
                                                             ANOX_LOSS = DZ
                                                        ENDIF
                             ELSE!IF(HH-PSI1 > GSE) THEN
                                                        IF(HH-PSI0 > SS) THEN
                                                             ALPHA   = (GSE-HH+PSI0) / (DOS*PSI0_PSI1)
                                                             THI_SAT = TPOT_ROOT*ALPHA*(GSE+PSI0)
                                                             THD_SAT = TPOT_ROOT*ALPHA
                                                             !
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH    !TGWSAT2=THISAT2-THDSAT2*HH
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                        ELSE
                                                             !THI_SAT = TPOT_ROOT * (DOS*PSI0 - CDAT%CROP(I)%ROOT(K)) / (DOS * PSI0_PSI1)  !GSE+SS = -ROOT   --SS = GSE - ROOT  fixed summation
                                                             !THD_SAT = TPOT_ROOT / PSI0_PSI1
                                                             THI_SAT = (DOS*PSI0 + GSE + SS) * TPOT / (DOS * PSI0_PSI1)
                                                             THD_SAT = TPOT / PSI0_PSI1
                                                             !
                                                             THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
                                                             THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
                                                             !
                                                             TGWA  = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH     !TGWSAT2=THISAT2-THDSAT2*HH
                                                             TSURF = DZ
                                                             ANOX_LOSS = TPOT-TGWA
                                                             SOIL_LOSS = DZ
                                                        END IF
                             END IF
                         END IF
                      END ASSOCIATE
                      !
                  CASE(102:105)  !SOLVE WITH CONCEPT 1  --CODE IDENTICAL TOO "SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)"
                      !
                      SOIL_LOSS = DZ  !THIS IS ALWAYS ZERO FOR CONCEPT 2
                      !
                      IF(CDAT%HAS_POND) THEN
                          GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
                          ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
                      ELSE
                          GSE_POND = GSE
                          ROOT_POND= CDAT%CROP(I)%ROOT(K)
                      END IF
                      !
                      IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
                             !
                             THI = DZ
                             THD = DZ
                             TGWA = DZ
                             TSURF  = DZ
                             ANOX_LOSS=TPOT
                             !
                      ELSEIF(HH >= CDAT%CROP(I)%SS(K) .AND. ROOT_POND > NEARZERO_12) THEN
                             !
                             THI = TPOT * (GSE_POND / ROOT_POND)
                             THD = TPOT / ROOT_POND
                             !
                             TGWA = THI-THD*HH 
                             TSURF  = DZ
                             ANOX_LOSS=TPOT-TGWA
                             !
                      ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
                             !
                             THI  = DZ
                             THD  = DZ
                             TGWA = DZ
                             TSURF  = TPOT
                             ANOX_LOSS=DZ
                             !
                      ELSE                                     ! LXX < HH < SS
                             PSIA = SOIL%CAPILLARY_FRINGE(C,R)
                             !
                             THI = TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA) !TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
                             THD = DNEG*TPOT / PSIA
                             !
                             TGWA      = THI-THD*HH 
                             TSURF     = TPOT - TGWA
                             ANOX_LOSS = DZ
                      END IF
                  CASE DEFAULT
                      WRITE(*,'(A)') 'THIS SHOULD NOT HAPPEN FOR CROP '//NUM2STR(I)//' AT ROW, COL '//NUM2STR(R,-5)//NUM2STR(C,-5)
                      !
                  END SELECT  T_CALC
                  !
                  !########################################################################################
                  !
                  IF(TGWA  > TPOT) THEN
                      THI = THI - (TGWA-TPOT)
                      TGWA  = TPOT
                  END IF
                  IF(TSURF + TGWA > TPOT .AND. TSURF>DZ) TSURF = TPOT - TGWA
                  !
                  IF(NO_HD_TERM) THEN
                      THI = THI - THD*HH
                      THD = DZ
                  ELSEIF(PRED <= 0.99D0) THEN
                         THI = THI - THD*CORR*WT0
                         THD =       THD*PRED
                  END IF
                  !
                  IF(ANOX_LOSS< NEARZERO_12) ANOX_LOSS=DZ
                  IF(SOIL_LOSS< NEARZERO_12) SOIL_LOSS=DZ
                  IF(TSURF    < NEARZERO_12) TSURF=DZ
                  !
                  !CALL SET_NEAR_ZERO(THI, NEARZERO_12)
                  !CALL SET_NEAR_ZERO(THD, NEARZERO_12)
                  IF(NEGNEARZERO_12 < THI .AND. THI < NEARZERO_12) THI = DZ
                  IF(NEGNEARZERO_12 < THD .AND. THD < NEARZERO_12) THD = DZ
                  !
                  IF(TGWA > NEARZERO_12) TGWA = THI - THD*WT1  !RECALCULATE TGWA IN CASE IT IS OUT OF SYNC WITH THI AND THD
                  IF(TGWA < NEARZERO_12) THEN
                                         TGWA =DZ
                                         THI = DZ
                                         THD = DZ
                  END IF
                  !
                  ! 0 = No Transpiration            ==> Zeros out any T requirement
                  ! 1 = No Groundwater Interaction  ==> No Root-Groundwater Uptake, No  Anoxia or Stress Reduction, Full CU must be met through surface sources (Precip or Irigiation)
                  ! 2 = Has Anoxia/Soil Stress Loss,                      NO Root-Groundwater Uptake ==> CU Reduced from any anoxia and soil stress, but CU may only be satisfied with surface sources
                  ! 3 = Has Root-Groundwater Uptake,                      NO Anoxia/Soil Stress Loss ==> Anoxia and Soil Stress losses are either added to Root-Groundwater Uptake or surface consumption requirement  (i.e. if there is root-groundwater uptake, then the ammount lossed through anoxia is consumed as root-groundwater uptake. However if there is no root-groundwater uptake then the anoxia is added to the surface sources consumption (Precip or Irigiation) 
                  ! 4 = Has Root-Groundwater Uptake and Soil Stress Loss, NO Anoxia Loss             ==> Anoxia                 losses are either added to Root-Groundwater Uptake or surface consumption requirement  (i.e. if there is root-groundwater uptake, then the ammount lossed through anoxia is consumed as root-groundwater uptake. However if there is no root-groundwater uptake then the anoxia is added to the surface sources consumption (Precip or Irigiation) 
                  ! 5 = Full Interaction  ==> HAS Anoxia/Soil Stress Reducation, HAS Root-Groundwater Uptake  (DEFAULT)
                  !
                  SELECT CASE(CDAT%CROP(I)%GW_INTER(K))
                  CASE(0,1,5)   !CASES THAT DO NOT ALTER TSURF/TGWA
                              CONTINUE
                  CASE(TWO)   !NO GROUNDWATER UPTAKE BUT ANOXIA AND SOIL STRESS
                                       TSURF = TSURF + TGWA
                                       TGWA  = DZ
                                       THI   = DZ
                                       THD   = DZ
                  CASE(THREE) !NO AOXIA NOR SOIL LOSSES
                             IF(ANOX_LOSS > NEARZERO_12 .OR. SOIL_LOSS > NEARZERO_12) THEN
                                IF(TSURF > DZ) THEN
                                    TSURF = TSURF + ANOX_LOSS+SOIL_LOSS
                                ELSE
                                    TGWA  = TGWA  + ANOX_LOSS+SOIL_LOSS
                                    THI   = THI   + ANOX_LOSS+SOIL_LOSS
                                END IF
                             END IF
                             ANOX_LOSS = DZ
                             SOIL_LOSS = DZ
                  CASE(FOUR) !NO ANOXIA LOSSES
                             IF(ANOX_LOSS > NEARZERO_12) THEN
                                IF(TSURF > DZ) THEN
                                    TSURF = TSURF + ANOX_LOSS
                                ELSE
                                    TGWA  = TGWA + ANOX_LOSS
                                    THI   = THI  + ANOX_LOSS
                                    TSURF = DZ
                                END IF
                             END IF
                             ANOX_LOSS = DZ
                  CASE DEFAULT
                      WRITE(*,'(A)') 'THIS SHOULD NOT HAPPEN FOR CROP '//NUM2STR(I)//' AT ROW, COL '//NUM2STR(R,-5)//NUM2STR(C,-5)//' GW_INTER: '//NUM2STR(CDAT%CROP(I)%GW_INTER(K))
                  END SELECT 
                  !
                  !
                  !IF(TSURF + TGWA > TPOT) THEN
                  !    IF(TSURF + TGWA > DZ) THEN
                  !        ALPHA = TPOT / (TSURF + TGWA)
                  !        TSURF = TSURF * ALPHA
                  !        TGWA  = TGWA  * ALPHA
                  !    END IF
                  !END IF
                  !
                  CDAT%CROP(I)%THI(K) = THI  !TGWA = THI - THD*H
                  CDAT%CROP(I)%THD(K) = THD
                  !
                  CDAT%CROP(I)%TGWA(K)      = TGWA
                  CDAT%CROP(I)%TSURF(K)     = TSURF
                  CDAT%CROP(I)%ANOX_LOSS(K) = ANOX_LOSS
                  CDAT%CROP(I)%SOIL_LOSS(K) = SOIL_LOSS
                  !
                  IF( CDAT%CROP(I)%IRR(K) > Z) THEN
                      IF( CDAT%CROP(I)%TPPOT(K) < TSURF ) THEN
                           CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
                           CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
                      ELSE
                           CDAT%CROP(I)%TI(K) = DZ
                           CDAT%CROP(I)%TP(K) = TSURF
                      END IF
                  ELSE
                      CDAT%CROP(I)%TI(K) = DZ
                      !
                      IF( CDAT%CROP(I)%TPPOT(K) < TSURF ) THEN
                           CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
                      ELSE
                           CDAT%CROP(I)%TP(K) = TSURF
                      END IF
                  END IF
                  !
                  IF(CDAT%CROP(I)%TI(K) < DZ) CDAT%CROP(I)%TI(K) = DZ
                  IF(CDAT%CROP(I)%TP(K) < DZ) CDAT%CROP(I)%TP(K) = DZ
                  !
                  !IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF) THEN
                  !    !
                  !    CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
                  !    CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
                  !    !
                  !ELSEIF( CDAT%CROP(I)%TPPOT(K) > TSURF ) THEN
                  !    CDAT%CROP(I)%TI(K) = DZ
                  !    CDAT%CROP(I)%TP(K) = TSURF
                  !ELSE
                  !    CDAT%CROP(I)%TI(K) = DZ
                  !    CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
                  !END IF
           ELSE !NO HAS_T
                  CDAT%CROP(I)%THI(K)   = DZ
                  CDAT%CROP(I)%THD(K)   = DZ
                  CDAT%CROP(I)%TGWA(K)  = DZ
                  CDAT%CROP(I)%TSURF(K) = DZ
                  CDAT%CROP(I)%TI(K)    = DZ
                  CDAT%CROP(I)%TP(K)    = DZ
                  CDAT%CROP(I)%ANOX_LOSS(K) = DZ
                  CDAT%CROP(I)%SOIL_LOSS(K) = DZ
           END IF HAS_T
           !
          END DO
    END IF
    END DO
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE CALC_EGW_CROP_VEC(N, RC, IRR, CU, GSE, TGWA, CECT, TI, TP, EPPOT, XX, EP, EHI, EHD, EGWA, EGW, CAPILLARY_FRINGE, NO_HD_TERM) !, FTR=>CDAT%CROP(I)%FTR(K)
  !!!  !
  !!!  INTEGER, INTENT(IN):: N
  !!!  INTEGER,          DIMENSION(TWO,N), INTENT(IN   ):: RC
  !!!  INTEGER,          DIMENSION(N),     INTENT(IN   ):: IRR
  !!!  DOUBLE PRECISION, DIMENSION(N),     INTENT(IN   ):: CU, GSE, TGWA, CECT, TI, TP, EPPOT, XX
  !!!  DOUBLE PRECISION, DIMENSION(N),     INTENT(INOUT):: EP, EHI, EHD, EGWA, EGW
  !!!  LOGICAL,                            INTENT(IN   ):: NO_HD_TERM
  !!!  DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: CAPILLARY_FRINGE
  !!!  INTEGER:: K
  !!!  DOUBLE PRECISION:: FRINGE, EPOT, HH
  !!!  !
  !!!  DO CONCURRENT (K=ONE:N) 
  !!!     !
  !!!     EHI(K) = DZ
  !!!     EHD(K) = DZ
  !!!     !
  !!!     IF(IRR(K) > Z) THEN    !Tgw - ETi
  !!!         EGW(K) = CU(K) - TP(K) - TGWA(K) - TI(K)*(UNO + CECT(K)) ! = EP + EGWA
  !!!     ELSE
  !!!         EGW(K) = CU(K) - TP(K) - TGWA(K)
  !!!     END IF
  !!!     !
  !!!     !EGW = CU * (UNO - FTR)   !SCOTT -- FOR CHECKING AGAINST OWHMv1
  !!!     !
  !!!     IF(EGW(K) > CU(K)      ) EGW(K) = CU(K)
  !!!     IF(EGW(K) < NEARZERO_12) EGW(K) = DZ
  !!!     !
  !!!     IF(EGW(K) > EPPOT(K)) THEN !EPPOT IS TOO LARGE -- No Egw
  !!!         EP(K) = EPPOT(K)
  !!!         EPOT  = EGW(K) - EP(K)
  !!!     ELSE
  !!!         EP(K) = EGW(K)
  !!!         EPOT  = DZ
  !!!     END IF
  !!!     !
  !!!     IF(EP(K) < DZ) EP(K) = DZ
  !!!     !
  !!!     IF( EPOT < NEARZERO_12) THEN             !NO EGW OR ALL EVAP COMES FROM PRECIP; L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
  !!!         EGWA(K) = DZ
  !!!     ELSE!------------------------------------------------------------------------------
  !!!         !
  !!!         HH  = WTABLE(RC(TWO,K),RC(ONE,K))
  !!!         !
  !!!         IF( HH > GSE(K) ) THEN
  !!!             !
  !!!             EHI(K)  = EPOT
  !!!             EGWA(K) = EHI(K)
  !!!             !EHD  = DZ
  !!!             !
  !!!         ELSEIF(HH < XX(K)) THEN  !GSE-CAP
  !!!             !
  !!!             !EHI  = DZ
  !!!             !EHD  = DZ
  !!!             EGWA(K) = DZ
  !!!         ELSE
  !!!             FRINGE = CAPILLARY_FRINGE(RC(TWO,K),RC(ONE,K))
  !!!             !
  !!!             EHI(K) =        EPOT * ( UNO - GSE(K)/FRINGE)
  !!!             EHD(K) = DNEG * EPOT / FRINGE  
  !!!             !
  !!!             EGWA(K) = EHI(K) - EHD(K)*HH
  !!!         END IF
  !!!         !
  !!!         IF(EGWA(K) < NEARZERO_12) THEN
  !!!             EHI(K)  = DZ
  !!!             EHD(K)  = DZ
  !!!             EGWA(K) = DZ
  !!!         ELSEIF(NO_HD_TERM) THEN
  !!!             EHI(K) = EHI(K) - EHD(K)*HH
  !!!             EHD(K) = DZ
  !!!         END IF
  !!!         !
  !!!     END IF
  !!!  END DO
  !!!  !
  !!!END SUBROUTINE
  !
  PURE SUBROUTINE CALC_EGW(CDAT, SOIL, RELAX, NO_HD_TERM) !THIS MUST BE CALLED AFTER T CALCULATION
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
    DOUBLE PRECISION, INTENT(IN   ):: RELAX
    LOGICAL,          INTENT(IN   ):: NO_HD_TERM
    INTEGER:: I, K, R, C
    DOUBLE PRECISION:: FRINGE, EPOT, HH, WT0, WT1, PRED, CORR
    !
    PRED = CDAT%HNEW_FACTOR
    CORR = UNO - PRED
    !
    IF(CDAT%NCROP > Z) THEN
         !
         DO I=ONE, CDAT%NCROP
         IF(CDAT%CROP(I)%N > Z ) THEN
             !CALL CALC_EGW_CROP_VEC(CDAT%CROP(I)%N,   CDAT%CROP(I)%RC,  CDAT%CROP(I)%IRR,                       &
             !                       CDAT%CROP(I)%CU,  CDAT%CROP(I)%GSE, CDAT%CROP(I)%TGWA,  CDAT%CROP(I)%CECT,  &
             !                       CDAT%CROP(I)%TI,  CDAT%CROP(I)%TP,  CDAT%CROP(I)%EPPOT, CDAT%CROP(I)%XX, &
             !                       CDAT%CROP(I)%EP,  CDAT%CROP(I)%EHI, CDAT%CROP(I)%EHD,   CDAT%CROP(I)%EGWA,  &
             !                       CDAT%CROP(I)%EGW, SOIL%CAPILLARY_FRINGE, NO_HD_TERM)
         DO K=ONE, CDAT%CROP(I)%N
            !
            ASSOCIATE( CU =>CDAT%CROP(I)%CU(K),     IRR =>CDAT%CROP(I)%IRR(K),    GSE=>CDAT%CROP(I)%GSE(K),   &
                       TGWA=>CDAT%CROP(I)%TGWA(K),  CECT=>CDAT%CROP(I)%CECT(K),                               & !P  =>CDAT%CROP(I)%PRECIP(K), 
                       TI =>CDAT%CROP(I)%TI(K),     TP =>CDAT%CROP(I)%TP(K),      EP =>CDAT%CROP(I)%EP(K),    &
                     EPPOT=>CDAT%CROP(I)%EPPOT(K),  EHI=>CDAT%CROP(I)%EHI(K),     EHD=>CDAT%CROP(I)%EHD(K),   &
                     EGWA =>CDAT%CROP(I)%EGWA(K),   EGW=>CDAT%CROP(I)%EGW(K),     FTR=>CDAT%CROP(I)%FTR(K)     ) !<==VARAIBLES SET BY LOOP
                        !
                 R   = CDAT%CROP(I)%RC(ONE,K)
                 C   = CDAT%CROP(I)%RC(TWO,K)
                 !
                 EHI = DZ
                 EHD = DZ
                 !
                 !!!IF(FTR < UNO) THEN
                     !
                     !!!EPPOT = P - TP
                     !!!IF(EPPOT < NEARZERO_12) EPPOT = DZ
                     !
                     IF (CDAT%TPOT_SHIFT_EPOT) THEN
                        IF(IRR > Z) THEN    !Tgw - ETi
                            EGW = CU - TP - TGWA - TI*(UNO + CECT) ! = EP + EGWA
                        ELSE
                            EGW = CU - TP - TGWA
                        END IF
                        !
                        IF(EGW > CU         ) EGW = CU
                        IF(EGW < NEARZERO_12) EGW = DZ
                     ELSE
                         EGW = CU * (UNO - FTR)   !SCOTT -- FOR CHECKING AGAINST OWHMv1
                     END IF
                     !
                     IF(EGW > EPPOT) THEN !EPPOT IS TOO LARGE -- No Egw
                         EP   = EPPOT
                         EPOT = EGW - EP
                     ELSE
                         EP   = EGW
                         EPOT = DZ
                     END IF
                     !
                     IF(EP < DZ) EP = DZ
                 !!!ELSE
                 !!!    EGW   = DZ 
                 !!!    !!!EPPOT = DZ
                 !!!    EP    = DZ
                 !!!    EPOT  = DZ
                 !!!END IF
                 !
                 IF( EPOT < NEARZERO_12) THEN             !NO EGW OR ALL EVAP COMES FROM PRECIP; L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
                     EPOT = DZ
                     EGWA = DZ
                 ELSEIF(WTABLE(C,R) < NEAR_ninf ) THEN   !NO EGW OR ALL EVAP COMES FROM PRECIP; L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
                     EPOT = DZ
                     EGWA = DZ
                 ELSE!------------------------------------------------------------------------------
                     !
                     WT0 = WTABLE_OLD(C,R) !HOLD(C,R, UPLAY(C,R))
                     WT1 = WTABLE(C,R)
                     !
                     IF(WT0 < NEAR_ninf) WT0 = WT1
                     !
                     IF(PRED > 0.99D0 .OR. WT1 < NEAR_ninf) THEN
                                       HH = WT1
                     ELSE
                                       HH = (WT0*CORR + WT1*PRED)
                     END IF 
                     !
                     !IF(CDAT%HAS_AVE_HEAD) THEN
                     !     HH  = CDAT%AVE_HEAD(C,R)
                     !ELSEIF(SUB_ONE_5 < RELAX .AND. RELAX < NEAR_ONE_5) THEN
                     !     HH  = WTABLE(C,R) 
                     !ELSE
                     !     CALL RELAX_IT(HH, WTABLE(C,R), HNEW_OLD(C,R,UPLAY(C,R)), RELAX)    !HNEW = HOLD + FRAC*(HNEW-HOLD)
                     !END IF
                     !
                     IF( HH > GSE ) THEN
                         !
                         EHI  = EPOT
                         EGWA = EHI
                         !EHD  = DZ
                         !
                     ELSEIF(HH < CDAT%CROP(I)%XX(K)) THEN  !GSE-CAP
                         !
                         !EHI  = DZ
                         !EHD  = DZ
                         EGWA = DZ
                     ELSE                                    !Only enter whem CAP>0
                         FRINGE = SOIL%CAPILLARY_FRINGE(C,R)
                         !
                         EHI =        EPOT * ( UNO - GSE/FRINGE)
                         EHD = DNEG * EPOT / FRINGE
                         !
                         IF(PRED <= 0.99D0) THEN
                                            EHI = EHI - EHD*CORR*WT0    !Remove the HOLD portion from EHD (EHD*HH = EHD*(WT0+WT1)/DOS
                                            EHD =       EHD*PRED
                         END IF
                         !
                         EGWA = EHI - EHD*WT1
                     END IF
                     !
                     IF(EGWA < NEARZERO_12) THEN
                         EHI  = DZ
                         EHD  = DZ
                         EGWA = DZ
                     ELSEIF(NO_HD_TERM) THEN
                         EHI = EHI - EHD*WT1
                         EHD = DZ
                     END IF
                     !
                 END IF
            END ASSOCIATE
         END DO
         END IF
         END DO
    END IF
    !
    IF(CDAT%CHECK_BARE) THEN
         !
         DO R=ONE, CDAT%NROW
         DO C=ONE, CDAT%NCOL
         IF ( CDAT%BARE_FRAC(C,R) > DZ ) THEN
            !
            ASSOCIATE( EBPOT=>CDAT%BARE_POT_EVAP(C,R), GSE=>CDAT%BARE_GSE(C,R),     BARE_FRINGE=>SOIL%CAPILLARY_FRINGE(C,R),    &
                       EHI=>CDAT%BARE_EVAP_EHI(C,R),   EHD=>CDAT%BARE_EVAP_EHD(C,R),       EGWA=>CDAT%BARE_EVAP(C,R)            ) !<==VARAIBLES SET BY LOOP
                       !
                 !
                 EHI  = DZ
                 EHD  = DZ
                 EGWA = DZ
                 !
                 IF( EBPOT > NEARZERO_12 .AND. WTABLE(C,R) > NEAR_ninf) THEN   !L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
                     !
                     WT0 = WTABLE_OLD(C,R) !HOLD(C,R, UPLAY(C,R))
                     WT1 = WTABLE(C,R)
                     !
                     IF(WT0 < NEAR_ninf) WT0 = WT1
                     !
                     IF(PRED > 0.99D0 .OR. WT1 < NEAR_ninf) THEN
                                       HH = WT1
                     ELSE
                                       HH = (WT0*CORR + WT1*PRED)
                     END IF
                     !
                     !IF(CDAT%HAS_AVE_HEAD) THEN
                     !     HH  = CDAT%AVE_HEAD(C,R)
                     !ELSEIF(SUB_ONE_5 < RELAX .AND. RELAX < NEAR_ONE_5) THEN
                     !     HH  = WTABLE(C,R)
                     !ELSE
                     !     CALL RELAX_IT(HH, WTABLE(C,R), HNEW_OLD(C,R,UPLAY(C,R)), RELAX) 
                     !END IF
                     !
                     IF( HH > GSE ) THEN
                         !
                         EHI  = EBPOT
                         !CALL SET_NEAR_ZERO(EHI,NEARZERO_12)
                         IF(NEGNEARZERO_12 < EHI .AND. EHI < NEARZERO_12) EHI = DZ
                         !
                         EGWA = EHI
                         EHD  = DZ
                         !
                     ELSEIF(HH > GSE - BARE_FRINGE) THEN  !GSE-CAP
                         !
                         EHI =        EBPOT * ( UNO - GSE/BARE_FRINGE)
                         EHD = DNEG * EBPOT / BARE_FRINGE  
                         !
                         IF(PRED <= 0.99D0) THEN
                                            EHI = EHI - EHD*CORR*WT0    !Remove the HOLD portion from EHD (EHD*HH = EHD*(WT0+WT1)/DOS
                                            EHD =       EHD*PRED
                         END IF
                         !
                         IF(NEGNEARZERO_12 < EHI .AND. EHI < NEARZERO_12) EHI = DZ
                         IF(NEGNEARZERO_12 < EHD .AND. EHD < NEARZERO_12) EHD = DZ
                         !
                         EGWA = EHI - EHD*HH
                     ELSE
                         EHI  = DZ
                         EHD  = DZ
                     END IF
                 END IF
                 !
                 IF(NO_HD_TERM) THEN
                     EHI = EHI - EHD*HH
                     EHD = DZ
                 END IF
                 !
                 IF(EGWA < NEARZERO_12) THEN
                     EHI  = DZ
                     EHD  = DZ
                     EGWA = DZ
                 END IF
            END ASSOCIATE
         END IF
         END DO
         END DO
    END IF
    !
  END SUBROUTINE
  !
!  SUBROUTINE CALC_TRANSPIRATION(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    !
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: TGWA
!    DOUBLE PRECISION:: PSIA, PSI0, PSI1, PSI2, PSI3, PSI3_CM, XDRY, XWET
!    DOUBLE PRECISION:: HH, HO, GSE, TPOT, TPOT_ROOT, TPOT_AREA, TSURF, ANOX_STRESS,GSE_POND, ROOT_POND
!    DOUBLE PRECISION:: PSIDRY, PSIWET, PSIWET_CM, PSIDRY_CM, PSI0_PSI1
!    DOUBLE PRECISION:: UXX, MXX, DRZ, NEXP, THI, THD, THI_SAT, THD_SAT, ALPHA, DEL
!    LOGICAL:: HAS_NONZERO_PSI, HAS_TRANSPIRATION 
!    INTEGER:: NPOINT
!    DOUBLE PRECISION:: DPOINT
!    !
!    NPOINT = 1   !10
!    DPOINT = 1D0 !10D0
!    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
!       !
!       PSI0 = DZ;  PSI1 = DZ;  PSI2 = DZ;  PSI3 = DZ
!       !
!       IF(CDAT%HAS_PSI) THEN
!          IF( CDAT%CROP(I)%PSI(ONE  ) < DZ )  PSI0 = CDAT%CROP(I)%PSI(ONE  ) * DNEG  !FLIP TO POSITIVE --SAME AS ABSOLUTE VALUE
!          IF( CDAT%CROP(I)%PSI(TWO  ) < DZ )  PSI1 = CDAT%CROP(I)%PSI(TWO  ) * DNEG 
!          IF( CDAT%CROP(I)%PSI(THREE) < DZ )  PSI2 = CDAT%CROP(I)%PSI(THREE) * DNEG
!          IF( CDAT%CROP(I)%PSI(FOUR ) < DZ )  PSI3 = CDAT%CROP(I)%PSI(FOUR ) * DNEG
!       END IF
!       !
!       DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
!           !
!           R = CDAT%CROP(I)%RC(ONE,K)
!           C = CDAT%CROP(I)%RC(TWO,K)
!           L = UPLAY(C,R)
!           !
!           THI = DZ
!           THD = DZ
!           TGWA = DZ
!           TSURF = DZ
!           ANOX_STRESS = DZ
!           !
!           TPOT = CDAT%CROP(I)%TGW(K)
!           IF(TPOT < NEARZERO_12) TPOT = DZ
!           !
!           HAS_TRANSPIRATION = TPOT > NEARZERO_12 .AND. L > Z .AND. CDAT%CROP(I)%T_CONCEPT(K) > Z .AND. CDAT%CROP(I)%AREA(K) > DZ .AND. CDAT%CROP(I)%NOT_FALLOW(K)
!           !
!           IF(CDAT%CROP(I)%T_CONCEPT(K) > ONE) THEN
!                 GSE = CDAT%CROP(I)%GSE(K)
!                 HO  = HOLD(C,R,L)
!                 HH  = RELAXER(HNEW(C,R,L), HNEW_OLD(C,R,L), CDAT%RELAX)  !CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD) 
!                 !
!                 IF(NPOINT>ONE) THEN
!                     DEL = (HH-HO)/DPOINT
!                 ELSE
!                     DEL = HH-HO
!                 END IF
!                 !
!           END IF
!           !
!           !########################################################################################
!           !
!      HAS_T: IF(HAS_TRANSPIRATION) THEN
!     T_CALC:      SELECT CASE(CDAT%CROP(I)%T_CONCEPT(K))
!                  CASE(ONE) ! NO ROOT-GROUNDWATER INTERACTION -- FULL CU
!                      !
!                      TSURF = TPOT
!                      !
!                  CASE(202:204)  ! SOLVE WITH CONCEPT 1
!                      !
!                      UXX = CDAT%CROP(I)%UXX(K)
!                      MXX = CDAT%CROP(I)%MXX(K)
!                      TPOT_ROOT =            TPOT / CDAT%CROP(I)%ROOT(K)
!                      !
!                      IF    (HH >= UXX ) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!  --LATTER ADD CORRECTION FOR PLANTS THAT DROWNING LIKE RICE/WILLIOWS
!                             !
!                             TGWA = DZ
!                             TSURF = DZ
!                             ANOX_STRESS=TPOT
!                             !
!                      ELSEIF( CDAT%CROP(I)%LXX(K) >= HH ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!                             !
!                             TGWA = DZ
!                             TSURF  = TPOT_ROOT * (UXX-CDAT%CROP(I)%SS(K))      !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
!                             ANOX_STRESS = TPOT - TSURF
!                             !
!                      ELSEIF(UXX  > HH .AND. HH > MXX) THEN !FULL UPTAKE/ANOXI Zone
!                            !
!                            THI = TPOT_ROOT * UXX   !TGWA = THI - THD*H = (TPOT/ROOT)*(UXX - H)
!                            THD = TPOT_ROOT      
!                            !
!                            TGWA=THI-THD*HH                                           !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)
!                            TSURF=DZ                                            !       Tgw-act = Tc-act
!                            ANOX_STRESS = TPOT - TGWA
!                            !
!                      ELSEIF(MXX >= HH .AND. HH >= CDAT%CROP(I)%SS(K)) THEN
!                            !
!                            THI = TPOT_ROOT*(UXX-MXX)
!                            !
!                            TGWA = THI                                            !TACT = Tgw-act = Tgw-act-max < Tc-pot
!                            TSURF = TPOT_ROOT*(UXX- HH) - TGWA                     !       Tgw-act < Tc-act (Tc-act varies linearly)
!                            ANOX_STRESS = TPOT - TSURF - TGWA
!                            !
!                      ELSEIF(CDAT%CROP(I)%SS(K) > HH .AND. HH > CDAT%CROP(I)%LXX(K)) THEN
!                            !
!                            PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                            !
!                            THI=     TPOT_ROOT * (UXX-MXX) * (UNO - CDAT%CROP(I)%SS(K)/PSIA)         !
!                            THD=DNEG*TPOT_ROOT * (UXX-MXX) / PSIA                                    !IF NONLINEAR: THI & THD SEPARATION COULD BE SKIPPED:
!                            !
!                            TGWA = THI-THD*HH                                                   !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)        !TACT=TMAX*(1-SS/PSIA+HH/PSIA)**2
!                            TSURF = TPOT_ROOT * (UXX-CDAT%CROP(I)%SS(K)) - TGWA                            !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
!                            ANOX_STRESS = TPOT - TSURF - TGWA
!                            !
!                      ENDIF
!                      !-------------------------------------------------------------------------------------------------------------------------------------------------------
!                      ! EVALUATE ADDITIONAL TRANSPIRATION FROM PLANTS THAT CAN TAKE DROWNING
!                      IF( CDAT%CROP(I)%PSI(ONE) > NEARZERO_12 .AND. CDAT%CROP(I)%PSI(TWO) >= DZ ) THEN
!                          !
!                          !
!                          PSI0 = CDAT%CROP(I)%PSI(ONE)
!                          PSI1 = CDAT%CROP(I)%PSI(TWO)
!                          !
!                          PSI0_PSI1 = PSI0-PSI1
!                          IF(PSI0_PSI1 < NEARZERO_12) PSI0_PSI1 = NEARZERO_12
!                          !
!                          !9E2----EVALUATE ACTUAL TRANSPIRATION (FULL UPTAKE) FROM THE SATURATED ROOT ZONE (TGWSAT1)
!                          IF( MAX(CDAT%CROP(I)%SS(K), HH-PSI1) > MIN(GSE, HH) ) THEN
!                                                          CONTINUE !TGWSAT1=DZ   --DO NOTHING
!                          ELSEIF(HH > GSE) THEN !, THD_SAT
!                                                IF(CDAT%CROP(I)%SS(K) >= HH-PSI1 )THEN
!                                                          THI_SAT = TPOT   ! = TGWSAT1 RHSS=RHSS+TGWSAT1
!                                                          !
!                                                          THI = THI_SAT
!                                                          !
!                                                          TGWA = THI  !THI_SAT
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=DZ
!                                                ELSE!IF(HH-PSI1 > CDAT%CROP(I)%SS(K))THEN
!                                                          THI_SAT = TPOT_ROOT*(GSE+PSI1)
!                                                          THD_SAT = TPOT_ROOT
!                                                          !                                                                   
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                END IF
!                          ELSE!IF(GSE > HH) ==> HH < GSE
!                                                IF(CDAT%CROP(I)%SS(K) >= HH-PSI1)THEN
!                                                          THI_SAT = DNEG * TPOT_ROOT * CDAT%CROP(I)%SS(K)  !(TPOT/TRZ)*(TRZ-GSE))
!                                                          THD_SAT = DNEG * TPOT_ROOT
!                                                          !
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH 
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                ELSE!IF(HH-PSI1 > CDAT%CROP(I)%SS(K))THEN
!                                                          THI_SAT = TPOT_ROOT*PSI1
!                                                          !
!                                                          THI = THI + THI_SAT
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT  !RHSS=RHSS+THISAT1
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                ENDIF
!                          END IF
!                          !
!                          !9E3----EVALUATE ACTUAL TRANSPIRATION (PARTIAL UPTAKE) FROM SATURATED ROOT ZONE (TGWSAT2)
!                          IF(MAX(HH-PSI0, CDAT%CROP(I)%SS(K)) > MIN(HH-PSI1, GSE) ) THEN
!                                                          CONTINUE !TGWSAT2=DZ   --DO NOTHING
!                          ELSEIF(GSE > HH-PSI1) THEN
!                                                     IF(HH-PSI0 >= CDAT%CROP(I)%SS(K))THEN
!                                                          THI_SAT = TPOT_ROOT * PSI0_PSI1 / DOS
!                                                          !
!                                                          THI = THI + THI_SAT                                    !RHSS=RHSS+THISAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT 
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                     ELSE
!                                                          ALPHA= HALF + (PSI0-HH+CDAT%CROP(I)%SS(K))/(DOS*PSI0_PSI1)
!                                                          THI_SAT = DNEG*TPOT_ROOT*ALPHA*(CDAT%CROP(I)%SS(K)+PSI1)
!                                                          THD_SAT = DNEG*TPOT_ROOT*ALPHA
!                                                          !
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                     ENDIF
!                          ELSE!IF(HH-PSI1 > GSE) THEN
!                                                     IF(HH-PSI0 > CDAT%CROP(I)%SS(K)) THEN
!                                                          ALPHA=(GSE-HH+PSI0) / (DOS*PSI0_PSI1)
!                                                          THI_SAT = TPOT_ROOT*ALPHA*(GSE+PSI0)
!                                                          THD_SAT = TPOT_ROOT*ALPHA
!                                                          !
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH    !TGWSAT2=THISAT2-THDSAT2*HH
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                     ELSE
!                                                          !THI_SAT = TPOT_ROOT * (DOS*PSI0 - CDAT%CROP(I)%ROOT(K)) / (DOS * PSI0_PSI1)  !GSE+SS = -ROOT   --SS = GSE - ROOT  fixed summation
!                                                          !THD_SAT = TPOT_ROOT / PSI0_PSI1
!                                                          THI_SAT = (DOS*PSI0 + GSE + CDAT%CROP(I)%SS(K)) * TPOT / (DOS * PSI0_PSI1)
!                                                          THD_SAT = TPOT / PSI0_PSI1
!                                                          !
!                                                          THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!                                                          THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!                                                          !
!                                                          TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH     !TGWSAT2=THISAT2-THDSAT2*HH
!                                                          TSURF=DZ
!                                                          ANOX_STRESS=TPOT-TGWA
!                                                     END IF
!                          END IF
!                      END IF
!                      !
!                  CASE(102:104)  !SOLVE WITH CONCEPT 2  --CODE IDENTICAL TOO "SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)"
!                      !
!                      IF(CDAT%HAS_POND) THEN
!                          GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
!                          ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
!                      ELSE
!                          GSE_POND = GSE
!                          ROOT_POND= CDAT%CROP(I)%ROOT(K)
!                      END IF
!                      !
!                      IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
!                             !
!                             TGWA = DZ
!                             TSURF  = DZ
!                             ANOX_STRESS=TPOT
!                             !
!                      ELSEIF(HH >= CDAT%CROP(I)%SS(K) ) THEN
!                             !
!                             THI = TPOT * GSE_POND / ROOT_POND
!                             THD = TPOT / ROOT_POND
!                             !
!                             TGWA = THI-THD*HH 
!                             TSURF  = DZ
!                             ANOX_STRESS=TPOT-TGWA
!                             !
!                      ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!                             !
!                             TGWA = DZ
!                             TSURF  = TPOT
!                             ANOX_STRESS=DZ
!                             !
!                      ELSE
!                             PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                             !
!                             THI = TPOT - (TPOT*CDAT%CROP(I)%SS(K)/PSIA) !TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
!                             THD = DNEG*TPOT / PSIA
!                             !
!                             TGWA = THI-THD*HH 
!                             TSURF  = TPOT - TGWA
!                             ANOX_STRESS=DZ
!                      END IF
!                      !
!                  END SELECT  T_CALC
!                  !
!                  !########################################################################################
!                  !
!                  ! 0 = No T/No CU
!                  ! 1 = No GW Interaction/Full CU from Surf/No  Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
!                  ! 2 = No GW Uptake/ HAS Anoxia/Soil Stress Reducation, No  Root-Groundwater Uptake  
!                  ! 3 = No Anoxia - But has GW Uptake
!                  ! 4 = Full Interaction HAS Anoxia/Soil Stress Reducation, HAS Root-Groundwater Uptake  
!                  !
!                  IF(CDAT%CROP(I)%GW_INTER(K) == TWO) THEN !NO GROUNDWATER UPTAKE
!                                                 TSURF = TSURF + TGWA
!                                                 TGWA  = DZ
!                                                 THI   = DZ
!                                                 THD   = DZ
!                  ELSEIF(CDAT%CROP(I)%GW_INTER(K) == THREE .AND. ANOX_STRESS>DZ) THEN
!                      IF(TSURF > DZ) THEN
!                          TSURF = TSURF + ANOX_STRESS
!                      ELSE
!                          TGWA = TGWA + ANOX_STRESS
!                          THI  = THI  + ANOX_STRESS
!                      END IF
!                  END IF
!                  !
!                  !
!                  IF(TSURF > TPOT) TSURF = TPOT
!                  IF(TGWA  > TPOT) TGWA  = TPOT
!                  IF(TSURF + TGWA > TPOT) THEN
!                      IF(TSURF + TGWA > DZ) THEN
!                          ALPHA = TPOT / (TSURF + TGWA)
!                          TSURF = TSURF * ALPHA
!                          TGWA  = TGWA  * ALPHA
!                      END IF
!                  END IF
!                  IF(ABS(TGWA - (THI - THD*HH) ) > NEARZERO_12) THEN
!                          ALPHA = 1D0
!                  END IF
!                  !
!                  CDAT%CROP(I)%THI(K) = THI
!                  CDAT%CROP(I)%THD(K) = THD
!                  !
!                  CDAT%CROP(I)%TGWA(K)        = TGWA
!                  CDAT%CROP(I)%TSURF(K)       = TSURF
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = ANOX_STRESS
!                  !
!                  IF(CDAT%CROP(I)%ANOXIA_LOSS(K) < NEARZERO_12) CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!                  !
!                  IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF) THEN
!                      !
!                      CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                      !
!                  ELSEIF(TSURF < CDAT%CROP(I)%TPPOT(K) ) THEN
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = TSURF
!                  ELSE
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                  END IF
!           ELSE !HAS_T
!                  CDAT%CROP(I)%THI(K)   = DZ
!                  CDAT%CROP(I)%THD(K)   = DZ
!                  CDAT%CROP(I)%TGWA(K)  = DZ
!                  CDAT%CROP(I)%TSURF(K) = DZ
!                  CDAT%CROP(I)%TI(K)    = DZ
!                  CDAT%CROP(I)%TP(K)    = DZ
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!           END IF HAS_T
!           !
!          END DO
!    END DO
!    !
!  END SUBROUTINE
  !
!!!  SUBROUTINE CONCEPT_ONE_TGW(CDAT, WBS, SOIL)
!!!    !
!!!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!!!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!!!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!!!    !
!!!    INTEGER:: I, K, R, C, L
!!!    DOUBLE PRECISION:: TGWA
!!!    DOUBLE PRECISION:: PSIA, PSI0, PSI1, PSI2, PSI3, PSI3_CM, XDRY, XWET
!!!    DOUBLE PRECISION:: HH, GSE, TPOT, TPOT_ROOT, TPOT_AREA, TSURF, GSE_POND, ROOT_POND
!!!    DOUBLE PRECISION:: PSIDRY, PSIWET, PSIWET_CM, PSIDRY_CM, PSI0_PSI1
!!!    DOUBLE PRECISION:: UXX, MXX, DRZ, NEXP, THI, THD, THI_SAT, THD_SAT, ALPHA
!!!    LOGICAL:: HAS_NONZERO_PSI, HAS_TRANSPIRATION 
!!!    !
!!!    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
!!!          !
!!!          PSI0 = DZ;  PSI1 = DZ;  PSI2 = DZ;  PSI3 = DZ
!!!          !
!!!          IF( CDAT%CROP(I)%PSI(ONE  ) < DZ )  PSI0 = CDAT%CROP(I)%PSI(ONE  ) * DNEG  !FLIP TO POSITIVE --SAME AS ABSOLUTE VALUE
!!!          IF( CDAT%CROP(I)%PSI(TWO  ) < DZ )  PSI1 = CDAT%CROP(I)%PSI(TWO  ) * DNEG 
!!!          IF( CDAT%CROP(I)%PSI(THREE) < DZ )  PSI2 = CDAT%CROP(I)%PSI(THREE) * DNEG
!!!          IF( CDAT%CROP(I)%PSI(FOUR ) < DZ )  PSI3 = CDAT%CROP(I)%PSI(FOUR ) * DNEG
!!!          !
!!!          HAS_NONZERO_PSI =  ANY( ABS(CDAT%CROP(I)%PSI) > NEARZERO_12 ) !PSI0 > DZ .OR. PSI1 > DZ .OR. PSI2 > DZ .OR. PSI3 > DZ
!!!          !
!!!          PSIWET = (PSI0+PSI1)/DOS    ! EVALUATE PRESSURE HEADS BETWEEN WHICH UPTAKE IS CONSIDERED OPTIMAL
!!!          PSIDRY = (PSI2+PSI3)/DOS
!!!          !
!!!          PSI3_CM   = PSI3  *CDAT%MLT
!!!          PSIWET_CM = PSIWET*CDAT%MLT
!!!          PSIDRY_CM = PSIDRY*CDAT%MLT
!!!          !
!!!          DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
!!!              !
!!!              R = CDAT%CROP(I)%RC(ONE,K)
!!!              C = CDAT%CROP(I)%RC(TWO,K)
!!!              L = UPLAY(C,R)
!!!              !
!!!              THI = DZ
!!!              THD = DZ
!!!              TGWA = DZ
!!!              TSURF = DZ
!!!              !
!!!              UXX = CDAT%CROP(I)%GSE(K)
!!!              MXX = CDAT%CROP(I)%SS(K)
!!!              !
!!!              TPOT = CDAT%CROP(I)%TGW(K)
!!!              IF(TPOT < NEARZERO_12) TPOT = DZ
!!!              !
!!!              HAS_TRANSPIRATION = TPOT > NEARZERO_12 .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. L > Z
!!!              !
!!!              !########################################################################################
!!!              !
!!!      T_CALC: IF(CDAT%CROP(I)%GW_INTER(K) == Z) THEN  ! NO ROOT-GROUNDWATER INTERACTION
!!!                  !
!!!                  TSURF = TPOT
!!!                  !
!!!              ELSEIF( HAS_TRANSPIRATION .AND. HAS_NONZERO_PSI ) THEN   ! SOLVE WITH CONCEPT 1
!!!                  !
!!!                  HH  = CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!!!                  GSE = CDAT%CROP(I)%GSE(K)
!!!                  !
!!!                  !6B1C---CONVERT FLOWRATE OF ORIGINAL MAXIMUM TRANSPIRATION BACK TO FLUX (REASON: UXX AND MXX BELOW ARE FUNCTIONS OF T-FLUX NOT T-FLOWRATE; WITH:
!!!                  !        UXX =    Head Elevation of Upper Extinction of Transpiration due to Anoxia
!!!                  !        MXX =    Head Elevation of Elimination of crop-unproductive Wilting Zone)
!!!                  !
!!!                  TPOT_ROOT =            TPOT / CDAT%CROP(I)%ROOT(K)
!!!                  TPOT_AREA = CDAT%MLT * TPOT / CDAT%CROP(I)%AREA(K)  !NOTE THIS IS A RATE RATHER THAN VOLUMETRIC RATE  --CONVERTED TO CM/T
!!!                  !
!!!                  DRZ =  SOIL%COEF(C,R)%A*LOG(CDAT%CROP(I)%ROOT(K)*CDAT%MLT) + SOIL%COEF(C,R)%B*LOG(TPOT_AREA) + SOIL%COEF(C,R)%C  !TAKE EXP AFTER USED FOR NEXP CALCULATION
!!!                  NEXP = SOIL%COEF(C,R)%D*DRZ + SOIL%COEF(C,R)%E
!!!                  DRZ  = EXP(DRZ)
!!!                  !
!!!                  IF(DRZ  > PSI3_CM)     DRZ  = PSI3_CM
!!!                  IF(NEXP < NEARZERO_12) NEXP = NEARZERO_12
!!!                  !
!!!                  IF(PSIWET < NEARZERO_12) THEN
!!!                       XWET = DZ
!!!                  ELSE
!!!                       !     
!!!                       !6B1G---SOLVE ANALYTICAL FUNCTION FOR DEPTHS BETWEEN WHICH UPTAKE IS OPTIMAL:
!!!                       !       ANALYTICAL FUNCTION: PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH)
!!!                       !                            PSI(DEPTH)   IS SOLVED ITERATIVELY BY BISECTION-METHOD
!!!                       !                                         FOR DEPTH(PSIWET) AND FOR DEPTH(PSIDRY)
!!!                       XWET = RTFUNC(DRZ,PSI3_CM,NEXP,PSIWET_CM) / CDAT%MLT
!!!                       !
!!!                       IF(XWET.NE.XWET) THEN
!!!                           !WRITE(CDAT%LOUT,'(/A/,A/,6A)') 'FMP CROP WARNING. SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XWET = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).', &
!!!                           !                               'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF UPPER EXTINCTION OF TRANSPIRATION DUE TO ANOXIA IS ASSUMED TO BE THE GROUND SURFACE.', &
!!!                           !                               'THIS PROBLEM OCCURED FOR CROP ',NUM2STR(I),' LOCATED IN ROW, COL: ', NUM2STR(R), ', ', NUM2STR(C)
!!!                           CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP: SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XWET = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).'//NL// &
!!!                                                                     'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF UPPER EXTINCTION OF TRANSPIRATION DUE TO ANOXIA IS ASSUMED TO BE THE GROUND SURFACE.'//NL// &
!!!                                                                     'THIS PROBLEM OCCURED FOR CROP '//NUM2STR(I)//NL//' LOCATED IN ROW, COL: '//NUM2STR(R)//', '//NUM2STR(C), INLINE=TRUE)
!!!                           XWET = DZ
!!!                       ELSEIF(XWET < DZ)  THEN
!!!                           XWET = DZ
!!!                       END IF
!!!                       !
!!!                  ENDIF
!!!                  !
!!!                  IF    (XWET < NEARZERO_12 ) THEN
!!!                                             UXX = GSE
!!!                  ELSEIF(XWET > CDAT%CROP(I)%ROOT(K) ) THEN
!!!                                             UXX = CDAT%CROP(I)%SS(K)
!!!                  ELSEIF(XWET > PSIWET) THEN
!!!                                             UXX = GSE - PSIWET
!!!                  ELSE
!!!                                             UXX = GSE - XWET
!!!                  END IF
!!!                  !
!!!                  IF    (HH >= UXX ) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!  --LATTER ADD CORRECTION FOR PLANTS THAT DROWNING LIKE RICE/WILLIOWS
!!!                         !
!!!                         TGWA = DZ
!!!                         TSURF = DZ
!!!                         !
!!!                  ELSEIF( CDAT%CROP(I)%LXX(K) >= HH ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!!!                         !
!!!                         TGWA = DZ
!!!                         TSURF  = TPOT_ROOT * (UXX-CDAT%CROP(I)%SS(K))      !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
!!!                         !
!!!                  ELSE ! HAVE TO CALCULATE XDRY FOR FUTHER CHECKS.
!!!                         !
!!!                         IF(HAS_NONZERO_PSI) THEN
!!!                               !
!!!                               XDRY = RTFUNC(DRZ,PSI3_CM,NEXP,PSIDRY_CM) / CDAT%MLT
!!!                               !
!!!                               IF(XDRY.NE.XDRY) THEN
!!!                                   !WRITE(CDAT%LOUT,'(/A/,A/,6A)') 'FMP CROP WARNING. SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XDRY = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).', &
!!!                                   !                               'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF ELIMINATION OF CROP-UNPRODUCTIVE WILTING ZONE IS ASSUMED TO BE THE AT THE BOTTOM OF THE ROOT ZONE.', &
!!!                                   !                               'THIS PROBLEM OCCURED FOR CROP ',NUM2STR(I),' LOCATED IN ROW, COL: ', NUM2STR(R), ', ', NUM2STR(C)
!!!                                   CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP: SOLVING ANALYITICAL WATER STRESS RESPONSE FUNCTION, XDRY = PSI(DEPTH) = FUNCTION (DRZ,NEXP,PSI3,DEPTH), WITH BISECTION METHOD FAILED TO IDENTIFY INITIAL GUESS (d1 and d2) THAT ARE ON BOTH SIDES OF THE ROOT. (viz. PSI(d1)*PSI(d2)>0).'//NL// &
!!!                                                                     'TO KEEP PROGRAM FROM STOPPING THE SOLUTION THE HEAD ELEVATION OF ELIMINATION OF CROP-UNPRODUCTIVE WILTING ZONE IS ASSUMED TO BE THE AT THE BOTTOM OF THE ROOT ZONE.'//NL// &
!!!                                                                     'THIS PROBLEM OCCURED FOR CROP '//NUM2STR(I)//NL//' LOCATED IN ROW, COL: '//NUM2STR(R)//', '//NUM2STR(C), INLINE=TRUE)
!!!                                   XDRY = CDAT%CROP(I)%ROOT(K)
!!!                               END IF
!!!                         ELSE
!!!                               XDRY = CDAT%CROP(I)%ROOT(K) !USING CONCEPT TWO BECAUSE ALL PSI ARE SET TO ZERO
!!!                         END IF
!!!                         !
!!!                         IF(XDRY >= CDAT%CROP(I)%ROOT(K)) THEN
!!!                             MXX = CDAT%CROP(I)%SS(K)
!!!                         ELSE
!!!                             MXX = GSE - XDRY      
!!!                         END IF
!!!                         !
!!!                         IF(MXX > UXX) MXX = UXX
!!!                         !
!!!                         IF(UXX  > HH .AND. HH > MXX) THEN
!!!                               !
!!!                               THI = TPOT_ROOT * UXX   !TGWA = THI - THD*H = (TPOT/ROOT)*(UXX - H)
!!!                               THD = TPOT_ROOT      
!!!                               !
!!!                               TGWA=THI-THD*HH                                           !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)
!!!                               TSURF=DZ                                            !       Tgw-act = Tc-act
!!!                               !
!!!                         ELSEIF(MXX >= HH .AND. HH >= CDAT%CROP(I)%SS(K)) THEN
!!!                               !
!!!                               THI = TPOT_ROOT*(UXX-MXX)
!!!                               !
!!!                               TGWA = THI                                            !TACT = Tgw-act = Tgw-act-max < Tc-pot
!!!                               TSURF = TPOT_ROOT*(UXX- HH) - TGWA                     !       Tgw-act < Tc-act (Tc-act varies linearly)
!!!                               !
!!!                         ELSEIF(CDAT%CROP(I)%SS(K) > HH .AND. HH > CDAT%CROP(I)%LXX(K)) THEN
!!!                               !
!!!                               PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!!!                               !
!!!                               THI=     TPOT_ROOT * (UXX-MXX) * (UNO - CDAT%CROP(I)%SS(K)/PSIA)         !
!!!                               THD=DNEG*TPOT_ROOT * (UXX-MXX) / PSIA                                    !IF NONLINEAR: THI & THD SEPARATION COULD BE SKIPPED:
!!!                               !
!!!                               TGWA = THI-THD*HH                                                   !TACT = Tgw-act < Tgw-act-max < Tc-pot (Tgw-act varies linearly)        !TACT=TMAX*(1-SS/PSIA+HH/PSIA)**2
!!!                               TSURF = TPOT_ROOT * (UXX-CDAT%CROP(I)%SS(K)) - TGWA                            !       Tgw-act < Tc-act = Tc-act-max = (TPOT/TRZ)*(UXX-SS) < Tc-pot
!!!                               !
!!!                         ENDIF
!!!                  END IF
!!!                  !-------------------------------------------------------------------------------------------------------------------------------------------------------
!!!                  ! EVALUATE ADDITIONAL TRANSPIRATION FROM PLANTS THAT CAN TAKE DROWNING
!!!                  IF( CDAT%CROP(I)%PSI(ONE) > NEARZERO_12 .AND. CDAT%CROP(I)%PSI(TWO) >= DZ ) THEN
!!!                      !
!!!                      !
!!!                      PSI0 = CDAT%CROP(I)%PSI(ONE)
!!!                      PSI1 = CDAT%CROP(I)%PSI(TWO)
!!!                      !
!!!                      PSI0_PSI1 = PSI0-PSI1
!!!                      IF(PSI0_PSI1 < NEARZERO_12) PSI0_PSI1 = NEARZERO_12
!!!                      !
!!!                      !9E2----EVALUATE ACTUAL TRANSPIRATION (FULL UPTAKE) FROM THE SATURATED ROOT ZONE (TGWSAT1)
!!!                      IF( MAX(CDAT%CROP(I)%SS(K), HH-PSI1) > MIN(GSE, HH) ) THEN
!!!                                                      CONTINUE !TGWSAT1=DZ   --DO NOTHING
!!!                      ELSEIF(HH > GSE) THEN !, THD_SAT
!!!                                            IF(CDAT%CROP(I)%SS(K) >= HH-PSI1 )THEN
!!!                                                      THI_SAT = TPOT   ! = TGWSAT1 RHSS=RHSS+TGWSAT1
!!!                                                      !
!!!                                                      THI = THI_SAT
!!!                                                      !
!!!                                                      TGWA = THI  !THI_SAT
!!!                                            ELSE!IF(HH-PSI1 > CDAT%CROP(I)%SS(K))THEN
!!!                                                      THI_SAT = TPOT_ROOT*(GSE+PSI1)
!!!                                                      THD_SAT = TPOT_ROOT
!!!                                                      !                                                                   
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
!!!                                            END IF
!!!                      ELSE!IF(GSE > HH) ==> HH < GSE
!!!                                            IF(CDAT%CROP(I)%SS(K) >= HH-PSI1)THEN
!!!                                                      THI_SAT = DNEG * TPOT_ROOT * CDAT%CROP(I)%SS(K)  !(TPOT/TRZ)*(TRZ-GSE))
!!!                                                      THD_SAT = DNEG * TPOT_ROOT
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
!!!                                            ELSE!IF(HH-PSI1 > CDAT%CROP(I)%SS(K))THEN
!!!                                                      THI_SAT = TPOT_ROOT*PSI1
!!!                                                      !
!!!                                                      THI = THI + THI_SAT
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT  !RHSS=RHSS+THISAT1
!!!                                            ENDIF
!!!                      END IF
!!!                      !
!!!                      !9E3----EVALUATE ACTUAL TRANSPIRATION (PARTIAL UPTAKE) FROM SATURATED ROOT ZONE (TGWSAT2)
!!!                      IF(MAX(HH-PSI0, CDAT%CROP(I)%SS(K)) > MIN(HH-PSI1, GSE) ) THEN
!!!                                                      CONTINUE !TGWSAT2=DZ   --DO NOTHING
!!!                      ELSEIF(GSE > HH-PSI1) THEN
!!!                                                 IF(HH-PSI0 >= CDAT%CROP(I)%SS(K))THEN
!!!                                                      THI_SAT = TPOT_ROOT * PSI0_PSI1 / DOS
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                    !RHSS=RHSS+THISAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT  
!!!                                                 ELSE
!!!                                                      ALPHA= HALF + (PSI0-HH+CDAT%CROP(I)%SS(K))/(DOS*PSI0_PSI1)
!!!                                                      THI_SAT = DNEG*TPOT_ROOT*ALPHA*(CDAT%CROP(I)%SS(K)+PSI1)
!!!                                                      THD_SAT = DNEG*TPOT_ROOT*ALPHA
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH  
!!!                                                 ENDIF
!!!                      ELSE!IF(HH-PSI1 > GSE) THEN
!!!                                                 IF(HH-PSI0 > CDAT%CROP(I)%SS(K)) THEN
!!!                                                      ALPHA=(GSE-HH+PSI0) / (DOS*PSI0_PSI1)
!!!                                                      THI_SAT = TPOT_ROOT*ALPHA*(GSE+PSI0)
!!!                                                      THD_SAT = TPOT_ROOT*ALPHA
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH    !TGWSAT2=THISAT2-THDSAT2*HH
!!!                                                 ELSE
!!!                                                      !THI_SAT = TPOT_ROOT * (DOS*PSI0 - CDAT%CROP(I)%ROOT(K)) / (DOS * PSI0_PSI1)  !GSE+SS = -ROOT   --SS = GSE - ROOT  fixed summation
!!!                                                      !THD_SAT = TPOT_ROOT / PSI0_PSI1
!!!                                                      THI_SAT = (DOS*PSI0 + GSE + CDAT%CROP(I)%SS(K)) * TPOT / (DOS * PSI0_PSI1)
!!!                                                      THD_SAT = TPOT / PSI0_PSI1
!!!                                                      !
!!!                                                      THI = THI + THI_SAT                                                 !RHSS=RHSS+THISAT1
!!!                                                      THD = THD + THD_SAT                                                 !HCOFF=HCOFF+THDSAT1
!!!                                                      !
!!!                                                      TGWA = THI - THD*HH  !TGWA + THI_SAT - THD_SAT*HH     !TGWSAT2=THISAT2-THDSAT2*HH
!!!                                                 END IF
!!!                      END IF
!!!                  END IF
!!!                  !
!!!              ELSEIF( HAS_TRANSPIRATION .AND. .NOT. HAS_NONZERO_PSI) THEN  !SOLVE WITH CONCEPT 2  --CODE IDENTICAL TOO "SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)"
!!!                  !
!!!                  HH  = CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!!!                  GSE = CDAT%CROP(I)%GSE(K)
!!!                  !
!!!                  IF(CDAT%HAS_POND) THEN
!!!                      GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
!!!                      ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
!!!                  ELSE
!!!                      GSE_POND = GSE
!!!                      ROOT_POND= CDAT%CROP(I)%ROOT(K)
!!!                  END IF
!!!                  !
!!!                  IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
!!!                         !
!!!                         TGWA = DZ
!!!                         TSURF  = DZ
!!!                         !
!!!                  ELSEIF(HH >= CDAT%CROP(I)%SS(K) ) THEN
!!!                         !
!!!                         THI = TPOT * GSE_POND / ROOT_POND
!!!                         THD = TPOT / ROOT_POND
!!!                         !
!!!                         TGWA = THI-THD*HH 
!!!                         TSURF  = DZ
!!!                         !
!!!                  ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!!!                         !
!!!                         TGWA = DZ
!!!                         TSURF  = TPOT
!!!                         !
!!!                  ELSE
!!!                         PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!!!                         !
!!!                         THI =      TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
!!!                         THD = DNEG*TPOT / PSIA
!!!                         !
!!!                         TGWA = THI-THD*HH 
!!!                         TSURF  = TPOT - TGWA
!!!                  END IF
!!!              END IF  T_CALC
!!!              !
!!!              !########################################################################################
!!!              !
!!!              IF(HAS_TRANSPIRATION .AND. CDAT%CROP(I)%GW_INTER(K) == ONE) THEN !NO GROUNDWATER UPTAKE
!!!                                                 TSURF = TSURF + TGWA
!!!                                                 TGWA  = DZ
!!!                                                 THI   = DZ
!!!                                                 THD   = DZ
!!!              END IF
!!!              !
!!!              IF(HAS_TRANSPIRATION) THEN
!!!                  !
!!!                  IF(TSURF > TPOT) TSURF = TPOT
!!!                  IF(TGWA  > TPOT) TGWA  = TPOT
!!!                  IF(TSURF + TGWA > TPOT) THEN
!!!                      IF(TSURF + TGWA > DZ) THEN
!!!                          ALPHA = TPOT / (TSURF + TGWA)
!!!                          TSURF = TSURF * ALPHA
!!!                          TGWA  = TGWA  * ALPHA
!!!                      END IF
!!!                  END IF
!!!                  !
!!!                  !
!!!                  CDAT%CROP(I)%THI(K) = THI
!!!                  CDAT%CROP(I)%THD(K) = THD
!!!                  !
!!!                  !
!!!                  CDAT%CROP(I)%TGWA(K)        = TGWA
!!!                  CDAT%CROP(I)%TSURF(K)       = TSURF
!!!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = TPOT - TSURF - TGWA
!!!                  !
!!!                  IF(CDAT%CROP(I)%ANOXIA_LOSS(K) < NEARZERO_12) CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!!!                  !
!!!                  IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF) THEN
!!!                      !
!!!                      CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
!!!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!!!              IF(TSURF - CDAT%CROP(I)%TPPOT(K)<DZ) THEN
!!!                  UXX=CDAT%CROP(I)%TPPOT(K)
!!!                  PAUSE
!!!              END IF
!!!                      !
!!!                  ELSEIF(TSURF < CDAT%CROP(I)%TPPOT(K) ) THEN
!!!                      CDAT%CROP(I)%TI(K) = DZ
!!!                      CDAT%CROP(I)%TP(K) = TSURF
!!!                  ELSE
!!!                      CDAT%CROP(I)%TI(K) = DZ
!!!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!!!                  END IF
!!!              ELSE
!!!                  CDAT%CROP(I)%THI(K)   = DZ
!!!                  CDAT%CROP(I)%THD(K)   = DZ
!!!                  CDAT%CROP(I)%TGWA(K)  = DZ
!!!                  CDAT%CROP(I)%TSURF(K) = DZ
!!!                  CDAT%CROP(I)%TI(K)    = DZ
!!!                  CDAT%CROP(I)%TP(K)    = DZ
!!!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!!!              END IF
!!!              !
!!!              CDAT%CROP(I)%UXX(K) = UXX 
!!!              CDAT%CROP(I)%MXX(K) = MXX 
!!!              !
!!!          END DO
!!!    END DO
!!!    !
!!!  END SUBROUTINE
  !
!  SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    !
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: HH, GSE, PSIA, TPOT, TSURF, TGWA, ROOT_POND, GSE_POND, ALPHA
!    DOUBLE PRECISION:: THI, THD
!    LOGICAL:: HAS_TRANSPIRATION, HAS_TSURF
!    !
!    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
!          !
!          DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
!              !
!              R = CDAT%CROP(I)%RC(ONE,K)
!              C = CDAT%CROP(I)%RC(TWO,K)
!              L = UPLAY(C,R)
!              !
!              THI = DZ
!              THD = DZ
!              TSURF = DZ
!              TPOT = CDAT%CROP(I)%TGW(K)
!              TGWA = DZ
!              !
!              HAS_TRANSPIRATION = TPOT > NEARZERO_12 .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. L > Z
!              !
!      T_CALC: IF(CDAT%CROP(I)%GW_INTER(K) == Z .AND. HAS_TRANSPIRATION) THEN  ! NO ROOT-GROUNDWATER INTERACTION -----
!                  !
!                  TSURF = TPOT
!                  !
!      ELSEIF(HAS_TRANSPIRATION) THEN  ! L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  !
!                  !HO  = HNEW_OLD(C,R,L)
!                  !HH  = HNEW(C,R,L)
!                  !DEL = HNEW(C,R,L) - HO
!                  !HH  = HO + 0.9D0*(HNEW(C,R,L) - HO)
!                  HH  = HNEW(C,R,L) !CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!                  !
!                  GSE = CDAT%CROP(I)%GSE(K)
!                  !
!                  IF(CDAT%HAS_POND) THEN
!                      GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
!                      ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
!                  ELSE
!                      GSE_POND = GSE
!                      ROOT_POND= CDAT%CROP(I)%ROOT(K)
!                  END IF
!                  !
!                  IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
!                         !
!                         TGWA = DZ
!                         !TSURF  = DZ
!                         HAS_TSURF = FALSE
!                         !
!                  ELSEIF(HH >= CDAT%CROP(I)%SS(K) ) THEN
!                         !
!                         THI = TPOT * GSE_POND / ROOT_POND
!                         THD = TPOT / ROOT_POND
!                         !
!                         TGWA = THI-THD*HH 
!                         !TSURF  = DZ
!                         HAS_TSURF = FALSE
!                         !
!                  ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!                         !
!                         TGWA = DZ
!                         !TSURF  = TPOT
!                         HAS_TSURF = TRUE
!                         !
!                  ELSE
!                         PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                         !
!                         THI = TPOT - (TPOT*CDAT%CROP(I)%SS(K)/PSIA) !TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
!                         THD = DNEG*TPOT / PSIA
!                         !
!                         TGWA = THI-THD*HH 
!                         !TSURF  = TPOT - TGWA
!                         HAS_TSURF = TRUE
!                  END IF
!                  !
!                  IF(CDAT%CROP(I)%GW_INTER(K) == ONE) THEN !NO GROUNDWATER UPTAKE
!                                                     TSURF = TSURF + TGWA
!                                                     TGWA = DZ
!                                                     THI                  = DZ
!                                                     THD                  = DZ
!                  END IF
!              END IF T_CALC !--------------------------------------------------------------------------
!              !
!              IF(HAS_TRANSPIRATION) THEN
!                  !
!                  !IF(TSURF > TPOT) TSURF = TPOT
!                  !IF(TGWA  > TPOT) TGWA  = TPOT
!                  !IF(TSURF + TGWA > TPOT) THEN
!                  !    IF(TSURF + TGWA > DZ) THEN
!                  !        ALPHA = TPOT / (TSURF + TGWA)
!                  !        TSURF = TSURF * ALPHA
!                  !        TGWA  = TGWA  * ALPHA
!                  !    END IF
!                  !END IF
!                  !
!                  CDAT%CROP(I)%THI(K) = RELAXER(THI, CDAT%CROP(I)%THI(K), CDAT%RELAX) ! THI
!                  CDAT%CROP(I)%THD(K) = RELAXER(THD, CDAT%CROP(I)%THD(K), CDAT%RELAX) ! THD
!                  !
!                  CDAT%CROP(I)%TGWA(K)        = RELAXER(TGWA, CDAT%CROP(I)%TGWA(K), CDAT%RELAX) !TGWA
!                  TGWA = CDAT%CROP(I)%TGWA(K)
!                  IF(HAS_TSURF) THEN
!                                    TSURF = TPOT - CDAT%CROP(I)%TGWA(K)
!                  ELSE
!                                    TSURF = DZ
!                  END IF
!                  CDAT%CROP(I)%TSURF(K) = TSURF
!                  !
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = TPOT - TSURF - TGWA
!                  !
!                  IF(CDAT%CROP(I)%ANOXIA_LOSS(K) < NEARZERO_12) CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!                  !
!                  IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF ) THEN
!                      !
!                      CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                      !
!                  ELSEIF(TSURF < CDAT%CROP(I)%TPPOT(K) ) THEN
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = TSURF
!                  ELSE
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                  END IF
!              ELSE
!                  CDAT%CROP(I)%THI(K)   = DZ
!                  CDAT%CROP(I)%THD(K)   = DZ
!                  CDAT%CROP(I)%TGWA(K)  = DZ
!                  CDAT%CROP(I)%TSURF(K) = DZ
!                  CDAT%CROP(I)%TI(K)    = DZ
!                  CDAT%CROP(I)%TP(K)    = DZ
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!              END IF
!          END DO
!    END DO
!    !
!    END SUBROUTINE
  !
!  SUBROUTINE CONCEPT_TWO_TGW(CDAT, WBS, SOIL)
!    !
!    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
!    TYPE(  WBS_DATA), INTENT(IN   ):: WBS
!    TYPE( SOIL_DATA), INTENT(IN   ):: SOIL
!    !
!    INTEGER:: I, K, R, C, L
!    DOUBLE PRECISION:: HH, GSE, PSIA, TPOT, TSURF, TGWA, ROOT_POND, GSE_POND, ALPHA
!    DOUBLE PRECISION:: THI, THD
!    LOGICAL:: HAS_TRANSPIRATION 
!    !
!    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
!          !
!          DO CONCURRENT ( K=ONE:CDAT%CROP(I)%N )
!              !
!              R = CDAT%CROP(I)%RC(ONE,K)
!              C = CDAT%CROP(I)%RC(TWO,K)
!              L = UPLAY(C,R)
!              !
!              THI = DZ
!              THD = DZ
!              TSURF = DZ
!              TPOT = CDAT%CROP(I)%TGW(K)
!              TGWA = DZ
!              !
!              HAS_TRANSPIRATION = TPOT > NEARZERO_12 .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. L > Z
!              !
!      T_CALC: IF(CDAT%CROP(I)%GW_INTER(K) == Z .AND. HAS_TRANSPIRATION) THEN  ! NO ROOT-GROUNDWATER INTERACTION -----
!                  !
!                  TSURF = TPOT
!                  !
!      ELSEIF(HAS_TRANSPIRATION) THEN  ! L=0 MEANS THAT ENTIRE MODEL COLUMN HAS IBOUND(C,R,:)==0 SO THERE IS NO WATER TO TRANSPIRE FROM!!!
!                  !
!                  !HO  = HNEW_OLD(C,R,L)
!                  !HH  = HNEW(C,R,L)
!                  !DEL = HNEW(C,R,L) - HO
!                  !HH  = HO + 0.9D0*(HNEW(C,R,L) - HO)
!                  HH  = RELAXER(HNEW(C,R,L), HNEW_OLD(C,R,L), CDAT%RELAX) !CDAT%RELAX*(HNEW(C,R,L) - HNEW_OLD(C,R,L)) + HNEW_OLD(C,R,L)   !HNEW = HOLD + FRAC*(HNEW-HOLD)
!                  !
!                  GSE = CDAT%CROP(I)%GSE(K)
!                  !
!                  IF(CDAT%HAS_POND) THEN
!                      GSE_POND = GSE                  + CDAT%CROP(I)%POND(K)
!                      ROOT_POND= CDAT%CROP(I)%ROOT(K) + CDAT%CROP(I)%POND(K)
!                  ELSE
!                      GSE_POND = GSE
!                      ROOT_POND= CDAT%CROP(I)%ROOT(K)
!                  END IF
!                  !
!                  IF    (HH >= GSE_POND) THEN  !HEAD ABOVE CROP ANOXIA LIMIT...PLANT HAS DROWNED!   --POND=0 WHEN NOT SPECIFIED
!                         !
!                         TGWA = DZ
!                         TSURF  = DZ
!                         !
!                  ELSEIF(HH >= CDAT%CROP(I)%SS(K) ) THEN
!                         !
!                         THI = TPOT * GSE_POND / ROOT_POND
!                         THD = TPOT / ROOT_POND
!                         !
!                         TGWA = THI-THD*HH 
!                         TSURF  = DZ
!                         !
!                  ELSEIF(HH <= CDAT%CROP(I)%LXX(K) ) THEN  !HEAD BELOW LOWER EXTINCTION DEPTH SO NO TGWA (LXX = GSE-ROOT-CAPILARY_FRINGE)
!                         !
!                         TGWA = DZ
!                         TSURF  = TPOT
!                         !
!                  ELSE
!                         PSIA = SOIL%CAPILLARY_FRINGE(C,R)
!                         !
!                         THI = TPOT - (TPOT*CDAT%CROP(I)%SS(K)/PSIA) !TPOT * (UNO - CDAT%CROP(I)%SS(K)/PSIA)
!                         THD = DNEG*TPOT / PSIA
!                         !
!                         TGWA = THI-THD*HH 
!                         TSURF  = TPOT - TGWA
!                  END IF
!                  !
!                  IF(CDAT%CROP(I)%GW_INTER(K) == ONE) THEN !NO GROUNDWATER UPTAKE
!                                                     TSURF = TSURF + TGWA
!                                                     TGWA = DZ
!                                                     THI                  = DZ
!                                                     THD                  = DZ
!                  END IF
!              END IF T_CALC !--------------------------------------------------------------------------
!              !
!              IF(HAS_TRANSPIRATION) THEN
!                  !
!                  IF(TSURF > TPOT) TSURF = TPOT
!                  IF(TGWA  > TPOT) TGWA  = TPOT
!                  IF(TSURF + TGWA > TPOT) THEN
!                      IF(TSURF + TGWA > DZ) THEN
!                          ALPHA = TPOT / (TSURF + TGWA)
!                          TSURF = TSURF * ALPHA
!                          TGWA  = TGWA  * ALPHA
!                      END IF
!                  END IF
!                  !
!                  CDAT%CROP(I)%THI(K) = THI
!                  CDAT%CROP(I)%THD(K) = THD
!                  !
!                  CDAT%CROP(I)%TGWA(K)        = TGWA
!                  CDAT%CROP(I)%TSURF(K)       = TSURF
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = TPOT - TSURF - TGWA
!                  !
!                  IF(CDAT%CROP(I)%ANOXIA_LOSS(K) < NEARZERO_12) CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!                  !
!                  IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%TPPOT(K) < TSURF ) THEN
!                      !
!                      CDAT%CROP(I)%TI(K) = TSURF - CDAT%CROP(I)%TPPOT(K)
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                      !
!                  ELSEIF(TSURF < CDAT%CROP(I)%TPPOT(K) ) THEN
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = TSURF
!                  ELSE
!                      CDAT%CROP(I)%TI(K) = DZ
!                      CDAT%CROP(I)%TP(K) = CDAT%CROP(I)%TPPOT(K)
!                  END IF
!              ELSE
!                  CDAT%CROP(I)%THI(K)   = DZ
!                  CDAT%CROP(I)%THD(K)   = DZ
!                  CDAT%CROP(I)%TGWA(K)  = DZ
!                  CDAT%CROP(I)%TSURF(K) = DZ
!                  CDAT%CROP(I)%TI(K)    = DZ
!                  CDAT%CROP(I)%TP(K)    = DZ
!                  CDAT%CROP(I)%ANOXIA_LOSS(K) = DZ
!              END IF
!          END DO
!    END DO
!    !
!    END SUBROUTINE
  !
  PURE SUBROUTINE CALC_CIR_DEMAND(CDAT, SET_CIR_INI)   !WRAPPER TO CALL NEXT SUBROUTINE
    CLASS(CROP_DATA),  INTENT(INOUT):: CDAT
    LOGICAL,           INTENT(IN   ):: SET_CIR_INI
    INTEGER:: I
    !
    DO I=1, CDAT%NCROP
            CALL CALC_CIR_DEMAND_BY_CROP( CDAT%CROP(I) )
    END DO
    !
    IF(SET_CIR_INI) THEN
           DO I=1, CDAT%NCROP
                IF(CDAT%CROP(I)%N > Z) CDAT%CROP(I)%CIR_INI = CDAT%CROP(I)%CIR
           END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_CIR_DEMAND_BY_CROP(CROP)
    CLASS(CROP_PROP), INTENT(INOUT):: CROP
    INTEGER:: K
    !
    DO K=ONE, CROP%N
        IF( CROP%TI(K) > NEARZERO_12 ) THEN ! PRECIP DOES NOT SATISFY NEEDS          ! remove: CROP%NOT_FALLOW(K) .AND. CROP%IRR(K) > Z .AND. 
            !
            CROP%CIR(K)    = CROP%TI(K) * (UNO + CROP%CECT(K))  !TI = TSUR-TP ==> (TSUR-TP)*(1+ FEI/FTR) --NOTE THAT IF FTR=0 THEN TGW = 0, SO TSUR =0 WHICH IS < TPPOT SO CONDITION FAILS
            CROP%DEMAND(K) = CROP%CIR(K) / CROP%EFF(K)
        ELSE
            CROP%TI(K)     = DZ
            CROP%CIR(K)    = DZ
            CROP%DEMAND(K) = DZ
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE INIT_EXTERNAL_DEMAND(CDAT)
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    INTEGER:: I, K
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP    )
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
          IF( CDAT%CROP(I)%IRR(K) > Z .AND. CDAT%CROP(I)%ADMD(K) > NEARZERO_12 ) THEN
                                      CDAT%CROP(I)%DEMAND_EXT(K) = CDAT%CROP(I)%ADMD(K) / CDAT%CROP(I)%EFF(K)
          ELSE
              CDAT%CROP(I)%DEMAND_EXT(K) = DZ
          END IF
    END DO; END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_EXTERNAL_DEMAND(CDAT,DMD,I,K,F,USE_AREA)
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    DOUBLE PRECISION, INTENT(IN):: DMD
    INTEGER,          INTENT(IN):: I,K,F  !SET TO ZERO TO NOT USE
    LOGICAL,          INTENT(IN):: USE_AREA
    INTEGER:: J,KK
    DOUBLE PRECISION:: AREA
    !
    CDAT%HAS_DEMAND_EXT = TRUE
    AREA = UNO
    J=NEG
    KK=NEG
    !
    IF(F>Z) THEN !SEARCH BY FARM
        !
        IF(I<ONE .AND. K<ONE) THEN  !ALL CROP IN FARM F
            DO CONCURRENT (J=ONE:CDAT%NCROP)
            DO CONCURRENT (KK=ONE:CDAT%CROP(J)%N, CDAT%CROP(J)%FID(KK) == F .AND. CDAT%CROP(J)%IRR(KK) > Z )
                                              IF(USE_AREA) AREA = CDAT%CROP(J)%AREA(KK)
                                              CDAT%CROP(J)%DEMAND_EXT(KK) = CDAT%CROP(J)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(J)%EFF(KK)
            END DO; END DO
        ELSEIF(I>Z .AND. K<ONE) THEN !ALL CROP I IN FARM F
            DO CONCURRENT ( KK=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%FID(KK) == F .AND. CDAT%CROP(I)%IRR(KK) > Z )
                                              IF(USE_AREA) AREA = CDAT%CROP(I)%AREA(KK)
                                              CDAT%CROP(I)%DEMAND_EXT(KK) = CDAT%CROP(I)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(I)%EFF(KK)
            END DO
        ELSEIF(I<ONE .AND. K>Z) THEN !ALL CROP IN FARM F AT Kth POSITION
            DO CONCURRENT ( J=ONE:CDAT%NCROP, CDAT%CROP(J)%FID(KK) == F .AND. CDAT%CROP(J)%IRR(KK) > Z )
                                              IF(USE_AREA) AREA = CDAT%CROP(J)%AREA(KK)
                                              CDAT%CROP(J)%DEMAND_EXT(KK) = CDAT%CROP(J)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(J)%EFF(KK)
            END DO
        ELSEIF(CDAT%CROP(I)%FID(K) == F .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
            IF(USE_AREA) AREA = CDAT%CROP(I)%AREA(K)
            CDAT%CROP(I)%DEMAND_EXT(K) = CDAT%CROP(I)%DEMAND_EXT(K) + DMD*AREA/CDAT%CROP(I)%EFF(K)
        END IF
        !
    ELSEIF(K>Z) THEN  !SEARCH BY Kth POSITION
        !
        IF(I>Z) THEN  !SPECIFY I AND K
            IF(USE_AREA) AREA = CDAT%CROP(I)%AREA(K)
            IF(CDAT%CROP(I)%IRR(K) > Z) CDAT%CROP(I)%DEMAND_EXT(K) = CDAT%CROP(I)%DEMAND_EXT(K) + DMD*AREA/CDAT%CROP(I)%EFF(K)
        ELSE          !SPECIFY K ONLY
            DO CONCURRENT ( J=ONE:CDAT%NCROP, CDAT%CROP(J)%IRR(K) > Z)
                                              IF(USE_AREA) AREA = CDAT%CROP(J)%AREA(K)
                                              CDAT%CROP(J)%DEMAND_EXT(K) = CDAT%CROP(J)%DEMAND_EXT(K) + DMD*AREA/CDAT%CROP(J)%EFF(K)
            END DO
        END IF
        !
    ELSEIF(I>Z) THEN !SEARCH BY CROP
            DO CONCURRENT ( KK=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(KK) > Z)
                                              IF(USE_AREA) AREA = CDAT%CROP(I)%AREA(KK)
                                              CDAT%CROP(I)%DEMAND_EXT(KK) = CDAT%CROP(I)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(I)%EFF(KK)
            END DO
    ELSE !ALL ZERO
            DO CONCURRENT (J=ONE:CDAT%NCROP)
            DO CONCURRENT (KK=ONE:CDAT%CROP(J)%N, CDAT%CROP(J)%IRR(KK) > Z)
                                              IF(USE_AREA) AREA = CDAT%CROP(J)%AREA(KK)
                                              CDAT%CROP(J)%DEMAND_EXT(KK) = CDAT%CROP(J)%DEMAND_EXT(KK) + DMD*AREA/CDAT%CROP(J)%EFF(KK)
            END DO; END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_WBS_ADDED_DEMAND(CDAT,WBS)
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),   INTENT(IN   ):: WBS
    INTEGER:: I, K, F
    !
    IF(WBS%HAS_CROP_FLUX) THEN
        DO CONCURRENT (I=ONE:CDAT%NCROP,     WBS%CRP_HAS_ADMD(I)    )
        DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
              !
              F = CDAT%CROP(I)%FID(K)
              IF(WBS%WBS_HAS_ADMD(F)) CALL ADD_EXTERNAL_DEMAND(CDAT,WBS%CROP_FLUX(F,I),I,K,F,TRUE)
              !
        END DO; END DO
    END IF
    !
    IF(WBS%HAS_CROP_VOLR) THEN
        DO CONCURRENT (I=ONE:CDAT%NCROP,     WBS%CRP_HAS_ADMD(I)    )
        DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%IRR(K) > Z)
              !
              F = CDAT%CROP(I)%FID(K)
              IF(WBS%WBS_HAS_ADMD(F)) CALL ADD_EXTERNAL_DEMAND(CDAT,WBS%CROP_VOLR(F,I),I,K,F,FALSE)
              !
        END DO; END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE CHECK_WBS_ADDED_DEMAND(CDAT,WBS)
    !
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),   INTENT(IN   ):: WBS
    INTEGER:: I, J, K, F, R, C
    CHARACTER(:),ALLOCATABLE:: WARN
    !
    WARN=NL
    !
    IF(WBS%HAS_CROP_FLUX) THEN
        DO CONCURRENT (F=ONE:WBS%NFARM, WBS%WBS_HAS_ADMD(F) )
        DO CONCURRENT (J=ONE:WBS%CROP(F)%N)
                                                I=WBS%CROP(F)%PNT(ONE,J)
                                                K=WBS%CROP(F)%PNT(TWO,J)
                                                IF(WBS%CROP_FLUX(F,I) .NE. DZ .AND. CDAT%CROP(I)%IRR(K) == Z) THEN
                                                IF(LEN(WARN) < THOU30) THEN
                                                       R = WBS%CROP(F)%PNT(THREE,J)
                                                       C = WBS%CROP(F)%PNT(FOUR, J)
                                                       WARN=WARN//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//BLNK//NUM2STR(WBS%CROP_FLUX(F,I))//NL
                                                END IF
                                                END IF
        END DO; END DO
          IF (WARN.NE.NL) THEN
                   WARN='FMP WBS AND CROP -- CHECK FOR VALID "ADDED_CROP_DEMAND LENGTH" HAD CROPS WITH DEMANDS THAT DO NOT HAVE AN IRRIGATION TYPE'//NL//'SPECIFICALLY IT HAD "IRRIGATION=0" SO NO WAY TO SATISFY THE ADDITIONAL CROP DEMAND.'//NL// &
                         'THE FOLLOWING FARMS/CROPS WILL NEVER MEET THEIR ADDIONTIONAL DEMANDS BECAUSE IT HAS IRRIGATION=0'//BLN// &
                         '*** NOTE THIS IS JUST A WARNING IN CASE YOU MEANT TO HAVE ADDITIONAL IRRIGATION ***'//BLN// &
                         '  WBS CROP_ID      ROW      COLUMN   ADDED_DEMAND_LENGTH'//WARN
                         !
                   IF(LEN(WARN) >= THOU30) WARN=WARN//NL//'   ***Note that warning message was truncated do to excessive length***'//NL
                   !
                   CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=WARN)
                   WARN = NL
          END IF
    END IF
    !
    IF(WBS%HAS_CROP_VOLR) THEN
        DO CONCURRENT (F=ONE:WBS%NFARM, WBS%WBS_HAS_ADMD(F) )
        DO CONCURRENT (J=ONE:WBS%CROP(F)%N)
                                                I=WBS%CROP(F)%PNT(ONE,J)
                                                K=WBS%CROP(F)%PNT(TWO,J)
                                                IF(WBS%CROP_VOLR(F,I) .NE. DZ .AND. CDAT%CROP(I)%IRR(K) == Z) THEN
                                                IF(LEN(WARN) < THOU30) THEN
                                                       R = WBS%CROP(F)%PNT(THREE,J)
                                                       C = WBS%CROP(F)%PNT(FOUR, J)
                                                       WARN=WARN//BLNK//NUM2STR(F,-8)//BLNK//NUM2STR(I,-8)//BLNK//NUM2STR(R,-8)//BLNK//NUM2STR(C,-8)//BLNK//NUM2STR(WBS%CROP_FLUX(F,I))//NL
                                                END IF
                                                END IF
        END DO; END DO
        IF (WARN.NE.NL) THEN
                 WARN='FMP WBS AND CROP -- CHECK FOR VALID "ADDED_CROP_DEMAND RATE" HAD CROPS WITH DEMANDS THAT DO NOT HAVE AN IRRIGATION TYPE'//NL//'SPECIFICALLY IT HAD "IRRIGATION=0" SO NO WAY TO SATISFY THE ADDITIONAL CROP DEMAND.'//NL// &
                       'THE FOLLOWING FARMS/CROPS WILL NEVER MEET THEIR ADDIONTIONAL DEMANDS BECAUSE IT HAS IRRIGATION=0'//BLN// &
                       '*** NOTE THIS IS JUST A WARNING IN CASE YOU MEANT TO HAVE ADDITIONAL IRRIGATION ***'//BLN// &
                       '  WBS CROP_ID      ROW      COLUMN   ADDED_DEMAND_RATE'//WARN
                       !
                 IF(LEN(WARN) >= THOU30) WARN=WARN//NL//'   ***Note that warning message was truncated do to excessive length***'//NL
                 !
                 CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG=WARN)
                 WARN = NL
        END IF
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_EXTERNAL_DEMAND_INI(CDAT)
    CLASS(CROP_DATA), INTENT(INOUT):: CDAT
    INTEGER:: I
    !
    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N > Z )
                                      CDAT%CROP(I)%DEMAND_EXT_INI = CDAT%CROP(I)%DEMAND_EXT
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE NOT_FALLOW_RESET(CDAT)
    !
    CLASS(CROP_DATA),                             INTENT(INOUT):: CDAT
    INTEGER:: I
    !
    DO CONCURRENT ( I=ONE:CDAT%NCROP, CDAT%CROP(I)%N>Z ) 
                                                        CDAT%CROP(I)%NOT_FALLOW    = CDAT%CROP(I)%NOT_FALLOW_SP
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_CROP_DEMAND_TO_ARRAY(CDAT, DIM1, DIM2, ARRAY)
    !
    CLASS(CROP_DATA),                       INTENT(IN ):: CDAT
    INTEGER,                                INTENT(IN):: DIM1,DIM2
    DOUBLE PRECISION, DIMENSION(DIM1,DIM2), INTENT(OUT):: ARRAY
    INTEGER:: I, K
    !
    DO CONCURRENT(I=1:DIM1,K=1:DIM2)
                                   ARRAY(I,K) = DZ
    END DO
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%DEMAND(K) > DZ)
          !
          ARRAY( CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K) ) = ARRAY( CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K) ) + CDAT%CROP(I)%DEMAND(K)
          !
    END DO; END DO
    !
    IF(CDAT%HAS_DEMAND_EXT) THEN
          DO CONCURRENT (I=ONE:CDAT%NCROP)
          DO CONCURRENT (K=ONE:CDAT%CROP(I)%N,   CDAT%CROP(I)%DEMAND_EXT(K) < NEGNEARZERO_30 .OR. CDAT%CROP(I)%DEMAND_EXT(K) > NEARZERO_30 )
                !
                ARRAY( CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K) ) = ARRAY( CDAT%CROP(I)%RC(TWO,K),CDAT%CROP(I)%RC(ONE,K) ) + CDAT%CROP(I)%DEMAND_EXT(K)
                !
          END DO; END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_CROP_ADDED_DEMAND_BYWBS(CDAT, DIM, VEC)
    !
    CLASS(CROP_DATA),                 INTENT(IN   ):: CDAT
    INTEGER,                          INTENT(IN   ):: DIM
    DOUBLE PRECISION, DIMENSION(DIM), INTENT(INOUT):: VEC
    INTEGER:: I, K
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N,   CDAT%CROP(I)%DEMAND_EXT(K) < NEGNEARZERO_30 .OR. CDAT%CROP(I)%DEMAND_EXT(K) > NEARZERO_30 )
          !
          VEC( CDAT%CROP(I)%FID(K) ) = VEC( CDAT%CROP(I)%FID(K) ) + CDAT%CROP(I)%DEMAND_EXT(K)
          !
    END DO; END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE PRORATE_DEMAND_DEFECICIY(CDAT, WBS, F)
    !
    !  ASSUMES THAT WBS%IRR_AREA IS UP TO DATE WITH CALLING 
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(IN   ):: WBS
    INTEGER, INTENT(IN):: F
    !
    INTEGER:: I, J, K, IMPRV
    DOUBLE PRECISION:: QAVF, QAVD, QDEF, QEXC, FRAC1, FRAC2, DMD, DMD2, RATIO
    !
    IF(WBS%IRR_AREA(F) < NEARZERO_30 .OR. WBS%SUPPLY(F)%CROP < NEARZERO_30) THEN  !NO IRRIGATED AREA OR SIMPLY NO SUPPLY --ZERO OUT DEMAND
        !
        DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
            I=WBS%CROP(F)%PNT(ONE,J)
            K=WBS%CROP(F)%PNT(TWO,J)
            !
            !IF(CDAT%CROP(I)%DEMAND(K) > DZ) CDAT%CROP(I)%TSUR(K) = MIN(CDAT%CROP(I)%TSUR(K), CDAT%CROP(I)%TPPOT(K)) !CDAT%CROP(I)%TSUR(K) - CDAT%CROP(I)%DEMAND(K)*CDAT%CROP(I)%EFF(K)  !Lower TSUR TO MATCH HOW MUCH WATER IS APPLIED PLUS PRECIP.  -- QDEF*CDAT%CROP(I)%EFF(K) IS AMMOUNT OF WATER NO LONGER APPLIED TO PLANT
            !
            CDAT%CROP(I)%TI(K)     = DZ
            CDAT%CROP(I)%CIR(K)    = DZ
            CDAT%CROP(I)%DEMAND(K) = DZ
            CDAT%CROP(I)%DEMAND_EXT(K) = DZ
        END DO    
    ELSE
        SELECT CASE(WBS%PRORATE_DEFICIENCY)
        CASE(Z)
                 IF( WBS%CROP_DEMAND_ADDED(F) > DZ ) THEN
                     DMD = WBS%CROP_DEMAND(F) - WBS%CROP_DEMAND_ADDED(F)  !Remove added part to onyl have Crop DMD
                 ELSE
                     DMD = WBS%CROP_DEMAND(F)
                 END IF
                 DMD2  = WBS%CROP_DEMAND_ADDED(F)
                 !
                 FRAC1 = UNO  !Flag to indicate crop must be reduced
                 FRAC2 = DZ  !Scale for Added DMD
                 !
                 IF(DMD2 < NEARZERO_30) THEN  !No added demand, only adjust Crop
                     !
                     FRAC2 = UNO
                     !
                 ELSEIF(DMD  < NEARZERO_30) THEN  !No crop dmd demand, only just added
                     !
                     FRAC1 = DNEG
                     FRAC2 = WBS%SUPPLY(F)%CROP / WBS%CROP_DEMAND(F)
                     !
                 ELSEIF(DMD < WBS%SUPPLY(F)%CROP) THEN                    !Supply enough to meet some of external dmd and Crop demand
                     !
                     FRAC1 = DNEG                                          !Met all of Crop Demand
                     !
                     RATIO = WBS%SUPPLY(F)%CROP - DMD                     !Supply for Added dmd
                     !
                     IF(RATIO > NEARZERO_30)  FRAC2 = RATIO / DMD2  !Reduce Added Demand by Shortfall
                 END IF
                 !
                 IF( FRAC2 < UNO) THEN
                   DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
                       I=WBS%CROP(F)%PNT(ONE,J)
                       K=WBS%CROP(F)%PNT(TWO,J)
                       !
                       CDAT%CROP(I)%DEMAND_EXT(K) = FRAC2 * CDAT%CROP(I)%DEMAND_EXT(K)
                       !
                       IF( CDAT%CROP(I)%DEMAND_EXT(K) < NEARZERO_30) CDAT%CROP(I)%DEMAND_EXT(K) = DZ
                   END DO
                 END IF
                 !
                 IF( FRAC1 > DZ ) THEN  ! Flag indicates that Crop must be adjusted
                    !
                    FRAC1 = DZ
                    QDEF = DZ
                    QEXC = DZ
                    !IRR_CROP_AREA = DZ
                    !DO CONCURRENT(J=ONE:WBS%CROP(F)%N)  !GET AREA --MAYBE OUT OF SYNC WITH WBS%IRR_AREA DO TO FALLOWING
                    !    I=WBS%CROP(F)%PNT(ONE,J)
                    !    K=WBS%CROP(F)%PNT(TWO,J)
                    !    !
                    !    IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) IRR_CROP_AREA = IRR_CROP_AREA + CDAT%CROP(I)%AREA(K)
                    !END DO
                    !
                    QAVF = WBS%SUPPLY(F)%CROP / WBS%IRR_AREA(F)  !AVERAGE FLOW PER IRRIGATED CROP AREA    / CROP_DEMAND(F)
                    !
                    DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
                        I=WBS%CROP(F)%PNT(ONE,J)
                        K=WBS%CROP(F)%PNT(TWO,J)
                        !
                        IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z)  THEN
                            !
                            QAVD = QAVF*CDAT%CROP(I)%AREA(K)
                            !
                            DMD = CDAT%CROP(I)%DEMAND(K) !+ FRAC2*CDAT%CROP(I)%DEMAND_EXT(K)
                            IF ( DMD > QAVD ) THEN
                                                                                          QEXC = QEXC + DMD - QAVD
                            ELSE
                                                                                          QDEF = QDEF + QAVD - DMD
                            END IF
                        END IF
                    END DO
                    !
                    IF(QEXC > DZ) FRAC1 = QDEF/QEXC
                    !
                    DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
                        I=WBS%CROP(F)%PNT(ONE,J)
                        K=WBS%CROP(F)%PNT(TWO,J)
                        !
                        QAVD = QAVF*CDAT%CROP(I)%AREA(K)
                        !
                             DMD2 = CDAT%CROP(I)%DEMAND(K)
                        IF ( DMD2 > QAVD .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
                               !
                               !DMD  = FRAC * (CDAT%CROP(I)%DEMAND(K)-QAVD) + QAVD
                               DMD  = FRAC1 * (DMD2-QAVD) + QAVD
                               !
                               RATIO = DZ
                               IF(DMD2>DZ) RATIO = DMD/DMD2
                               IF(RATIO > UNO) RATIO = UNO
                               IF(RATIO < DZ ) RATIO = DZ
                               !
                               DMD = CDAT%CROP(I)%DEMAND(K)     * RATIO
                               !
                               !QDEF = (CDAT%CROP(I)%DEMAND(K) - DMD) * CDAT%CROP(I)%EFF(K) !CIR_DEFICIT
                               !
                               !CIR = (TSUR-TPPOT)*(1+CECT)
                               !TSUR = CIR/(1+CECT) + TPPOT
                               !TSUR_1 - TSUR_2 = (CIR_1-CIR_2)/(1+CECT) = ((DMD_1-DMD_2)*EFF)/(1+CECT)
                               !
                               !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TSUR(K) - QDEF/(UNO + CDAT%CROP(I)%CECT(K))
                               !
                               IMPRV = WBS%EFF_IMPROVE_TFR%GET( F, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), CDAT%CROP(I)%IRR(K) )
                               IF( IMPRV == Z ) THEN
                                   CDAT%CROP(I)%CIR(K) = DMD * CDAT%CROP(I)%EFF(K)
                                   CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
                               ELSE
                                   IF(DMD > NEARZERO_30) THEN
                                                    CDAT%CROP(I)%EFF(K) = CDAT%CROP(I)%CIR(K) / DMD
                                                    IF(CDAT%CROP(I)%EFF(K) > UNO) THEN
                                                                                      CDAT%CROP(I)%EFF(K) = UNO
                                                                                      CDAT%CROP(I)%CIR(K) = DMD
                                                                                      CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
                                                    END IF
                                   ELSE
                                                    !CDAT%CROP(I)%EFF(K) = DZ
                                                    CDAT%CROP(I)%TI(K)  = DZ
                                   END IF
                               END IF
                               !
                               IF( CDAT%CROP(I)%TI(K) < NEARZERO_30) THEN
                                   CDAT%CROP(I)%TI(K)     = DZ
                                   CDAT%CROP(I)%CIR(K)    = DZ
                                   CDAT%CROP(I)%DEMAND(K) = DZ
                               ELSE
                                   CDAT%CROP(I)%DEMAND(K) = DMD
                               END IF
                               !
                               !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
                               !
                        END IF  !IF <QAVD THEN DEMAND IS FULLY MET AND NO CHANGE IN EFF. PREVIOUS FMP WOULD LOWER DEMAND TO TSUR TO MAKE EFF=1
                    END DO
                 END IF
        CASE(ONE)
                 IF( WBS%CROP_DEMAND_ADDED(F) > DZ ) THEN
                     DMD = WBS%CROP_DEMAND(F) - WBS%CROP_DEMAND_ADDED(F)  !Remove added part to onyl have Crop DMD
                 ELSE
                     DMD = WBS%CROP_DEMAND(F)
                 END IF
                 DMD2  = WBS%CROP_DEMAND_ADDED(F)
                 !
                 FRAC1 = DZ  !Scale for Crop DMD
                 FRAC2 = DZ  !Scale for Added DMD
                 !
                 IF(DMD2 < NEARZERO_30) THEN  !No added demand, only adjust Crop
                     !
                     FRAC1 = WBS%SUPPLY(F)%CROP / WBS%CROP_DEMAND(F)
                     !
                 ELSEIF(DMD  < NEARZERO_30) THEN  !No acropdded demand, only just added
                     !
                     FRAC2 = WBS%SUPPLY(F)%CROP / WBS%CROP_DEMAND(F)
                     !
                 ELSEIF(DMD < WBS%SUPPLY(F)%CROP) THEN                    !Supply enough to meet some of external dmd and Crop demand
                     !
                     FRAC1 = UNO                                          !Met all of Crop Demand
                     !
                     RATIO = WBS%SUPPLY(F)%CROP - DMD                     !Supply for Added dmd
                     !
                     IF(RATIO > NEARZERO_30)  FRAC2 = RATIO / DMD2  !Reduce Added Demand by Shortfall
                     !
                 ELSE !Crop demand is greater than supply
                     !
                     FRAC1 = WBS%SUPPLY(F)%CROP / DMD
                 END IF
                 !
                 DO CONCURRENT(J=ONE:WBS%CROP(F)%N)
                     I=WBS%CROP(F)%PNT(ONE,J)
                     K=WBS%CROP(F)%PNT(TWO,J)
                     !
                     IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
                            !
                            DMD  = CDAT%CROP(I)%DEMAND(K)     * FRAC1
                            DMD2 = CDAT%CROP(I)%DEMAND_EXT(K) * FRAC2
                            !QDEF = (CDAT%CROP(I)%DEMAND(K) - DMD) * CDAT%CROP(I)%EFF(K) !CIR_DEFICIT
                            !
                            !CIR = (TSUR-TPPOT)*(1+CECT)
                            !TSUR = CIR/(1+CECT) + TPPOT
                            !TSUR_1 - TSUR_2 = (CIR_1-CIR_2)/(1+CECT) = ((DMD_1-DMD_2)*EFF)/(1+CECT)
                            !
                            !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TSUR(K) - QDEF/(UNO + CDAT%CROP(I)%CECT(K))
                            !
                            IMPRV = WBS%EFF_IMPROVE_TFR%GET( F, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), CDAT%CROP(I)%IRR(K) )
                            IF( IMPRV == Z ) THEN
                                CDAT%CROP(I)%CIR(K) = DMD * CDAT%CROP(I)%EFF(K)
                                CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
                            ELSE
                                IF(DMD > NEARZERO_30) THEN
                                                 CDAT%CROP(I)%EFF(K) = CDAT%CROP(I)%CIR(K) / DMD
                                                 IF(CDAT%CROP(I)%EFF(K) > UNO) THEN
                                                                                   CDAT%CROP(I)%EFF(K) = UNO
                                                                                   CDAT%CROP(I)%CIR(K) = DMD
                                                                                   CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
                                                 END IF
                                ELSE
                                                 !CDAT%CROP(I)%EFF(K) = DZ
                                                 CDAT%CROP(I)%TI(K)  = DZ
                                END IF
                            END IF
                            !
                            IF( CDAT%CROP(I)%TI(K) < NEARZERO_30) THEN
                                CDAT%CROP(I)%TI(K)     = DZ
                                CDAT%CROP(I)%CIR(K)    = DZ
                                CDAT%CROP(I)%DEMAND(K) = DZ
                            ELSE
                                CDAT%CROP(I)%DEMAND(K) = DMD
                            END IF
                            !
                            IF( DMD2 < NEARZERO_30) THEN
                                CDAT%CROP(I)%DEMAND_EXT(K) = DZ
                            ELSE
                                CDAT%CROP(I)%DEMAND_EXT(K) = DMD2
                            END IF
                     END IF
                     !
                 END DO
        END SELECT
    END IF
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE PRORATE_DEMAND_DEFECICIY(CDAT, WBS, F)
  !!!  !
  !!!  !  ASSUMES THAT WBS%IRR_AREA IS UP TO DATE WITH CALLING 
  !!!  CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
  !!!  TYPE(WBS_DATA),     INTENT(IN   ):: WBS
  !!!  INTEGER, INTENT(IN):: F
  !!!  !
  !!!  INTEGER:: I, J, K, IMPRV
  !!!  DOUBLE PRECISION:: QAVF, QAVD, QDEF, QEXC, FRAC, DMD, DMD2, RATIO
  !!!  !
  !!!  IF(WBS%IRR_AREA(F) < NEARZERO_30 .OR. WBS%SUPPLY(F)%CROP < NEARZERO_30) THEN  !NO IRRIGATED AREA OR SIMPLY NO SUPPLY --ZERO OUT DEMAND
  !!!      !
  !!!      DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
  !!!          I=WBS%CROP(F)%PNT(ONE,J)
  !!!          K=WBS%CROP(F)%PNT(TWO,J)
  !!!          !
  !!!          !IF(CDAT%CROP(I)%DEMAND(K) > DZ) CDAT%CROP(I)%TSUR(K) = MIN(CDAT%CROP(I)%TSUR(K), CDAT%CROP(I)%TPPOT(K)) !CDAT%CROP(I)%TSUR(K) - CDAT%CROP(I)%DEMAND(K)*CDAT%CROP(I)%EFF(K)  !Lower TSUR TO MATCH HOW MUCH WATER IS APPLIED PLUS PRECIP.  -- QDEF*CDAT%CROP(I)%EFF(K) IS AMMOUNT OF WATER NO LONGER APPLIED TO PLANT
  !!!          !
  !!!          CDAT%CROP(I)%TI(K)     = DZ
  !!!          CDAT%CROP(I)%CIR(K)    = DZ
  !!!          CDAT%CROP(I)%DEMAND(K) = DZ
  !!!          CDAT%CROP(I)%DEMAND_EXT(K) = DZ
  !!!      END DO    
  !!!  ELSE
  !!!      SELECT CASE(WBS%PRORATE_DEFICIENCY)
  !!!      CASE(Z)
  !!!               QDEF = DZ
  !!!               QEXC = DZ
  !!!               FRAC = DZ
  !!!               !IRR_CROP_AREA = DZ
  !!!               !DO CONCURRENT(J=ONE:WBS%CROP(F)%N)  !GET AREA --MAYBE OUT OF SYNC WITH WBS%IRR_AREA DO TO FALLOWING
  !!!               !    I=WBS%CROP(F)%PNT(ONE,J)
  !!!               !    K=WBS%CROP(F)%PNT(TWO,J)
  !!!               !    !
  !!!               !    IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) IRR_CROP_AREA = IRR_CROP_AREA + CDAT%CROP(I)%AREA(K)
  !!!               !END DO
  !!!               !
  !!!               QAVF = WBS%SUPPLY(F)%CROP / WBS%IRR_AREA(F)  !AVERAGE FLOW PER IRRIGATED CROP AREA    / CROP_DEMAND(F)
  !!!               !
  !!!               DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
  !!!                   I=WBS%CROP(F)%PNT(ONE,J)
  !!!                   K=WBS%CROP(F)%PNT(TWO,J)
  !!!                   !
  !!!                   IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z)  THEN
  !!!                       !
  !!!                       QAVD = QAVF*CDAT%CROP(I)%AREA(K)
  !!!                       !
  !!!                       DMD = CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)
  !!!                       IF ( DMD > QAVD ) THEN
  !!!                                                                                     QEXC = QEXC + DMD - QAVD
  !!!                       ELSE
  !!!                                                                                     QDEF = QDEF + QAVD - DMD
  !!!                       END IF
  !!!                   END IF
  !!!               END DO
  !!!               !
  !!!               IF(QEXC > DZ) FRAC = QDEF/QEXC
  !!!               !
  !!!               DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
  !!!                   I=WBS%CROP(F)%PNT(ONE,J)
  !!!                   K=WBS%CROP(F)%PNT(TWO,J)
  !!!                   !
  !!!                   QAVD = QAVF*CDAT%CROP(I)%AREA(K)
  !!!                   !
  !!!                        DMD2 = CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)
  !!!                   IF ( DMD2 > QAVD .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
  !!!                          !
  !!!                          !DMD  = FRAC * (CDAT%CROP(I)%DEMAND(K)-QAVD) + QAVD
  !!!                          DMD  = FRAC * (DMD2-QAVD) + QAVD
  !!!                          !
  !!!                          RATIO = DZ
  !!!                          IF(DMD2>DZ) RATIO = DMD/DMD2
  !!!                          IF(RATIO > UNO) RATIO = UNO
  !!!                          IF(RATIO < DZ ) RATIO = DZ
  !!!                          !
  !!!                          DMD = CDAT%CROP(I)%DEMAND(K)     * RATIO
  !!!                          DMD2= CDAT%CROP(I)%DEMAND_EXT(K) * RATIO
  !!!                          !
  !!!                          !QDEF = (CDAT%CROP(I)%DEMAND(K) - DMD) * CDAT%CROP(I)%EFF(K) !CIR_DEFICIT
  !!!                          !
  !!!                          !CIR = (TSUR-TPPOT)*(1+CECT)
  !!!                          !TSUR = CIR/(1+CECT) + TPPOT
  !!!                          !TSUR_1 - TSUR_2 = (CIR_1-CIR_2)/(1+CECT) = ((DMD_1-DMD_2)*EFF)/(1+CECT)
  !!!                          !
  !!!                          !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TSUR(K) - QDEF/(UNO + CDAT%CROP(I)%CECT(K))
  !!!                          !
  !!!                          IMPRV = WBS%EFF_IMPROVE_TFR%GET( F, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), CDAT%CROP(I)%IRR(K) )
  !!!                          IF( IMPRV == Z ) THEN
  !!!                              CDAT%CROP(I)%CIR(K) = DMD * CDAT%CROP(I)%EFF(K)
  !!!                              CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
  !!!                          ELSE
  !!!                              IF(DMD > NEARZERO_30) THEN
  !!!                                               CDAT%CROP(I)%EFF(K) = CDAT%CROP(I)%CIR(K) / DMD
  !!!                                               IF(CDAT%CROP(I)%EFF(K) > UNO) THEN
  !!!                                                                                 CDAT%CROP(I)%EFF(K) = UNO
  !!!                                                                                 CDAT%CROP(I)%CIR(K) = DMD
  !!!                                                                                 CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
  !!!                                               END IF
  !!!                              ELSE
  !!!                                               !CDAT%CROP(I)%EFF(K) = DZ
  !!!                                               CDAT%CROP(I)%TI(K)  = DZ
  !!!                              END IF
  !!!                          END IF
  !!!                          !
  !!!                          IF( CDAT%CROP(I)%TI(K) < NEARZERO_30) THEN
  !!!                              CDAT%CROP(I)%TI(K)     = DZ
  !!!                              CDAT%CROP(I)%CIR(K)    = DZ
  !!!                              CDAT%CROP(I)%DEMAND(K) = DZ
  !!!                          ELSE
  !!!                              CDAT%CROP(I)%DEMAND(K) = DMD
  !!!                          END IF
  !!!                          !
  !!!                          IF( DMD2 < NEARZERO_30) THEN
  !!!                              CDAT%CROP(I)%DEMAND_EXT(K) = DZ
  !!!                          ELSE
  !!!                              CDAT%CROP(I)%DEMAND_EXT(K) = DMD2
  !!!                          END IF
  !!!                          !
  !!!                          !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
  !!!                          !
  !!!                   END IF  !IF <QAVD THEN DEMAND IS FULLY MET AND NO CHANGE IN EFF. PREVIOUS FMP WOULD LOWER DEMAND TO TSUR TO MAKE EFF=1
  !!!               END DO
  !!!      CASE(ONE)
  !!!               FRAC = WBS%SUPPLY(F)%CROP / WBS%CROP_DEMAND(F)
  !!!               DO CONCURRENT(J=ONE:WBS%CROP(F)%N)
  !!!                   I=WBS%CROP(F)%PNT(ONE,J)
  !!!                   K=WBS%CROP(F)%PNT(TWO,J)
  !!!                   !
  !!!                   IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) THEN
  !!!                          !
  !!!                          DMD  = CDAT%CROP(I)%DEMAND(K) * FRAC
  !!!                          DMD2 = CDAT%CROP(I)%DEMAND_EXT(K) * FRAC
  !!!                          !QDEF = (CDAT%CROP(I)%DEMAND(K) - DMD) * CDAT%CROP(I)%EFF(K) !CIR_DEFICIT
  !!!                          !
  !!!                          !CIR = (TSUR-TPPOT)*(1+CECT)
  !!!                          !TSUR = CIR/(1+CECT) + TPPOT
  !!!                          !TSUR_1 - TSUR_2 = (CIR_1-CIR_2)/(1+CECT) = ((DMD_1-DMD_2)*EFF)/(1+CECT)
  !!!                          !
  !!!                          !CDAT%CROP(I)%TSUR(K) = CDAT%CROP(I)%TSUR(K) - QDEF/(UNO + CDAT%CROP(I)%CECT(K))
  !!!                          !
  !!!                          IMPRV = WBS%EFF_IMPROVE_TFR%GET( F, CDAT%CROP(I)%RC(TWO,K), CDAT%CROP(I)%RC(ONE,K), CDAT%CROP(I)%IRR(K) )
  !!!                          IF( IMPRV == Z ) THEN
  !!!                              CDAT%CROP(I)%CIR(K) = DMD * CDAT%CROP(I)%EFF(K)
  !!!                              CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
  !!!                          ELSE
  !!!                              IF(DMD > NEARZERO_30) THEN
  !!!                                               CDAT%CROP(I)%EFF(K) = CDAT%CROP(I)%CIR(K) / DMD
  !!!                                               IF(CDAT%CROP(I)%EFF(K) > UNO) THEN
  !!!                                                                                 CDAT%CROP(I)%EFF(K) = UNO
  !!!                                                                                 CDAT%CROP(I)%CIR(K) = DMD
  !!!                                                                                 CDAT%CROP(I)%TI(K)  = CDAT%CROP(I)%CIR(K)/ (UNO + CDAT%CROP(I)%CECT(K))
  !!!                                               END IF
  !!!                              ELSE
  !!!                                               !CDAT%CROP(I)%EFF(K) = DZ
  !!!                                               CDAT%CROP(I)%TI(K)  = DZ
  !!!                              END IF
  !!!                          END IF
  !!!                          !
  !!!                          IF( CDAT%CROP(I)%TI(K) < NEARZERO_30) THEN
  !!!                              CDAT%CROP(I)%TI(K)     = DZ
  !!!                              CDAT%CROP(I)%CIR(K)    = DZ
  !!!                              CDAT%CROP(I)%DEMAND(K) = DZ
  !!!                          ELSE
  !!!                              CDAT%CROP(I)%DEMAND(K) = DMD
  !!!                          END IF
  !!!                          !
  !!!                          IF( DMD2 < NEARZERO_30) THEN
  !!!                              CDAT%CROP(I)%DEMAND_EXT(K) = DZ
  !!!                          ELSE
  !!!                              CDAT%CROP(I)%DEMAND_EXT(K) = DMD2
  !!!                          END IF
  !!!                   END IF
  !!!                   !
  !!!               END DO
  !!!      END SELECT
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !
  PURE SUBROUTINE APPLY_DEFICIENCY_SCENARIO(CDAT, WBS, F)
    !
    CLASS(CROP_DATA),   INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    INTEGER,            INTENT(IN   ):: F
    INTEGER:: I, K, J, R, C, RANK
    LOGICAL:: UPDATE
    !
    IF(CDAT%NCROP == Z) RETURN
    !
    UPDATE = FALSE
    !DO CONCURRENT   ( F=ONE:WBS%NFARM, WBS%CROP_DEMAND(F) > NEARZERO_10 .AND. WBS%SUPPLY(F)%CROP - WBS%CROP_DEMAND(F) < NEGNEARZERO_10 )  !SKIP WHEN SUPPLY IS CLOSE TO DEMAND  --ADD CHECK FOR WATER STACK FOR ADDING CROP LAND
    IF (WBS%CROP_DEMAND(F) > NEARZERO_10 .AND. WBS%SUPPLY(F)%CROP - WBS%CROP_DEMAND(F) < NEGNEARZERO_10) THEN
        !
        SELECT CASE(WBS%DEFICIENCY%LIST(F))
        !CASE(Z)
        !    CONTINUE  !WATER MAGICALLY FOUND AND APPLIED
        CASE(ONE)
                 UPDATE = TRUE
                 CALL PRORATE_DEMAND_DEFECICIY(CDAT, WBS, F)
        CASE(TWO)
                 UPDATE = TRUE
                 !
                 RANK = Z
                 !
                 DO WHILE (RANK < WBS%MAX_FALLOW_RANK(F) .OR. WBS%CROP_DEMAND(F) > WBS%SUPPLY(F)%CROP)
                    !
                    RANK = RANK + ONE
                    !
                    DO CONCURRENT(J=ONE:WBS%CROP(F)%N)
                          I=WBS%CROP(F)%PNT(ONE,J)
                          K=WBS%CROP(F)%PNT(TWO,J)
                          !
                          IF ( CDAT%CROP(I)%FALLOW_RANK(K) == RANK)  THEN
                               !
                               CDAT%CROP(I)%NOT_FALLOW(K) = FALSE
                               WBS%CROP_DEMAND(F) = WBS%CROP_DEMAND(F) - CDAT%CROP(I)%DEMAND(K) - CDAT%CROP(I)%DEMAND_EXT(K)
                          END IF
                    END DO
                 END DO
                 !
                 WBS%IRR_AREA(F) = DZ               !NEED TO UPDATE IRR_AREA DUE TO FALLOWING
                 DO CONCURRENT(J=ONE:WBS%CROP(F)%N)
                     I=WBS%CROP(F)%PNT(ONE,J)
                     K=WBS%CROP(F)%PNT(TWO,J)
                     !
                     IF(CDAT%CROP(I)%NOT_FALLOW(K) .AND. CDAT%CROP(I)%IRR(K) > Z) WBS%IRR_AREA(F) = WBS%IRR_AREA(F) + CDAT%CROP(I)%AREA(K)
                 END DO
                 !
                 IF ( WBS%CROP_DEMAND(F) > WBS%SUPPLY(F)%CROP ) THEN
                           CALL PRORATE_DEMAND_DEFECICIY(CDAT, WBS, F)
                 END IF
                 !
        END SELECT
        !
        IF (UPDATE) THEN !CALL ADD_CROP_DEMAND_TO_ARRAY(CDAT, WBS%CROP_DEMAND_ARRAY)
           !
           !WHERE(WBS%FID_ARRAY==F);  WBS%CROP_DEMAND_ARRAY = DZ  !UPDATING DEMAND, SO ZERO OUT FARM THAT IS UNDER DEFICIT
           !END WHERE
           DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                          WBS%CROP_DEMAND_ARRAY( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) ) = DZ
           END DO
           !CALL POSITION_SET_ARRAY(WBS%NCOL, WBS%NROW, F, WBS%FID_ARRAY, DZ, WBS%CROP_DEMAND_ARRAY) ! --Only minor speed boost over where
           !
           WBS%CROP_DEMAND(F) = DZ
           WBS%CROP_DEMAND_ADDED(F) = DZ
           DO CONCURRENT(J=ONE:WBS%CROP(F)%N)   !CROP POSITION IN WBS
               I=WBS%CROP(F)%PNT(ONE,  J)  !CROP ID
               K=WBS%CROP(F)%PNT(TWO,  J)  !CROP POSITION IN CROP
               R=WBS%CROP(F)%PNT(THREE,J)  !CROP Row
               C=WBS%CROP(F)%PNT(FOUR, J)  !CROP Col
               !
               WBS%CROP_DEMAND_ARRAY(C,R) = WBS%CROP_DEMAND_ARRAY(C,R) + CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)
               !
               WBS%CROP_DEMAND(F) = WBS%CROP_DEMAND(F)+ CDAT%CROP(I)%DEMAND(K) + CDAT%CROP(I)%DEMAND_EXT(K)
               !
               WBS%CROP_DEMAND_ADDED(F) = WBS%CROP_DEMAND_ADDED(F) + CDAT%CROP(I)%DEMAND_EXT(K)
           END DO
        END IF
    END IF
    !    
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_INEFFICIENT_LOSSES(CDAT, WBS, SURF_VK)
    !
    CLASS(CROP_DATA),                             INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),                               INTENT(INOUT):: WBS
    DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: SURF_VK
    INTEGER:: I, K, R, C, L
    DOUBLE PRECISION:: EXCESS, RUNOFF, DPERC_LIMIT
    !
    ! INITIALIZE VECTORS ---------------------------------
    !
    DO CONCURRENT(I=ONE:CDAT%NCROP   )
    DO CONCURRENT(K=ONE:CDAT%CROP(I)%N); CDAT%CROP(I)%RNOFF(K)     = DZ
    END DO; END DO
    !
    DO CONCURRENT(I=ONE:CDAT%NCROP   )
    DO CONCURRENT(K=ONE:CDAT%CROP(I)%N); CDAT%CROP(I)%DPERC(K)     = DZ
    END DO; END DO
    !
    DO CONCURRENT(I=ONE:CDAT%NCROP   )
    DO CONCURRENT(K=ONE:CDAT%CROP(I)%N); CDAT%CROP(I)%RNOFF_EXT(K) = DZ
    END DO; END DO
    !
    DO CONCURRENT(I=ONE:CDAT%NCROP   )
    DO CONCURRENT(K=ONE:CDAT%CROP(I)%N); CDAT%CROP(I)%DPERC_EXT(K) = DZ
    END DO; END DO
    !
    ! END INITIALIZE VECTORS ----------------------------------
    !
    ! IRRIGATION EXCESS
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%DEMAND(K) > NEARZERO_30 ) ! .AND. CDAT%CROP(I)%NOT_FALLOW(K) .AND. DZ < CDAT%CROP(I)%EFF(K) .AND. CDAT%CROP(I)%EFF(K) < UNO 
          !
          R = CDAT%CROP(I)%RC(ONE,K)
          C = CDAT%CROP(I)%RC(TWO,K)
          !
          EXCESS = CDAT%CROP(I)%DEMAND(K) - CDAT%CROP(I)%CIR(K)   
          !                                                                              !EFF=CIR/DEMAND
          IF(EXCESS < DZ) EXCESS = CDAT%CROP(I)%DEMAND(K) * (UNO - CDAT%CROP(I)%EFF(K))  ! DEMAND - CIR =  DEMAND - DEMAND*EFF = DEMAND*(1-EFF)   --EXCESS<0 FOR DEFICIT SCENARIO
          !
          IF(EXCESS > NEARZERO_30) THEN
                IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                               WBS%RUNOFF(C,R)       = WBS%RUNOFF(C,R) + EXCESS
                               CDAT%CROP(I)%RNOFF(K) = EXCESS
                ELSE
                     IF(    CDAT%CROP(I)%FIESWI(K) < NEARZERO_30) THEN
                                                               WBS%DPERC(C,R)        = WBS%DPERC(C,R)  + EXCESS
                                                               CDAT%CROP(I)%DPERC(K) = EXCESS
                     ELSEIF(CDAT%CROP(I)%FIESWI(K) >= UNO) THEN!------------------------------------------
                                                               WBS%RUNOFF(C,R)       = WBS%RUNOFF(C,R) + EXCESS
                                                               CDAT%CROP(I)%RNOFF(K) = EXCESS
                     ELSE!--------------------------------------------------------------------------------
                                                               RUNOFF = EXCESS * CDAT%CROP(I)%FIESWI(K)
                                                               !
                                                               WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                                               WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS - RUNOFF
                                                               CDAT%CROP(I)%RNOFF(K) = RUNOFF
                                                               CDAT%CROP(I)%DPERC(K) = EXCESS - RUNOFF
                     END IF
                END IF
          END IF
    END DO; END DO
    !
    ! EXTRA IRRIGATION EXCESS
    IF(CDAT%HAS_DEMAND_EXT) THEN
      DO CONCURRENT (I=ONE:CDAT%NCROP)
      DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%DEMAND_EXT(K) > NEARZERO_30)
            !
            R = CDAT%CROP(I)%RC(ONE,K)
            C = CDAT%CROP(I)%RC(TWO,K)
            L = UPLAY(C,R)
            !
            EXCESS = CDAT%CROP(I)%DEMAND_EXT(K) * (UNO - CDAT%CROP(I)%EFF(K))  ! DEMAND - CIR =  DEMAND - DEMAND*EFF = DEMAND*(1-EFF)   --EXCESS<0 FOR DEFICIT SCENARIO
            !
            !INEFFICIENT LOSSED EXTRA WATER
            IF(EXCESS > NEARZERO_30) THEN
                  IF(L == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                WBS%RUNOFF(C,R)          = WBS%RUNOFF(C,R) + EXCESS
                                CDAT%CROP(I)%RNOFF_EXT(K) = EXCESS
                  ELSE
                       IF(    CDAT%CROP(I)%FIESWI(K) < NEARZERO_30) THEN
                                                                 WBS%DPERC(C,R)            = WBS%DPERC(C,R)  + EXCESS
                                                                 CDAT%CROP(I)%DPERC_EXT(K) = EXCESS
                       ELSEIF(CDAT%CROP(I)%FIESWI(K) >= UNO) THEN!------------------------------------------
                                                                 WBS%RUNOFF(C,R)           = WBS%RUNOFF(C,R) + EXCESS
                                                                 CDAT%CROP(I)%RNOFF_EXT(K) = EXCESS
                       ELSE!--------------------------------------------------------------------------------
                                                                 RUNOFF = EXCESS * CDAT%CROP(I)%FIESWI(K)
                                                                 !
                                                                 WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                                                 WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS - RUNOFF
                                                                 CDAT%CROP(I)%RNOFF_EXT(K) = RUNOFF
                                                                 CDAT%CROP(I)%DPERC_EXT(K) = EXCESS - RUNOFF
                       END IF
                  END IF
            END IF
            !
            !ACTUAL EXTRA WATER
            EXCESS = CDAT%CROP(I)%DEMAND_EXT(K) * CDAT%CROP(I)%EFF(K)  ! CIR =  DEMAND*EFF --EXCESS<0 FOR DEFICIT SCENARIO
            !
            IF(EXCESS > NEARZERO_30) THEN
                  IF(L == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                                                WBS%RUNOFF(C,R)           = WBS%RUNOFF(C,R) + EXCESS
                                                                CDAT%CROP(I)%RNOFF_EXT(K) = CDAT%CROP(I)%RNOFF_EXT(K) + EXCESS
                  ELSE!----------------------------------------------------------------------------------------------------------------
                       IF(    CDAT%CROP(I)%ADRF(K) < NEARZERO_30) THEN
                                                                WBS%DPERC(C,R)            = WBS%DPERC(C,R)  + EXCESS
                                                                CDAT%CROP(I)%DPERC_EXT(K) = CDAT%CROP(I)%DPERC_EXT(K) + EXCESS
                       ELSEIF(CDAT%CROP(I)%ADRF(K) >= UNO) THEN!-----------------------------------------------------------------------
                                                                WBS%RUNOFF(C,R)           = WBS%RUNOFF(C,R) + EXCESS
                                                                CDAT%CROP(I)%RNOFF_EXT(K) = CDAT%CROP(I)%RNOFF_EXT(K) + EXCESS
                       ELSE!-----------------------------------------------------------------------------------------------------------
                                                                RUNOFF = EXCESS * CDAT%CROP(I)%ADRF(K)
                                                                !
                                                                WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                                                WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS - RUNOFF
                                                                CDAT%CROP(I)%RNOFF_EXT(K) = CDAT%CROP(I)%RNOFF_EXT(K) + RUNOFF
                                                                CDAT%CROP(I)%DPERC_EXT(K) = CDAT%CROP(I)%DPERC_EXT(K) + EXCESS - RUNOFF
                       END IF
                  END IF
            END IF
            !
            CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + CDAT%CROP(I)%RNOFF_EXT(K)
            CDAT%CROP(I)%DPERC(K) = CDAT%CROP(I)%DPERC(K) + CDAT%CROP(I)%DPERC_EXT(K)
      END DO; END DO
    END IF
    !
    !PRECIPITATION EXCESS THAT RESULTS FROM EFFECTIVE PRECIPITATION TABLE
    IF(CDAT%HAS_Pe) THEN
            DO CONCURRENT (I=ONE:CDAT%NCROP)
            DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%RNOFF_Peff(K) > DZ)
                  !
                  CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + CDAT%CROP(I)%RNOFF_Peff(K)
            END DO; END DO
            !
            DO CONCURRENT (I=ONE:CDAT%NCROP)
            DO CONCURRENT (K=ONE:CDAT%CROP(I)%N, CDAT%CROP(I)%RNOFF_Peff(K) > DZ)
                  !
                  R = CDAT%CROP(I)%RC(ONE,K)
                  C = CDAT%CROP(I)%RC(TWO,K)
                  !
                  WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + CDAT%CROP(I)%RNOFF_Peff(K)
            END DO; END DO
    END IF
    !
    !PRECIPITATION EXCESS
    DO CONCURRENT (I=ONE:CDAT%NCROP    )
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
          !
          R = CDAT%CROP(I)%RC(ONE,K)
          C = CDAT%CROP(I)%RC(TWO,K)
          !
          !             P                       - EP                   - TP
          EXCESS = CDAT%CROP(I)%PRECIP(K) - CDAT%CROP(I)%EP(K) - CDAT%CROP(I)%TP(K)
          !
          IF(EXCESS  > NEARZERO_15) THEN
                !
                IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                                             WBS%RUNOFF(C,R)       = WBS%RUNOFF(C,R) + EXCESS
                                                             CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + EXCESS
                ELSE!-----------------------------------------------------------------------------------------------------
                    IF(    CDAT%CROP(I)%FIESWP(K) < NEARZERO_30) THEN
                                                              WBS%DPERC(C,R)        = WBS%DPERC(C,R)  + EXCESS
                                                              CDAT%CROP(I)%DPERC(K) = CDAT%CROP(I)%DPERC(K) + EXCESS
                    ELSEIF(CDAT%CROP(I)%FIESWP(K) >= UNO) THEN!-----------------------------------------------------------
                                                              WBS%RUNOFF(C,R)       = WBS%RUNOFF(C,R) + EXCESS
                                                              CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + EXCESS
                    ELSE!-------------------------------------------------------------------------------------------------
                                                              RUNOFF = EXCESS * CDAT%CROP(I)%FIESWP(K)
                                                              !
                                                              WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                                              WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS - RUNOFF
                                                              CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + RUNOFF
                                                              CDAT%CROP(I)%DPERC(K) = CDAT%CROP(I)%DPERC(K) + EXCESS - RUNOFF
                    END IF
                END IF
          END IF
    END DO; END DO
    !
    !CHECK IF ANY DEEP PERCOLATION EXCEDES SURFACE LEAKAGE LIMIT (SURF_VK).
    !  IF IT DOES, THEN SHIFT TO RUNOFF AS REJECTED INFILTRATION
    !
    DO CONCURRENT (I=ONE:CDAT%NCROP)
    DO CONCURRENT (K=ONE:CDAT%CROP(I)%N)
          !
          R = CDAT%CROP(I)%RC(ONE,K)
          C = CDAT%CROP(I)%RC(TWO,K)
          !
          IF(SURF_VK(C,R) < D10) THEN
                                  DPERC_LIMIT = SURF_VK(C,R) * CDAT%CROP(I)%AREA(K)
                                  !
                                  IF(CDAT%CROP(I)%DPERC(K) > DPERC_LIMIT) THEN
                                      !
                                      RUNOFF = CDAT%CROP(I)%DPERC(K) - DPERC_LIMIT
                                      !
                                      CDAT%CROP(I)%DPERC(K) = DPERC_LIMIT
                                      !
                                      CDAT%CROP(I)%RNOFF(K) = CDAT%CROP(I)%RNOFF(K) + RUNOFF
                                      !
                                      WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                                      WBS%DPERC(C,R)  = WBS%DPERC(C,R)  - RUNOFF
                                      !
                                  END IF
          END IF
    END DO; END DO
    !
    !PRECIPITATION OVER FALLOW/BARE LAND
    IF(CDAT%CHECK_BARE) THEN
          DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_PRECEP_EXCESS(C,R) > DZ )
                !
                IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                               WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + CDAT%BARE_PRECEP_EXCESS(C,R)
                ELSE
                               RUNOFF = CDAT%BARE_PRECEP_EXCESS(C,R) * CDAT%BARE_FRAC_RUNOFF(C,R)  !RUNOFF
                               EXCESS = CDAT%BARE_PRECEP_EXCESS(C,R) - RUNOFF                      !DPERC
                               !
                               IF(SURF_VK(C,R) < D10 .AND. EXCESS > NEARZERO_15) THEN
                                                                                  DPERC_LIMIT = SURF_VK(C,R) * CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                                                                                  !
                                                                                  IF(EXCESS > DPERC_LIMIT) THEN
                                                                                                           RUNOFF = RUNOFF + EXCESS - DPERC_LIMIT
                                                                                                           EXCESS = DPERC_LIMIT
                                                                                  END IF
                               END IF
                               !
                               IF(RUNOFF > NEARZERO_15) WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + RUNOFF
                               !
                               IF(EXCESS > NEARZERO_15) WBS%DPERC(C,R)  = WBS%DPERC(C,R)  + EXCESS
                END IF
          END DO
          !
          !PRECIPITATION EXCESS THAT RESULTS FROM EFFECTIVE PRECIPITATION TABLE
          IF(CDAT%HAS_Pe) THEN
                  DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_RNOFF_Peff(C,R) > DZ )
                      !
                      WBS%RUNOFF(C,R) = WBS%RUNOFF(C,R) + CDAT%BARE_RNOFF_Peff(C,R)
                  END DO
          END IF
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUBTRACT_TGWA_EGWA_FROM_FNRCH(CDAT, WBS)
    !
    ! ASSUMES THAT 
    CLASS(CROP_DATA),   INTENT(IN   ):: CDAT
    TYPE(WBS_DATA),     INTENT(INOUT):: WBS
    !
    IF(CDAT%NCROP > Z) THEN
                                WBS%FNRCH = WBS%FNRCH - CDAT%EGWA - CDAT%TGWA
    ELSEIF(CDAT%CHECK_BARE) THEN
                                WBS%FNRCH = WBS%FNRCH - CDAT%EGWA
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BYFARM(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, J, K, R, C
    DOUBLE PRECISION:: AREA, BARE_AREA, DMDI, DMD, CU_I, CU, CIRI, CIR, TSURF_I, TSURF, EGWA, BARE_EVAP, BARE_EVAP_P, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, ADMD_I, ADMD, P, DP, RO, DP_E, RO_E !, TRAN, EGW,TGW 
    CHARACTER(17):: ZER, DT
    !
    IF(CDAT%OUT_BYFARM%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL CDAT%OUT_BYFARM%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_BYFARM%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_BYFARM%BINARY) THEN
            WRITE(CDAT%IOUT,'(A,/A)')'CROP INFORMATION BY WBS OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (int), WBS AREA (double), CROP AREA (double), IRRIGATED AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double), ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW_CROP (double), EVAP_GW_BARE (double), EVAP_PRECIP_BARE (double),  PRECIPITATION (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                                                                                                                                                                                                            ANOXIA_LOSS SOIL_STRESS_LOSS
            CALL CDAT%OUT_BYFARM%SET_HEADER( '    PER    STP    WBS         WBS_AREA        CROP_AREA   IRRIGATED_AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR EVAP_PRECIP_CROP     EVAP_GW_CROP     EVAP_GW_BARE EVAP_PRECIP_BARE    PRECIPITATION             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    DO F=ONE, WBS%NFARM
       AREA= DZ
       CU_I= DZ   !CU = TGW*CDAT%CROP(I)%FTR(K) + EGW * (UNO - CDAT%CROP(I)%FTR(K))
       CU  = DZ
       EGWA= DZ
       CIR = DZ
       DMD = DZ
       CIRI= DZ
       DMDI= DZ
       !EP  = DZ
       TPOT=DZ
       TACT=DZ
       ANOX_LOSS = DZ
       SOIL_LOSS = DZ
       TSURF_I   = DZ
       TSURF     = DZ
       ADMD_I    = DZ
       ADMD      = DZ
       P         = WBS%PRECIP(F)
       DP        = DZ
       RO        = DZ
       DP_E      = DZ
       RO_E      = DZ
       DO CONCURRENT(J=ONE:WBS%CROP(F)%N) 
           I=WBS%CROP(F)%PNT(ONE,J)
           K=WBS%CROP(F)%PNT(TWO,J)
           !
           !EGW = EGW  + CDAT%CROP(I)%EGW (K)
           !TGW = TGW  + CDAT%CROP(I)%TGW(K)
           !
           AREA= AREA + CDAT%CROP(I)%AREA(K)
           EGWA= EGWA + CDAT%CROP(I)%EGWA(K)
           !
           IF(CDAT%HAS_DEMAND_EXT) THEN
               ADMD_I = ADMD_I + CDAT%CROP(I)%DEMAND_EXT_INI(K)
               ADMD   = ADMD   + CDAT%CROP(I)%DEMAND_EXT(K)
           END IF
           !
           CU_I= CU_I + CDAT%CROP(I)%CU(K)
           CU  = CU   + CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
           ANOX_LOSS = ANOX_LOSS + CDAT%CROP(I)%ANOX_LOSS(K)
           SOIL_LOSS = SOIL_LOSS + CDAT%CROP(I)%SOIL_LOSS(K)
           !
           !P  = P  + CDAT%CROP(I)%PRECIP(K)
           !EP = EP + CDAT%CROP(I)%EP(K)
           DP   = DP   + CDAT%CROP(I)%DPERC(K)
           RO   = RO   + CDAT%CROP(I)%RNOFF(K)
           DP_E = DP_E + CDAT%CROP(I)%DPERC_EXT(K)
           RO_E = RO_E + CDAT%CROP(I)%RNOFF_EXT(K)
           !
           !IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
              TPOT    = TPOT + CDAT%CROP(I)%TGW(K)
              TACT    = TACT + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
              !
              TSURF_I = TSURF_I + CDAT%CROP(I)%TSURF(K)
              TSURF   = TSURF   + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
              !
              CIR = CIR  + CDAT%CROP(I)%CIR (K)
              DMD = DMD  + CDAT%CROP(I)%DEMAND (K)
              CIRI= CIRI + CDAT%CROP(I)%CIR_INI(K)
              IF(CDAT%CROP(I)%EFF(K)>DZ) DMDI= DMDI + CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
           !END IF
           !
       END DO
       !
       BARE_AREA  =DZ
       BARE_EVAP  =DZ
       BARE_EVAP_P=DZ
       !
       IF(CDAT%CHECK_BARE) THEN
          DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
              R = WBS%FID(F)%RC(ONE,K)
              C = WBS%FID(F)%RC(TWO,K)
              !
              IF(CDAT%BARE_FRAC(C,R) > DZ) THEN
                  BARE_AREA  = BARE_AREA   + CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                  BARE_EVAP  = BARE_EVAP   + CDAT%BARE_EVAP(C,R)
                  BARE_EVAP_P= BARE_EVAP_P + CDAT%BARE_EVAP_PRECIP(C,R)
                  CU_I = CU_I + CDAT%BARE_POT_EVAP(C,R)
                  CU   = CU   + CDAT%BARE_EVAP(C,R)
              END IF
          END DO
       END IF
       !
       IF(CDAT%OUT_BYFARM%BINARY) THEN
           IF(WBS%FID(F)%Count == Z) THEN
               WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ
           ELSE
               WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, WBS%FID(F)%AREA, AREA, WBS%IRR_AREA(F), WBS%EFF(F), CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I,ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, WBS%TIRR(F), WBS%TPRECIP(F), WBS%TGWA(F), WBS%EIRR(F), WBS%EPRECIP(F), EGWA, BARE_EVAP, BARE_EVAP_P, P
           END IF
       ELSEIF(WBS%FID(F)%Count == Z) THEN
               !
               WRITE(IU, '(3I7, 32A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, DT, DYEAR, DATE
       ELSE
               WRITE(IU, '(3I7, 32A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, NUM2STR(WBS%FID(F)%AREA), NUM2STR(AREA), NUM2STR(WBS%IRR_AREA(F)), NUM2STR(WBS%EFF(F)), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR ), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP  ), NUM2STR(RO  ), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(WBS%TIRR(F)), NUM2STR(WBS%TPRECIP(F)), NUM2STR(WBS%TGWA(F)), NUM2STR(WBS%EIRR(F)), NUM2STR(WBS%EPRECIP(F)), NUM2STR(EGWA), NUM2STR(BARE_EVAP), NUM2STR(BARE_EVAP_P), NUM2STR(P), DT, DYEAR, DATE
       END IF
       !
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BYCROP(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, I, K, L, R, C
    DOUBLE PRECISION::  AREA, AREA_IRR, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, TSURF_I, TSURF, EI, EP, EGWA, TGWA, BARE_EVAP, BARE_EVAP_P, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, ADMD, ADMD_I, P, DP, RO, DP_E, RO_E, EFF!, TRAN, EGW,TGW ,BARE_AREA, 
    CHARACTER(17):: ZER, DT
    CHARACTER(20):: BARE
    !
    IF(CDAT%OUT_BYCROP%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    BARE = 'BARE_LAND'
    !
    CALL CDAT%OUT_BYCROP%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_BYCROP%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_BYCROP%BINARY) THEN 
            WRITE(CDAT%IOUT,'(A,/A)')'CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), CROP_NAME (20 char), AREA (double), IRRIGATED AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !
            CALL CDAT%OUT_BYCROP%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',L+4)//'AREA   IRRIGATED_AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    AREA       = DZ
    BARE_EVAP  = DZ
    BARE_EVAP_P= DZ
    P          = DZ
    DP         = DZ
    RO         = DZ
    CU_I       = DZ
    CU         = DZ
    IF(CDAT%CHECK_BARE) THEN
          DO CONCURRENT ( R=ONE:CDAT%NROW, C=ONE:CDAT%NCOL, CDAT%BARE_FRAC(C,R) > DZ  )
                AREA       = AREA        + CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                BARE_EVAP  = BARE_EVAP   + CDAT%BARE_EVAP(C,R)
                BARE_EVAP_P= BARE_EVAP_P + CDAT%BARE_EVAP_PRECIP(C,R)
                CU_I = CU_I + CDAT%BARE_POT_EVAP(C,R)
                CU   = CU   + CDAT%BARE_EVAP(C,R)
                !
                P = P + CDAT%BARE_TOT_PRECEP(C,R)
                !
                IF(CDAT%HAS_Pe)  P = P + CDAT%BARE_RNOFF_Peff(C,R)
                !
                IF(CDAT%BARE_PRECEP_EXCESS(C,R) > DZ) THEN
                   !
                   IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                  RO = RO + CDAT%BARE_PRECEP_EXCESS(C,R)
                   ELSE
                                  RO = RO + CDAT%BARE_PRECEP_EXCESS(C,R) * (      CDAT%BARE_FRAC_RUNOFF(C,R))
                                  DP = DP + CDAT%BARE_PRECEP_EXCESS(C,R) * (UNO - CDAT%BARE_FRAC_RUNOFF(C,R))
                   END IF
                END IF
          END DO
    END IF
    !
    IF(CDAT%OUT_BYCROP%BINARY) THEN
        WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,Z,BARE,AREA,DZ,DZ,CU_I,CU,DZ,DZ,DZ,DZ,DZ,DZ,DP,RO,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,BARE_EVAP_P,BARE_EVAP,P
    ELSE
        WRITE(IU, '(3I7, 2x,A, 29A17, 2x,F13.7, 2x,A)') KPER, KSTP, Z, BARE(:L), NUM2STR(AREA), ZER, ZER, NUM2STR(CU_I), NUM2STR(CU), ZER, ZER, ZER, ZER, ZER, ZER, NUM2STR(DP), NUM2STR(RO), ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, NUM2STR(BARE_EVAP_P), NUM2STR(BARE_EVAP), NUM2STR(P), DT, DYEAR, DATE
    END IF
    !
    DO I=ONE, CDAT%NCROP
       AREA= DZ
       AREA_IRR = DZ
       CU_I= DZ   !CU = TGW*CDAT%CROP(I)%FTR(K) + EGW * (UNO - CDAT%CROP(I)%FTR(K))
       CU  = DZ
       EGWA= DZ
       TGWA= DZ
       TSURF_I=DZ
       TSURF=DZ
       TI  = DZ
       TP  = DZ
       EI  = DZ
       EP  = DZ
       CIR = DZ
       DMD = DZ
       CIRI= DZ
       DMDI= DZ
       ANOX_LOSS = DZ
       SOIL_LOSS = DZ
       TPOT=DZ
       TACT=DZ
       ADMD_I = DZ
       ADMD   = DZ
       P      = DZ
       DP     = DZ
       RO     = DZ
       DP_E   = DZ
       RO_E   = DZ
       EFF    = DZ
       DO CONCURRENT(K=ONE:CDAT%CROP(I)%N)
           !
           !EGW = EGW  + CDAT%CROP(I)%EGW (K)
           !TGW = TGW  + CDAT%CROP(I)%TGW(K)
           !
           IF(CDAT%CROP(I)%IRR(K)>Z) AREA_IRR = AREA_IRR + CDAT%CROP(I)%AREA(K)
           AREA= AREA + CDAT%CROP(I)%AREA(K)
           EGWA= EGWA + CDAT%CROP(I)%EGWA(K)
           !
           CU_I= CU_I + CDAT%CROP(I)%CU  (K)
           CU  = CU   + CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K)! old=>+ CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
           ANOX_LOSS = ANOX_LOSS + CDAT%CROP(I)%ANOX_LOSS(K)
           SOIL_LOSS = SOIL_LOSS + CDAT%CROP(I)%SOIL_LOSS(K)
           !
                            P = P + CDAT%CROP(I)%PRECIP(K)
           IF(CDAT%HAS_Pe)  P = P + CDAT%CROP(I)%RNOFF_Peff(K)  !Account for precip removed by concumption limits
           EP   = EP   + CDAT%CROP(I)%EP(K)
           DP   = DP   + CDAT%CROP(I)%DPERC(K)
           RO   = RO   + CDAT%CROP(I)%RNOFF(K)
           DP_E = DP_E + CDAT%CROP(I)%DPERC_EXT(K)
           RO_E = RO_E + CDAT%CROP(I)%RNOFF_EXT(K)
           !
           IF(CDAT%HAS_DEMAND_EXT) THEN
               ADMD_I = ADMD_I + CDAT%CROP(I)%DEMAND_EXT_INI(K)
               ADMD   = ADMD   + CDAT%CROP(I)%DEMAND_EXT(K)
               EFF    = EFF    + CDAT%CROP(I)%DEMAND_EXT(K)*CDAT%CROP(I)%EFF(K)
           END IF
           !
           !IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
              !
              EI  = EI   + CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
              TI  = TI   + CDAT%CROP(I)%TI  (K)
              TP  = TP   + CDAT%CROP(I)%TP  (K)
              !
              TPOT    = TPOT + CDAT%CROP(I)%TGW(K)
              TACT    = TACT + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
              !
              TSURF_I = TSURF_I + CDAT%CROP(I)%TSURF(K)
              TSURF   = TSURF   + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
              !
              TGWA= TGWA + CDAT%CROP(I)%TGWA(K)
              CIR = CIR  + CDAT%CROP(I)%CIR (K)
              DMD = DMD  + CDAT%CROP(I)%DEMAND (K)
              CIRI= CIRI + CDAT%CROP(I)%CIR_INI(K)
              EFF = EFF  + CDAT%CROP(I)%DEMAND(K)*CDAT%CROP(I)%EFF(K)
              IF(CDAT%CROP(I)%EFF(K)>DZ) DMDI= DMDI + CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
           !END IF
           !
       END DO
       !
       IF(EFF > NEARZERO_30) THEN  !EFF = Sum of CIR
           EFF = EFF/(DMD+ADMD)
           IF(EFF>UNO) EFF=UNO
       ELSE
           EFF=DZ
       END IF
       !
       IF(CDAT%OUT_BYCROP%BINARY) THEN
           IF(CDAT%CROP(I)%N == Z) THEN
               WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,I,CDAT%CROP_NAME(I),DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ,DZ
           ELSE
               WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,I,CDAT%CROP_NAME(I),AREA,AREA_IRR,EFF,CU_I,CU,CIRI,CIR,DMDI,DMD,ADMD_I,ADMD,DP,RO,DP_E,RO_E,TPOT,ANOX_LOSS,SOIL_LOSS,TACT,TSURF_I,TSURF,TI,TP,TGWA,EI,EP,EGWA,P
           END IF
       ELSEIF(CDAT%CROP(I)%N == Z) THEN
               !
               WRITE(IU, '(3I7, 2x,A, 29A17, 2x,F13.7, 2x,A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:L), ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, DT, DYEAR, DATE
       ELSE
               WRITE(IU, '(3I7, 2x,A, 29A17, 2x,F13.7, 2x,A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:L), NUM2STR(AREA), NUM2STR(AREA_IRR), NUM2STR(EFF), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), DT, DYEAR, DATE
       END IF
       
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BYFARM_BYCROP(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, J, K, R, C, L
    DOUBLE PRECISION::  AREA, AREA_IRR, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, EI, EP, EGWA, TGWA, BARE_EVAP, BARE_EVAP_P, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, TSURF_I, TSURF,ADMD,ADMD_I, P, DP, RO, DP_E, RO_E, EFF!, TRAN, EGW,TGW BARE_AREA, 
    CHARACTER(17):: ZER, DT
    CHARACTER(20):: BARE
    LOGICAL:: FOUND
    !
    IF(CDAT%OUT_BYFARMCROP%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    BARE = 'BARE_LAND'
    !
    CALL CDAT%OUT_BYFARMCROP%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_BYFARMCROP%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_BYFARMCROP%BINARY) THEN 
            WRITE(CDAT%IOUT,'(A,/A)')'CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (int), CROP ID (int), CROP_NAME (20 char), AREA (double), IRRIGATED AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !
            CALL CDAT%OUT_BYFARMCROP%SET_HEADER( '    PER    STP    WBS   CROP  CROP_NAME'//REPEAT(' ',L+4)//'AREA   IRRIGATED_AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO F=ONE, WBS%NFARM
          IF(WBS%FID(F)%COUNT < ONE) CYCLE
          !   
          AREA       = DZ
          BARE_EVAP  = DZ
          BARE_EVAP_P= DZ     
          P = DZ
          DP = DZ
          RO = DZ
          CU_I  = DZ
          CU    = DZ
          FOUND = FALSE
          IF(CDAT%CHECK_BARE) THEN
             DO K=ONE, WBS%FID(F)%Count
                   R = WBS%FID(F)%RC(ONE,K)
                   C = WBS%FID(F)%RC(TWO,K)
                   IF(CDAT%BARE_FRAC(C,R) > DZ) THEN
                      FOUND = TRUE 
                      AREA       = AREA        + CDAT%BARE_FRAC(C,R) * WBS%AREA(C,R)
                      BARE_EVAP  = BARE_EVAP   + CDAT%BARE_EVAP(C,R)
                      BARE_EVAP_P= BARE_EVAP_P + CDAT%BARE_EVAP_PRECIP(C,R)
                      CU_I = CU_I + CDAT%BARE_POT_EVAP(C,R)
                      CU   = CU   + CDAT%BARE_EVAP(C,R)
                      P    = P + CDAT%BARE_TOT_PRECEP(C,R)
                      !
                      IF(CDAT%HAS_Pe)  P = P + CDAT%BARE_RNOFF_Peff(C,R)
                      !
                      IF(UPLAY(C,R) == Z) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                                     RO = RO + CDAT%BARE_PRECEP_EXCESS(C,R)
                      ELSE
                                     RO = RO + CDAT%BARE_PRECEP_EXCESS(C,R) * (      CDAT%BARE_FRAC_RUNOFF(C,R))
                                     DP = DP + CDAT%BARE_PRECEP_EXCESS(C,R) * (UNO - CDAT%BARE_FRAC_RUNOFF(C,R))
                      END IF
                   END IF
             END DO
          END IF
          !
          IF(FOUND) THEN
            IF(CDAT%OUT_BYFARMCROP%BINARY) THEN
                WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, Z, BARE, AREA, DZ, DZ, CU_I, CU, DZ, DZ, DZ, DZ, DZ, DZ, DP, RO, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, BARE_EVAP_P, BARE_EVAP, P
            ELSE
                WRITE(IU, '(4I7, 2x,A, 29A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, Z, BARE(:L), NUM2STR(AREA), ZER, ZER, NUM2STR(CU_I), NUM2STR(CU), ZER, ZER, ZER, ZER, ZER, ZER, NUM2STR(DP), NUM2STR(RO), ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, NUM2STR(BARE_EVAP_P), NUM2STR(BARE_EVAP), NUM2STR(P), DT, DYEAR, DATE
            END IF
          END IF
          !
          DO I=ONE, CDAT%NCROP
             AREA= DZ
             AREA_IRR = DZ
             CU_I= DZ   !CU = TGW*CDAT%CROP(I)%FTR(K) + EGW * (UNO - CDAT%CROP(I)%FTR(K))
             CU  = DZ
             EGWA= DZ
             TGWA= DZ
             TI  = DZ
             TP  = DZ
             EI  = DZ
             EP  = DZ
             CIR = DZ
             DMD = DZ
             CIRI= DZ
             DMDI= DZ
             ANOX_LOSS = DZ
             SOIL_LOSS = DZ
             TPOT=DZ
             TACT=DZ
             TGWA= DZ
             TSURF_I=DZ
             TSURF  =DZ
             ADMD_I =DZ
             ADMD   =DZ
             P    = DZ
             DP   = DZ
             RO   = DZ
             DP_E = DZ
             RO_E = DZ
             EFF  = DZ
             FOUND = FALSE
             DO CONCURRENT(J=ONE:WBS%CROP(F)%N, WBS%CROP(F)%PNT(ONE,J) == I)
                 K=WBS%CROP(F)%PNT(TWO,J)
                 FOUND = TRUE
                 !
                 !EGW = EGW  + CDAT%CROP(I)%EGW (K)
                 !TGW = TGW  + CDAT%CROP(I)%TGW(K)
                 !
                 IF(CDAT%CROP(I)%IRR(K)>Z) AREA_IRR = AREA_IRR + CDAT%CROP(I)%AREA(K)
                 AREA= AREA + CDAT%CROP(I)%AREA(K)
                 EGWA= EGWA + CDAT%CROP(I)%EGWA(K)
                 !
                 CU_I= CU_I + CDAT%CROP(I)%CU  (K)
                 CU  = CU   + CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
                 ANOX_LOSS = ANOX_LOSS + CDAT%CROP(I)%ANOX_LOSS(K)
                 SOIL_LOSS = SOIL_LOSS + CDAT%CROP(I)%SOIL_LOSS(K)
                 !
                 IF(CDAT%HAS_DEMAND_EXT) THEN
                     ADMD_I = ADMD_I + CDAT%CROP(I)%DEMAND_EXT_INI(K)
                     ADMD   = ADMD   + CDAT%CROP(I)%DEMAND_EXT(K)
                     EFF    = EFF    + CDAT%CROP(I)%DEMAND_EXT(K)*CDAT%CROP(I)%EFF(K)
                 END IF
                                  P = P + CDAT%CROP(I)%PRECIP(K)
                 IF(CDAT%HAS_Pe)  P = P + CDAT%CROP(I)%RNOFF_Peff(K)  !Account for precip removed by concumption limits
                 !
                 EP   = EP   + CDAT%CROP(I)%EP(K)
                 DP   = DP   + CDAT%CROP(I)%DPERC(K)
                 RO   = RO   + CDAT%CROP(I)%RNOFF(K)
                 DP_E = DP_E + CDAT%CROP(I)%DPERC_EXT(K)
                 RO_E = RO_E + CDAT%CROP(I)%RNOFF_EXT(K)
                 !
                 !IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
                    TPOT    = TPOT + CDAT%CROP(I)%TGW(K)
                    TACT    = TACT + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
                    TSURF_I = TSURF_I + CDAT%CROP(I)%TSURF(K)
                    TSURF   = TSURF   + CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
                    EI  = EI   + CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
                    TI  = TI   + CDAT%CROP(I)%TI  (K)
                    TP  = TP   + CDAT%CROP(I)%TP  (K)
                    TGWA= TGWA + CDAT%CROP(I)%TGWA(K)
                    CIR = CIR  + CDAT%CROP(I)%CIR (K)
                    DMD = DMD  + CDAT%CROP(I)%DEMAND (K)
                    CIRI= CIRI + CDAT%CROP(I)%CIR_INI(K)
                    EFF = EFF  + CDAT%CROP(I)%DEMAND(K)*CDAT%CROP(I)%EFF(K)
                    IF(CDAT%CROP(I)%EFF(K)>DZ) DMDI= DMDI + CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
                 !END IF
                 !
             END DO
             !
             IF(EFF > NEARZERO_30) THEN  !EFF = Sum of CIR
                 EFF = EFF/(DMD+ADMD)
                 IF(EFF>UNO) EFF=UNO
             ELSE
                 EFF=DZ
             END IF
             !
             IF(FOUND) THEN
                IF(CDAT%OUT_BYFARMCROP%BINARY) THEN
                        WRITE(IU)                     DATE, DYEAR, DELT, KPER, KSTP, F, I, CDAT%CROP_NAME(I), AREA, AREA_IRR, EFF, CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I, ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, TI, TP, TGWA, EI, EP, EGWA, P
                ELSE
                        WRITE(IU, '(4I7, 2x,A, 29A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, I, CDAT%CROP_NAME(I)(:L), NUM2STR(AREA), NUM2STR(AREA_IRR), NUM2STR(EFF), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), DT, DYEAR, DATE
                END IF
             END IF
          END DO
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_SPECIFIED(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, K, R, C, L, N
    DOUBLE PRECISION:: EFF, AREA, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, EI, EP, EGWA, TGWA, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, TSURF_I, TSURF, ADMD, ADMD_I, P, DP, RO, DP_E, RO_E, HH, GSE, SS, LXX!, TRAN, EGW,TGW  BARE_AREA,BARE_EVAP, BARE_EVAP_P, 
    CHARACTER(17):: ZER, DT
    !CHARACTER(20):: BARE
    !
    IF(.NOT. ALLOCATED(CDAT%OUT_CROP_RC)) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    FILES: DO N=ONE, SIZE(CDAT%OUT_CROP_RC,2)
       !
       CALL CDAT%OUT_CROP(N)%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
       !
       IU = CDAT%OUT_CROP(N)%IU
       IF(IU == Z) CYCLE
       !
       IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
           IF(CDAT%OUT_CROP(N)%BINARY) THEN
               WRITE(CDAT%IOUT,'(A,/A)')'DETAILED CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), CROP_NAME (20 char), WBS ID (int), ROW (int), COL (int), AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double), GW_HEAD (double), GSE (double), ROOT_ELEV (double), LOW_EXTINC_ELEV (double)"
           ELSE
               !
               IF (CDAT%IOUT==IU) WRITE(IU,*)
               !
               CALL CDAT%OUT_CROP(N)%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',L-6)//' WBS    ROW    COL             AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION          GW_HEAD              GSE        ROOT_ELEV  LOW_EXTINC_ELEV             DELT   DYEAR            DATE_START' )
           END IF
       END IF
       !
       R = CDAT%OUT_CROP_RC(ONE,N)
       C = CDAT%OUT_CROP_RC(TWO,N)
       !
       DO I=ONE, CDAT%NCROP
          DO K=ONE, CDAT%CROP(I)%N
             IF(R == CDAT%CROP(I)%RC(ONE,K) .AND. C == CDAT%CROP(I)%RC(TWO,K)) THEN
                !
                F = CDAT%CROP(I)%FID(K) 
                !
                AREA= CDAT%CROP(I)%AREA(K)
                EGWA= CDAT%CROP(I)%EGWA(K)
                !
                IF(WTABLE(C,R) > NEAR_ninf) THEN
                    HH = WTABLE(C,R)
                ELSE
                    HH = HDRY
                END IF
                !
                GSE = CDAT%CROP(I)%GSE(K)
                !
                CU_I= CDAT%CROP(I)%CU  (K)
                CU  = CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
                ANOX_LOSS = CDAT%CROP(I)%ANOX_LOSS(K)
                SOIL_LOSS = CDAT%CROP(I)%SOIL_LOSS(K)
                !
                P = CDAT%CROP(I)%PRECIP(K)
                IF(CDAT%HAS_Pe)  P = P + CDAT%CROP(I)%RNOFF_Peff(K)
                !
                EP   = CDAT%CROP(I)%EP(K)
                DP   = CDAT%CROP(I)%DPERC(K)
                RO   = CDAT%CROP(I)%RNOFF(K)
                DP_E = CDAT%CROP(I)%DPERC_EXT(K)
                RO_E = CDAT%CROP(I)%RNOFF_EXT(K)
                !
                SS  = CDAT%CROP(I)%SS(K) 
                LXX = CDAT%CROP(I)%LXX(K) 
                !
                IF(CDAT%HAS_DEMAND_EXT) THEN
                    ADMD_I = CDAT%CROP(I)%DEMAND_EXT_INI(K)
                    ADMD   = CDAT%CROP(I)%DEMAND_EXT(K)
                ELSE
                    ADMD_I = DZ
                    ADMD   = DZ
                END IF
                !
                IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
                   TPOT    = CDAT%CROP(I)%TGW(K)
                   TACT    = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
                   TSURF_I = CDAT%CROP(I)%TSURF(K)
                   TSURF   = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
                   EI  = CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
                   TI  = CDAT%CROP(I)%TI  (K)
                   TP  = CDAT%CROP(I)%TP  (K)
                   TGWA= CDAT%CROP(I)%TGWA(K)
                   CIR = CDAT%CROP(I)%CIR (K)
                   DMD = CDAT%CROP(I)%DEMAND (K)
                   CIRI= CDAT%CROP(I)%CIR_INI(K)
                   !
                   IF(CDAT%CROP(I)%IRR(K)>Z ) THEN; EFF = CDAT%CROP(I)%EFF(K)
                   ELSE;                            EFF = DZ
                   END IF
                   IF(CDAT%CROP(I)%EFF(K)>DZ) THEN;  DMDI= CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
                   ELSE;                             DMDI= DMD
                   END IF
                ELSE
                   EI  = DZ
                   TI  = DZ
                   TP  = DZ
                   TGWA= DZ
                   CIR = DZ
                   DMD = DZ
                   CIRI= DZ
                   DMDI= DZ
                   EFF = DZ
                   TPOT=DZ
                   TACT=DZ
                END IF
                !
                IF(CDAT%OUT_ALL%BINARY) THEN
                        WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, I, CDAT%CROP_NAME(I), F, R, C, AREA, EFF, CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I, ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, TI, TP, TGWA, EI, EP, EGWA, P, HH, GSE, SS, LXX
                ELSE
                        WRITE(IU, '(3I7, 2x,A, 3I7, 32A17, 2x,F13.7, 2x,A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:L), F, R, C, NUM2STR(AREA), NUM2STR(EFF), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), NUM2STR(HH), NUM2STR(GSE), NUM2STR(SS), NUM2STR(LXX), DT, DYEAR, DATE
                END IF
                IF(.NOT. CDAT%MULTI_CROP_CELLS) CYCLE FILES
            END IF
          END DO
       END DO
    END DO FILES
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_ALL_CROP(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, K, R, C, L
    DOUBLE PRECISION:: EFF, AREA, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, EI, EP, EGWA, TGWA, SOIL_LOSS, ANOX_LOSS, TPOT, TACT, TSURF_I, TSURF, ADMD, ADMD_I, P, DP, RO, DP_E, RO_E, HH, GSE, SS, LXX!, TRAN, EGW,TGW  BARE_AREA,BARE_EVAP, BARE_EVAP_P, 
    CHARACTER(17):: ZER, DT
    !CHARACTER(20):: BARE
    !
    IF(CDAT%OUT_ALL%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    L  = CDAT%CROP_NAME_LEN
    !BARE = 'BARE_LAND'
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL CDAT%OUT_ALL%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_ALL%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_ALL%BINARY) THEN
            WRITE(CDAT%IOUT,'(A,/A)')'DETAILED CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), CROP_NAME (20 char), WBS ID (int), ROW (int), COL (int), AREA (double), EFFICIENCY (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double), GW_HEAD (double), GSE (double), ROOT_ELEV (double), LOW_EXTINC_ELEV (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !
            CALL CDAT%OUT_ALL%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',L-6)//' WBS    ROW    COL             AREA       EFFICIENCY           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION          GW_HEAD              GSE        ROOT_ELEV  LOW_EXTINC_ELEV             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO I=ONE, CDAT%NCROP
      IF(CDAT%PRINT_CROP%LIST(I).NE.Z) THEN
         DO K=ONE, CDAT%CROP(I)%N
             !
             R = CDAT%CROP(I)%RC(ONE,K)
             C = CDAT%CROP(I)%RC(TWO,K)
             F = CDAT%CROP(I)%FID(K) 
             !
             AREA= CDAT%CROP(I)%AREA(K)
             EGWA= CDAT%CROP(I)%EGWA(K)
             !
             IF(WTABLE(C,R) > NEAR_ninf) THEN
                 HH = WTABLE(C,R)
             ELSE
                 HH = HDRY
             END IF
             !
             GSE = CDAT%CROP(I)%GSE(K)
             !
             CU_I= CDAT%CROP(I)%CU  (K)
             CU  = CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
             ANOX_LOSS = CDAT%CROP(I)%ANOX_LOSS(K)
             SOIL_LOSS = CDAT%CROP(I)%SOIL_LOSS(K)
             !
             P = CDAT%CROP(I)%PRECIP(K)
             IF(CDAT%HAS_Pe)  P = P + CDAT%CROP(I)%RNOFF_Peff(K)
             !
             EP   = CDAT%CROP(I)%EP(K)
             DP   = CDAT%CROP(I)%DPERC(K)
             RO   = CDAT%CROP(I)%RNOFF(K)
             DP_E = CDAT%CROP(I)%DPERC_EXT(K)
             RO_E = CDAT%CROP(I)%RNOFF_EXT(K)
             !
             SS  = CDAT%CROP(I)%SS(K) 
             LXX = CDAT%CROP(I)%LXX(K) 
             !
             IF(CDAT%HAS_DEMAND_EXT) THEN
                 ADMD_I = CDAT%CROP(I)%DEMAND_EXT_INI(K)
                 ADMD   = CDAT%CROP(I)%DEMAND_EXT(K)
             ELSE
                 ADMD_I = DZ
                 ADMD   = DZ
             END IF
             !
             IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
                TPOT    = CDAT%CROP(I)%TGW(K)
                TACT    = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
                TSURF_I = CDAT%CROP(I)%TSURF(K)
                TSURF   = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
                EI  = CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
                TI  = CDAT%CROP(I)%TI  (K)
                TP  = CDAT%CROP(I)%TP  (K)
                TGWA= CDAT%CROP(I)%TGWA(K)
                CIR = CDAT%CROP(I)%CIR (K)
                DMD = CDAT%CROP(I)%DEMAND (K)
                CIRI= CDAT%CROP(I)%CIR_INI(K)
                !
                IF(CDAT%CROP(I)%IRR(K)>Z ) THEN; EFF = CDAT%CROP(I)%EFF(K)
                ELSE;                            EFF = DZ
                END IF
                IF(CDAT%CROP(I)%EFF(K)>DZ) THEN;  DMDI= CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
                ELSE;                             DMDI= DMD
                END IF
             ELSE
                EI  = DZ
                TI  = DZ
                TP  = DZ
                TGWA= DZ
                CIR = DZ
                DMD = DZ
                CIRI= DZ
                DMDI= DZ
                EFF = DZ
                TPOT=DZ
                TACT=DZ
             END IF
             !
             IF(CDAT%OUT_ALL%BINARY) THEN
                     WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, I, CDAT%CROP_NAME(I), F, R, C, AREA, EFF, CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I, ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, TI, TP, TGWA, EI, EP, EGWA, P, HH, GSE, SS, LXX
             ELSE
                     WRITE(IU, '(3I7, 2x,A, 3I7, 32A17, 2x,F13.7, 2x,A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:L), F, R, C, NUM2STR(AREA), NUM2STR(EFF), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), NUM2STR(HH), NUM2STR(GSE), NUM2STR(SS), NUM2STR(LXX), DT, DYEAR, DATE
             END IF
         END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_DETAIL_CROP(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, K, R, C, L, LL
    DOUBLE PRECISION:: EFF, AREA, DMDI, DMD, CU_I, CU, CIRI, CIR, TI, TP, EI, EP, EGWA, TGWA, ANOX_LOSS, SOIL_LOSS, TPOT, TACT, TSURF_I, TSURF,ADMD,ADMD_I, P, DP, RO, DP_E, RO_E!, TRAN, EGW,TGW BARE_EVAP, BARE_EVAP, BARE_EVAP_P, 
    CHARACTER(17):: ZER, DT
    DOUBLE PRECISION::  HH, GSE, FTR, FEI, FIESWP, FIESWI, POND, PSI1, PSI2, PSI3, PSI4, SS, LXX, UXX, MXX!, XX
    INTEGER:: GW_INTER, IRR
    !
    IF(CDAT%OUT_DETAIL%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    LL = CDAT%CROP_NAME_LEN
    !BARE = 'BARE_LAND'
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL CDAT%OUT_DETAIL%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_DETAIL%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_DETAIL%BINARY) THEN
            WRITE(CDAT%IOUT,'(A,/A)')'DETAILED CROP INFORMATION BY CROP OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), CROP_NAME (20 char), WBS ID (int), ROW (int), COL (int), LAY (int), GW_INTERACTION_FLAG (int), IRRIGATION_TYPE (int), AREA (double), EFFICIENCY (double), FRAC_TRAN (double), FRAC_EVAP_PRECIP (double), FRAC_EVAP_IRR (double), FRAC_SW_LOSS_PRECIP (double), FRAC_SW_LOSS_IRR (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), ADDED_DEMAND_INI (double), ADDED_DEMAND (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), ADDED_DMD_DPERC (double), ADDED_DMD_RUNOFF (double), TRAN_POT (double),  ANOXIA LOSS (double), SOIL STRESS LOSS (double), TRAN (double), TRAN_SURF_INI (double), TRAN_SURF (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double),  PRECIPITATION (double), POND_DEPTH_TOL (double), PSI_1 (double), PSI_2 (double), PSI_3 (double), PSI_4 (double), GW_HEAD (double), GSE (double), UP_EXTINC_ELEV (double), MID_EXTINC_ELEV (double), ROOT_ELEV (double), LOW_EXTINC_ELEV (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                                                                                                                                                                                                                       
            CALL CDAT%OUT_DETAIL%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',LL-6)//' WBS    ROW    COL    LAY GW_INT    IRR             AREA       EFFICIENCY        FRAC_TRAN    FRAC_EVAP_IRR FRAC_SW_LOSS_PRE FRAC_SW_LOSS_IRR           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND ADDED_DEMAND_INI     ADDED_DEMAND    TOT_DEEP_PERC  TOT_SURF_RUNOFF  ADDED_DMD_DPERC ADDED_DMD_RUNOFF         TRAN_POT      ANOXIA_LOSS SOIL_STRESS_LOSS             TRAN    TRAN_SURF_INI        TRAN_SURF         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW    PRECIPITATION   POND_DEPTH_TOL            PSI_1            PSI_2            PSI_3            PSI_4          GW_HEAD              GSE   UP_EXTINC_ELEV  MID_EXTINC_ELEV        ROOT_ELEV  LOW_EXTINC_ELEV             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO I=ONE, CDAT%NCROP
      IF(CDAT%PRINT_CROP%LIST(I).NE.Z) THEN
        !
        IF(CDAT%HAS_PSI .AND. CDAT%CROP(I)%N > Z) THEN; 
            PSI1 = CDAT%CROP(I)%PSI(ONE  )
            PSI2 = CDAT%CROP(I)%PSI(TWO  )
            PSI3 = CDAT%CROP(I)%PSI(THREE)
            PSI4 = CDAT%CROP(I)%PSI(FOUR )
        ELSE;          
            PSI1 = DZ
            PSI2 = DZ
            PSI3 = DZ
            PSI4 = DZ
        END IF
        !
        DO K=ONE, CDAT%CROP(I)%N
            !
            R = CDAT%CROP(I)%RC(ONE,K)
            C = CDAT%CROP(I)%RC(TWO,K)
            F = CDAT%CROP(I)%FID(K) 
            L = UPLAY(C,R)
            !
            GW_INTER = CDAT%CROP(I)%GW_INTER(K)
            IRR      = CDAT%CROP(I)%IRR(K)
            !
            IF(WTABLE(C,R) > NEAR_ninf) THEN
                HH = WTABLE(C,R)
            ELSE
                HH = HDRY
            END IF
            !
            GSE = CDAT%CROP(I)%GSE(K)
            !
            AREA= CDAT%CROP(I)%AREA(K)
            EGWA= CDAT%CROP(I)%EGWA(K)
            !
            CU_I= CDAT%CROP(I)%CU  (K)
            CU  = CDAT%CROP(I)%TI  (K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EP(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
            ANOX_LOSS = CDAT%CROP(I)%ANOX_LOSS(K)
            SOIL_LOSS = CDAT%CROP(I)%SOIL_LOSS(K)
            TPOT      = CDAT%CROP(I)%TGW(K)
            TACT      = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%TGWA(K)
            !
            P = CDAT%CROP(I)%PRECIP(K)
            IF(CDAT%HAS_Pe)  P = P + CDAT%CROP(I)%RNOFF_Peff(K)
            !
            EP   = CDAT%CROP(I)%EP(K)
            DP   = CDAT%CROP(I)%DPERC(K)
            RO   = CDAT%CROP(I)%RNOFF(K)
            DP_E = CDAT%CROP(I)%DPERC_EXT(K)
            RO_E = CDAT%CROP(I)%RNOFF_EXT(K)
            !
            IF(CDAT%HAS_DEMAND_EXT) THEN
                ADMD_I = CDAT%CROP(I)%DEMAND_EXT_INI(K)
                ADMD   = CDAT%CROP(I)%DEMAND_EXT(K)
            ELSE
                ADMD_I = DZ
                ADMD   = DZ
            END IF
            !
            FTR = CDAT%CROP(I)%FTR(K)
            FEI = CDAT%CROP(I)%FEI(K)
            FIESWP = CDAT%CROP(I)%FIESWP(K)
            FIESWI = CDAT%CROP(I)%FIESWI(K)
            IF(CDAT%HAS_POND) THEN; POND = CDAT%CROP(I)%POND(K)
            ELSE;                   POND = DZ
            END IF
            !
            IF(CDAT%HAS_PSI) THEN
                    UXX = CDAT%CROP(I)%UXX(K)
                    MXX = CDAT%CROP(I)%MXX(K)
            ELSE
                    UXX = CDAT%CROP(I)%GSE(K)
                    MXX = CDAT%CROP(I)%SS(K) 
            END IF
            SS  = CDAT%CROP(I)%SS(K) 
            LXX = CDAT%CROP(I)%LXX(K) 
            !XX  = CDAT%CROP(I)%XX(K) 
            !
            IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
               TSURF_I = CDAT%CROP(I)%TSURF(K)
               TSURF   = CDAT%CROP(I)%TI(K) + CDAT%CROP(I)%TP(K)
               EI  = CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
               TI  = CDAT%CROP(I)%TI  (K)
               TP  = CDAT%CROP(I)%TP  (K)
               TGWA= CDAT%CROP(I)%TGWA(K)
               CIR = CDAT%CROP(I)%CIR (K)
               DMD = CDAT%CROP(I)%DEMAND (K)
               CIRI= CDAT%CROP(I)%CIR_INI(K)
               !
               IF(CDAT%CROP(I)%IRR(K)>Z ) THEN; EFF = CDAT%CROP(I)%EFF(K)
               ELSE;                            EFF = DZ
               END IF
               IF(CDAT%CROP(I)%EFF(K)>DZ) THEN;  DMDI= CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
               ELSE;                             DMDI= DMD
               END IF
            ELSE
               TSURF_I = DZ
               TSURF   = DZ
               EI  = DZ
               TI  = DZ
               TP  = DZ
               TGWA= DZ
               CIR = DZ
               DMD = DZ
               CIRI= DZ
               DMDI= DZ
               EFF = DZ
               TPOT=DZ
               TACT=DZ
            END IF
            !
            IF(CDAT%OUT_DETAIL%BINARY) THEN
                    WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, I, CDAT%CROP_NAME(I), F, R, C, L, GW_INTER, IRR, AREA, EFF, FTR, FEI, FIESWP, FIESWI, CU_I, CU, CIRI, CIR, DMDI, DMD, ADMD_I, ADMD, DP, RO, DP_E, RO_E, TPOT, ANOX_LOSS, SOIL_LOSS, TACT, TSURF_I, TSURF, TI, TP, TGWA, EI, EP, EGWA, P, POND, PSI1, PSI2, PSI3, PSI4, HH, GSE, UXX, MXX, SS, LXX
            ELSE
                    WRITE(IU, '(3I7, 2x,A, 6I7, 43A17, 2x,F13.7, 2x,A)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:LL), F, R, C, L, GW_INTER, IRR, NUM2STR(AREA), NUM2STR(EFF), NUM2STR(FTR), NUM2STR(FEI), NUM2STR(FIESWP), NUM2STR(FIESWI), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(ADMD_I), NUM2STR(ADMD), NUM2STR(DP), NUM2STR(RO), NUM2STR(DP_E), NUM2STR(RO_E), NUM2STR(TPOT), NUM2STR(ANOX_LOSS), NUM2STR(SOIL_LOSS), NUM2STR(TACT), NUM2STR(TSURF_I), NUM2STR(TSURF), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), NUM2STR(P), NUM2STR(POND), NUM2STR(PSI1), NUM2STR(PSI2), NUM2STR(PSI3), NUM2STR(PSI4), NUM2STR(HH), NUM2STR(GSE), NUM2STR(UXX), NUM2STR(MXX), NUM2STR(SS), NUM2STR(LXX), DT, DYEAR, DATE
            END IF
        END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_INPUT(CDAT, WBS, KPER, KSTP)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    INTEGER:: IU, F, I, K, R, C, LL
    DOUBLE PRECISION:: EFF, AREA!, TRAN, EGW,TGW ARE_AREA, , BARE_EVAP_P, EP
    CHARACTER(17):: ZER, FRAC
    DOUBLE PRECISION::  GSE, FTR, FEI, FIESWP, FIESWI, POND, PSI1, PSI2, PSI3, PSI4, SS, LXX
    INTEGER:: GW_INTER, IRR
    !
    IF(CDAT%OUT_INPUT%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    LL = CDAT%CROP_NAME_LEN
    !BARE = 'BARE_LAND'
    !
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SETUP_CROP_EFFICIENCY(CDAT, WBS,FALSE)  ! BECAUSE EFF IS NOT SET UNTIL FM, THIS ALLOWS FOR IT TO BE PRINTED
    !
    CALL CDAT%OUT_INPUT%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_INPUT%IU
    !
    IF(CDAT%OUT_INPUT%BINARY) CALL STOP_ERROR(OUTPUT=CDAT%LOUT,MSG='FMP CROP ERROR. PRINT INPUT OPTION TURNED ON, BUT IT IS SET TO WRITE A BINARY FILE. THIS IS NOT SUPPORTED, PLEASE REMOVE BINARY KEYWORD OR SWITCH UNIT IN NAME FROM DATA(BINARY) TO DATA')
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
          !
          IF (CDAT%IOUT==IU) WRITE(IU,*)
          !
          CALL CDAT%OUT_INPUT%SET_HEADER( '    PER    STP   CROP  CROP_NAME'//REPEAT(' ',LL-6)//' WBS    ROW    COL GW_INT    IRR       EFFICIENCY         FRACTION             AREA        FRAC_TRAN    FRAC_EVAP_PRE    FRAC_EVAP_IRR FRAC_SW_LOSS_PRE FRAC_SW_LOSS_IRR              GSE        ROOT_ELEV  LOW_EXTINC_ELEV   POND_DEPTH_TOL            PSI_1            PSI_2            PSI_3            PSI_4' )
    END IF
    !
    IF(.NOT. CDAT%MULTI_CROP_CELLS) THEN
           FRAC = '1.0'
           FRAC = ADJUSTR(FRAC)
    END IF
    !
    DO I=ONE, CDAT%NCROP
       !
       IF(CDAT%HAS_PSI .AND. CDAT%CROP(I)%N > Z) THEN; 
           PSI1 = CDAT%CROP(I)%PSI(ONE  )
           PSI2 = CDAT%CROP(I)%PSI(TWO  )
           PSI3 = CDAT%CROP(I)%PSI(THREE)
           PSI4 = CDAT%CROP(I)%PSI(FOUR )
       ELSE;          
           PSI1 = DZ
           PSI2 = DZ
           PSI3 = DZ
           PSI4 = DZ
       END IF
       !
       DO K=ONE, CDAT%CROP(I)%N
           !
           R = CDAT%CROP(I)%RC(ONE,K)
           C = CDAT%CROP(I)%RC(TWO,K)
           F = CDAT%CROP(I)%FID(K) 
           !
           GW_INTER = CDAT%CROP(I)%GW_INTER(K)
           IRR      = CDAT%CROP(I)%IRR(K)
           !
           GSE = CDAT%CROP(I)%GSE(K)
           AREA= CDAT%CROP(I)%AREA(K)
           !
           IF(CDAT%MULTI_CROP_CELLS) THEN
               FRAC = NUM2STR( CDAT%CROP(I)%FRAC(K))
               FRAC = ADJUSTR(FRAC)
           END IF
           !
           FTR = CDAT%CROP(I)%FTR(K)
           FEI = CDAT%CROP(I)%FEI(K)
           FIESWP = CDAT%CROP(I)%FIESWP(K)
           FIESWI = CDAT%CROP(I)%FIESWI(K)
           IF(CDAT%HAS_POND) THEN; POND = CDAT%CROP(I)%POND(K)
           ELSE;                   POND = DZ
           END IF
           SS  = CDAT%CROP(I)%SS(K) 
           LXX = CDAT%CROP(I)%LXX(K) 
           !
           IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
              !
              IF(CDAT%CROP(I)%IRR(K)>Z ) THEN; EFF = CDAT%CROP(I)%EFF(K)
              ELSE;                            EFF = DZ
              END IF
           ELSE
              EFF = DZ
           END IF
           !
           WRITE(IU, '(3I7, 2x,A, 5I7, 16A17)') KPER, KSTP, I, CDAT%CROP_NAME(I)(:LL),  F, R, C, GW_INTER, IRR, NUM2STR(EFF), FRAC, NUM2STR(AREA), NUM2STR(FTR), NUM2STR(UNO-FTR), NUM2STR(FEI), NUM2STR(FIESWP), NUM2STR(FIESWI), NUM2STR(GSE), NUM2STR(SS), NUM2STR(LXX), NUM2STR(POND), NUM2STR(PSI1), NUM2STR(PSI2), NUM2STR(PSI3), NUM2STR(PSI4)
       END DO
       
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_BARE(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE, FRINGE)
    CLASS(CROP_DATA),INTENT(INOUT):: CDAT
    TYPE(WBS_DATA),  INTENT(IN   ):: WBS
    INTEGER,         INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,INTENT(IN   ):: DELT
    DOUBLE PRECISION,INTENT(IN   ):: DYEAR
    CHARACTER(*),    INTENT(IN   ):: DATE
    DOUBLE PRECISION, DIMENSION(:,:),CONTIGUOUS,INTENT(IN):: FRINGE
    INTEGER:: IU, R, C
    DOUBLE PRECISION:: AREA, FRAC, BARE_EVAP, BARE_EVAP_P, RO, DP, P, H, GSE, LXX!, TRAN, EGW,TGW 
    CHARACTER(17):: ZER, DT
    !
    IF(CDAT%OUT_BARE%IU == Z) RETURN  !NOTHING TO PRINT OUT
    IF(.NOT. CDAT%CHECK_BARE  ) THEN  !NO BARREN LAND TO WRITE OUT
        !WRITE(CDAT%IOUT,'(A)') 'WARNING: FMP CROP REQUESTED TO WRITE OUT BARREN LAND OUTPUT, BUT THERE IS NO BARREN LAND TO REPORT! (PLEASE SPECIFY A ET REF OR BARREN EVAP).'
        CALL WARNING_MESSAGE(OUTPUT=CDAT%LOUT,MSG='FMP CROP REQUESTED TO WRITE OUT BARREN LAND OUTPUT, BUT THERE IS NO BARREN LAND TO REPORT! (PLEASE SPECIFY A ET REF OR BARREN EVAP).', INLINE=TRUE)
        RETURN  
    END IF
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !DDT = DBLE(DELT)
    !
    CALL CDAT%OUT_BARE%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = CDAT%OUT_BARE%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
        IF(CDAT%OUT_BARE%BINARY) THEN 
            WRITE(CDAT%IOUT,'(A,/A)')'BARE LAND INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), ROW (int), COL (int), CELL_FRACTION (double), AREA (double), PRECIPITATION (double), TOT_DEEP_PERC (double), TOT_SURF_RUNOFF (double), EVAP_PRECIP (double), EVAP_GW (double), GW_HEAD (double), GSE (double), LOW_EXTINC_ELEV (double)"
        ELSE
            !
            IF (CDAT%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                                                    
            CALL CDAT%OUT_BARE%SET_HEADER( '    PER    STP    ROW    COL    CELL_FRACTION             AREA    PRECIPITATION    TOT_DEEP_PERC  TOT_SURF_RUNOFF EVAP_PRECIP_BARE     EVAP_GW_BARE          GW_HEAD              GSE  LOW_EXTINC_ELEV             DELT   DYEAR            DATE_START' )
        END IF
    END IF
    !
    DO C=ONE, WBS%NCOL
    DO R=ONE, WBS%NROW
    IF(CDAT%BARE_FRAC(C,R) > DZ) THEN
        FRAC  = CDAT%BARE_FRAC(C,R)
        AREA  =  FRAC * WBS%AREA(C,R)
        BARE_EVAP  =  CDAT%BARE_EVAP(C,R)
        BARE_EVAP_P=  CDAT%BARE_EVAP_PRECIP(C,R)
        GSE        =  CDAT%BARE_GSE(C,R)
        P = CDAT%BARE_TOT_PRECEP(C,R)
        LXX = GSE-FRINGE(C,R) 
        !
        IF(WTABLE(C,R) <= NEAR_ninf) THEN  ! ALL LAYERS ARE IBOUND=Z SO NO PERMIABLE MATERIAL TO PERCOLATE INTO
                       RO = CDAT%BARE_PRECEP_EXCESS(C,R)
                       DP = DZ
                       CALL SET_NAN(H)
        ELSE
                       RO = CDAT%BARE_PRECEP_EXCESS(C,R) * (      CDAT%BARE_FRAC_RUNOFF(C,R))
                       DP = CDAT%BARE_PRECEP_EXCESS(C,R) * (UNO - CDAT%BARE_FRAC_RUNOFF(C,R))
                       H =  WTABLE(C,R)
        END IF
        IF(CDAT%OUT_BARE%BINARY) THEN
            WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, R, C, FRAC, AREA, P, DP, RO, BARE_EVAP_P, BARE_EVAP, H, GSE, LXX
        ELSE
            WRITE(IU, '(4I7, 11A17, 2x,F13.7, 2x,A)') KPER, KSTP, R, C, NUM2STR(FRAC), NUM2STR(AREA), NUM2STR(P), NUM2STR(DP), NUM2STR(RO), NUM2STR(BARE_EVAP_P), NUM2STR(BARE_EVAP), NUM2STR(H), NUM2STR(GSE), NUM2STR(LXX),DT, DYEAR, DATE
        END IF
    END IF
    END DO
    END DO
    !
  END SUBROUTINE
  !
  !SUBROUTINE PRINT_OUT_ROOT(CDAT, WBS, KPER, KSTP, DELT, DYEAR, DATE)  --NOT COMPLETE
  !  CLASS(CROP_DATA),INTENT(INOUT):: CDAT
  !  TYPE(WBS_DATA),  INTENT(IN   ):: WBS
  !  INTEGER,         INTENT(IN   ):: KPER, KSTP
  !  REAL,            INTENT(IN   ):: DELT
  !  DOUBLE PRECISION,INTENT(IN   ):: DYEAR
  !  CHARACTER(*),    INTENT(IN   ):: DATE
  !  INTEGER:: IU, F, I, K, R, C
  !  DOUBLE PRECISION:: 
  !  CHARACTER(17):: ZER, DT
  !  !
  !  IF(CDAT%OUT_ROOT%IU == Z) RETURN  !NOTHING TO PRINT OUT
  !  !
  !  DT = NUM2STR(DELT)
  !  DT = ADJUSTR(DT)
  !  ZER = '0.0'; ZER = ADJUSTR(ZER)
  !  DDT = DBLE(DELT)
  !  !
  !  CALL CDAT%OUT_ROOT%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
  !  !
  !  IU = CDAT%OUT_ROOT%IU
  !  !
  !  IF( (KPER==ONE .AND. KSTP==ONE) .OR. CDAT%IOUT==IU )  THEN
  !      IF(CDAT%OUT_ROOT%BINARY) THEN 
  !          WRITE(CDAT%IOUT,'(A,/A)')'CROP ROOT INFORMATION TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), CROP ID (int), AREA (double), IRRIGATED AREA (double), CU_INI (double), CU (double), CIR_INI (double), CIR (double), DEMAND_INI (double), DEMAND (double), TRAN_IRR (double), TRAN_PRECIP (double), TRAN_GW (double), EVAP_IRR (double), EVAP_PRECIP (double), EVAP_GW (double)"
  !      ELSE
  !          !
  !          IF (CDAT%IOUT==IU) WRITE(IU,*)
  !          !
  !          CALL CDAT%OUT_ROOT%SET_HEADER( '    PER    STP   CROP             AREA   IRRIGATED_AREA           CU_INI               CU          CIR_INI              CIR       DEMAND_INI           DEMAND         TRAN_IRR      TRAN_PRECIP          TRAN_GW         EVAP_IRR      EVAP_PRECIP          EVAP_GW             DELT   DYEAR            DATE_START' )
  !      END IF
  !  END IF
  !  !
  !  DO I=ONE, CDAT%NCROP
  !     DO K=ONE, CDAT%CROP(I)%N
  !         !
  !         R = CDAT%CROP(I)%RC(ONE,K)
  !         C = CDAT%CROP(I)%RC(TWO,K)
  !         F = CDAT%CROP(I)%FID(K) 
  !         !
  !         AREA= CDAT%CROP(I)%AREA(K)
  !         EGWA= CDAT%CROP(I)%EGWA(K)
  !         !
  !         CU_I= CDAT%CROP(I)%CU  (K)
  !         CU  = CDAT%CROP(I)%TI(K)*(UNO + CDAT%CROP(I)%CECT(K)) + CDAT%CROP(I)%TP(K) + CDAT%CROP(I)%EPPOT(K) + CDAT%CROP(I)%TGWA(K) + CDAT%CROP(I)%EGWA(K) !CDAT%CROP(I)%EGWA(K) !TRAN*CDAT%CROP(I)%FTR(K) + TRAN*(UNO - CDAT%CROP(I)%FTR(K))
  !         EP  = CDAT%CROP(I)%EPPOT(K)
  !         !
  !         IF(CDAT%CROP(I)%NOT_FALLOW(K)) THEN
  !            EI  = CDAT%CROP(I)%TI  (K) * CDAT%CROP(I)%CECT(K)
  !            TI  = CDAT%CROP(I)%TI  (K)
  !            TP  = CDAT%CROP(I)%TP  (K)
  !            TGWA= CDAT%CROP(I)%TGWA(K)
  !            CIR = CDAT%CROP(I)%CIR (K)
  !            DMD = CDAT%CROP(I)%DEMAND (K)
  !            CIRI= CDAT%CROP(I)%CIR_INI(K)
  !            DMDI=DMD
  !            IF(CDAT%CROP(I)%EFF(K)>DZ) DMDI= CDAT%CROP(I)%CIR_INI(K)/CDAT%CROP(I)%EFF(K)
  !         ELSE
  !            EI  = DZ
  !            TI  = DZ
  !            TP  = DZ
  !            TGWA= DZ
  !            CIR = DZ
  !            DMD = DZ
  !            CIRI= DZ
  !            DMDI= DZ
  !         END IF
  !         !
  !         IF(CDAT%OUT_ROOT%BINARY) THEN
  !             IF(CDAT%CROP(I)%N == Z) THEN
  !                 WRITE(IU) DATE, DYEAR, DDT, KPER, KSTP, I, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ, DZ
  !             ELSE
  !                 WRITE(IU) DATE, DYEAR, DDT, KPER, KSTP, I, AREA, WBS%IRR_AREA(F), CU_I, CU, CIRI, CIR, DMDI, DMD, TI, TP, TGWA, EI, EP, EGWA, BARE_EVAP, BARE_EVAP_P
  !             END IF
  !         ELSEIF(CDAT%CROP(I)%N == Z) THEN
  !                 !
  !                 WRITE(IU, '(3I7, 14A17, 2x,F13.7, 2x,A)') KPER, KSTP, I, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, ZER, DT, DYEAR, DATE
  !         ELSE
  !                 WRITE(IU, '(6I7, 14A17, 2x,F13.7, 2x,A)') KPER, KSTP, I, F, R, C, NUM2STR(AREA), NUM2STR(CU_I), NUM2STR(CU), NUM2STR(CIRI), NUM2STR(CIR ), NUM2STR(DMDI), NUM2STR(DMD), NUM2STR(TI), NUM2STR(TP), NUM2STR(TGWA), NUM2STR(EI), NUM2STR(EP), NUM2STR(EGWA), DT, DYEAR, DATE
  !         END IF
  !     END DO
  !     
  !  END DO
  !  !
  !END SUBROUTINE
  !
  PURE FUNCTION RTFUNC(D,M,N,Y)
    !******************************************************************
    !SOLUTION OF ANALYTICAL FUNTION FITTING VERTICAL PRESSURE HEAD
    !DISTRIBUTION OVER DEPTH USING BISECTION METHOD.
    !******************************************************************
    !   SPECIFICATIONS:
    !------------------------------------------------------------------
    DOUBLE PRECISION,INTENT(IN ):: D,M,N,Y
    DOUBLE PRECISION:: RTFUNC    
    !
    !DOUBLE PRECISION:: XACC=1D-5,TOL= 1D-5                           !PRECISION TO SOLVE ROOT AT
    DOUBLE PRECISION:: X1,X2,DX,F,FMID,XMID
    INTEGER:: J
    !
    !1===== DEFINE EXCLUSIONS
    IF(D.LE.UNO) THEN
                     IF(Y < D) THEN
                         RTFUNC=Y
                     ELSE
                         RTFUNC=D
                     END IF
                     RETURN
    ELSEIF (Y.LE.UNO .OR. ABS(D-M).LT.NEARZERO_5 ) THEN
                     RTFUNC=Y
                     RETURN
    END IF
    !
    !2===== DEFINE LATERAL BOUNDS X1 AND X2
    IF(Y.GE.D) THEN
          IF(N > NEARZERO_30) THEN
              X1 = ((LOG(Y/D)/LOG(M/D))**(UNO/N)) * (D-UNO) + UNO - NEARZERO_5
          ELSE
              X1 = ((LOG(Y/D)/LOG(M/D))**(1D30))  * (D-UNO) + UNO - NEARZERO_5
          END IF
          !
          IF(X1 < UNO) X1 = UNO
    ELSE
              X1 = UNO
    END IF
    !
    IF(N > NEARZERO_30) THEN
              X2 = ((DLOG((Y+D)/D)/DLOG(M/D))**(UNO/N)) * (D-UNO) + UNO + NEARZERO_5
    ELSE
              X2 = ((DLOG((Y+D)/D)/DLOG(M/D))**(1D30))  * (D-UNO) + UNO + NEARZERO_5
    END IF
    IF(X2 > Y) X2 = Y + NEARZERO_5
    !
    !3===== FIND THE ROOT OF A FUNCTION KNOWN TO LIE BETWEEN X1 AND X2.
    FMID=FUNC(X2,D,M,N,Y)
    F=FUNC(X1,D,M,N,Y)
    IF(F*FMID.GE.0D0) THEN
        RTFUNC = IEEE_VALUE(F, IEEE_QUIET_NAN)
        RETURN
    END IF
    !
    !3A-----ORIENT SEARCH SO THAT F>0 LIES AT X+DX    
    IF(F < DZ)THEN
        RTFUNC = X1
        DX = X2 - X1
    ELSE
        RTFUNC = X2
        DX = X1 - X2
    ENDIF
    !
    !3B-----BISECTION LOOP
    !       (REDEFINE ROOT, RETURNED AS RTFUNC, UNTIL ITS ACCURACY IS ? XACC)
    DO J=ONE, 250     !----------STOP AFTER 250 ITERATIONS
                 DX = 0.5D0 * DX
                 XMID=RTFUNC+DX
                 FMID=FUNC(XMID,D,M,N,Y)
                 !
                 IF(FMID.LE.DZ) RTFUNC=XMID
                 IF(ABS(DX) < NEARZERO_5 .OR. ABS(FMID).LE.NEARZERO_5) EXIT
                 !
                 IF (J==250) RTFUNC = IEEE_VALUE(F, IEEE_QUIET_NAN)  !  DEBUGGING-----------------------------------------------------
    END DO

  END FUNCTION RTFUNC
  !
  PURE FUNCTION FUNC(X,D,M,N,Y)
    !******************************************************************
    !FORMULATION OF ANALYTICAL FUNTION F(X)=Y AS F(X)-Y=0
    !******************************************************************
    DOUBLE PRECISION,INTENT(IN):: X,D,M,N,Y
    DOUBLE PRECISION:: FUNC
    !
    FUNC = D*((M/D)**(((X-1D0)/(D-1D0))**N)) + X - D - Y
    ! 
  END FUNCTION FUNC
  !
!  PURE ELEMENTAL SUBROUTINE ADJUST_CIR_TO_INCLUDE_PRECIP(CROP)
!    CLASS(CROP_PROP), INTENT(INOUT):: CROP
!    INTEGER:: K
!    !
!    DO CONCURRENT ( K=ONE:CROP%N )
!        !
!        !   NOT FALLOWED CROP         IRRIGATED CROP       PRECIP DOES NOT SATISFY NEEDS
!        IF( CROP%NOT_FALLOW(K) .AND. CROP%IRR(K) > Z .AND. CROP%TPPOT(K) < CROP%TSUR(K) ) THEN
!            !
!            CROP%TSUR(K) = ( CROP%TSUR(K) - CROP%TPPOT(K) ) * (UNO + CROP%CECT(K))  !(TSUR-TP)*(1+ FEI/FTR)  --NOTE THAT IF FTR=0 THEN TGW = 0, SO TSUR =0 WHICH IS < TPPOT SO CONDITION FAILS
!        ELSE
!            CROP%TSUR(K) = DZ
!        END IF
!    END DO
!    !
!  END SUBROUTINE
  !
!  SUBROUTINE GET_CROP_COUNT_AND_NAMES( BL, CDAT, Z, ONE, ERROR )  !=ASSUMES FWEL IS OF SIZE NFARMS  ---Called from FMP main to load FWEL 
!    !USE LINKED_LIST_INSTRUCTION, ONLY:CHARACTER_LINKED_LIST
!    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
!    CLASS(CROP_DATA),            INTENT(INOUT):: CDAT
!    INTEGER,                     INTENT(IN   ):: Z, ONE
!    CHARACTER(5),                INTENT(IN   ):: ERROR
!    TYPE(GENERIC_INPUT_FILE):: FL
!    CHARACTER(:), ALLOCATABLE:: LN
!    INTEGER:: I,LLOC,ISTART,ISTOP,IERR,NCROP
!    CHARACTER(20), DIMENSION(:), ALLOCATABLE:: CROPNAME, CTMP
!    CHARACTER(20):: NAME
!    REAL:: R
!    !
!    CALL BL%LIST%START()
!    CALL BL%LIST%SET_LN()
!    !
!    DO I=1, BL%NLINE
!      IF(  BL%LIST%LN==ERROR ) CALL FILE_IO_ERROR(Z,BL%IU, OUTPUT=BL%IOUT,MSG='UNFORTUNATELY UNKNOWN CROP BLOCK ERROR. PLEASE DOUBLE CHECK BLOCK SET UP.')
!      LLOC=ONE
!      CALL URWORD(BL%LIST%LN,LLOC,ISTART,ISTOP,ONE,I,R,BL%IOUT,BL%IU)
!      !
!      IF ( BL%LIST%LN(ISTART:ISTOP) == 'NAME') THEN
!                 CALL FL%OPEN(LLOC, BL%LIST%LN, BL%IOUT, BL%IU, NOSTOP=.TRUE., REQKEY=.TRUE.)  !GET LOCATION THAT HOLDS LIST OF FEEDFILE NAMES
!                 EXIT
!      END IF
!      !
!      CALL BL%LIST%NEXT()
!      CALL BL%LIST%SET_LN()
!    END DO
!    !
!    IF ( BL%LIST%LN(ISTART:ISTOP) .NE. 'NAME') CALL FILE_IO_ERROR(Z,BL%IU, OUTPUT=BL%IOUT,MSG='FAILED TO IDENTIFY "NAME" KEYWORD WITHIN FMP CROP BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
!    !
!    NCROP=Z
!    !
!    IF(FL%IU == Z .AND. FL%ERROR) THEN  !NAMES ON SAME LINE
!       DO
!         CALL URWORD(BL%LIST%LN,LLOC,ISTART,ISTOP,Z,I,R,BL%IOUT,FL%IU)
!         !
!         IF(BL%LIST%LN(ISTART:ISTOP) == ' ') EXIT
!         !
!         NCROP = NCROP + ONE
!         NAME = BL%LIST%LN(ISTART:ISTOP)
!         !
!         IF(ALLOCATED(CROPNAME)) THEN
!             ALLOCATE(CTMP, SOURCE=[CROPNAME,NAME])
!             CALL MOVE_ALLOC(CTMP,CROPNAME)
!         ELSE
!             ALLOCATE(CROPNAME(ONE), SOURCE=NAME)
!         END IF
!       END DO
!    ELSE             !NAMES IN SEPARATE FILE OR INTERNAL
!       !
!       ALLOCATE(CHARACTER(768)::LN)
!       IF(FL%IU == Z) THEN 
!                          CALL BL%LIST%NEXT()
!                          CALL BL%LIST%SET_LN()
!       END IF
!       DO
!         IF(FL%IU == Z) THEN 
!                            LN = BL%LIST%LN
!                            IF(  BL%LIST%LN==ERROR ) CALL FILE_IO_ERROR(Z,BL%IU, OUTPUT=BL%IOUT,MSG='UNFORTUNATELY UNKNOWN FMP CROP BLOCK ERROR. PLEASE DOUBLE CHECK BLOCK SET UP.')
!         ELSE
!                            CALL READ_TO_DATA(LN, FL%IU)
!         END IF
!         !
!         LLOC = ONE
!         CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,I,R,BL%IOUT,FL%IU)
!         READ(LN(ISTART:ISTOP), *, IOSTAT=IERR) I
!         !
!         IF(IERR.NE.Z .OR. I-NCROP.NE.ONE .OR. LN=='') EXIT
!         !
!         NCROP = I
!         CALL URWORD(LN,LLOC,ISTART,ISTOP,Z,I,R,BL%IOUT,FL%IU)
!         NAME = LN(ISTART:ISTOP)
!         !
!         IF(ALLOCATED(CROPNAME)) THEN
!             ALLOCATE(CTMP, SOURCE=[CROPNAME,NAME])
!             CALL MOVE_ALLOC(CTMP,CROPNAME)
!         ELSE
!             ALLOCATE(CROPNAME(ONE), SOURCE=NAME)
!         END IF
!         !
!         IF(FL%IU == Z) THEN 
!                            CALL BL%LIST%NEXT()
!                            CALL BL%LIST%SET_LN()
!         END IF
!       END DO
!       IF(FL%IU .NE. Z) BACKSPACE(FL%IU)
!    END IF
!    CDAT%NCROP = NCROP
!    !
!    END SUBROUTINE
END MODULE
! 
!#########################################################################################################
! 
