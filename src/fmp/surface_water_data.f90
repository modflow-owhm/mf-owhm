!
!#########################################################################################################
!
MODULE SURFACE_WATER_DATA_FMP_MODULE
  !
  USE FMP_DIMENSION_MODULE, ONLY: FMP_DIMENSION
  !
  USE CONSTANTS
  USE ERROR_INTERFACE,                   ONLY: STOP_ERROR, WARNING_MESSAGE
  USE FILE_IO_INTERFACE,                 ONLY: READ_TO_DATA
  USE PARSE_WORD_INTERFACE,              ONLY: PARSE_WORD_UP
  USE STRINGS,                           ONLY: GET_NUMBER
  USE IS_ROUTINES,                       ONLY: IS_CLOSE
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  USE SFR_INPUT_DATA_TYPES,              ONLY: SFR_NAMED_LOCATION, WBS_SEG_RCH_WT_TFR, SFR_SEGRCH_TFR, SFR_SEG_TFR, FMP_FLOW_REMOVE_SFR
  USE LINKED_LIST_INSTRUCTION,           ONLY: INTEGER_LINKED_LIST
  USE SORT_INTERFACE,                    ONLY: SORT
  USE GENERIC_OUTPUT_FILE_INSTRUCTION,   ONLY: GENERIC_OUTPUT_FILE
  
  USE ULOAD_AND_SFAC_INTERFACE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: SURFACE_WATER_DATA, INITIALIZE_SURFACE_WATER_DATA, SRD_LOC, RETURN_LOC
  !
  TYPE SRD_LOC
      INTEGER:: N=Z
      LOGICAL:: NO_WT = TRUE
      INTEGER,         DIMENSION(:,:),ALLOCATABLE:: SR
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: ISRD       !OLD SRD TFR POSITION
      INTEGER,         DIMENSION(:),  ALLOCATABLE:: ISTRM      !SFR Location
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: WT         !Fraction of dmd tfat each delivery satisfies
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FLOW       !Delivery Flow Rate
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: FLOW_OLD   !Delivery Flow Rate From Preivous Iter
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: LLIM, ULIM !Delivery limits
      DOUBLE PRECISION,DIMENSION(:),  ALLOCATABLE:: MAXDEL     !Delivery limit - Used for output
      DOUBLE PRECISION:: TOT_DMD_INI, TOT_DMD_MET
  END TYPE
  !
  TYPE RETURN_LOC
      LOGICAL:: HAS_RETURN = FALSE
      LOGICAL:: FULLY      = FALSE
      LOGICAL:: BUILD_FULLY= FALSE
      LOGICAL:: LEAVE_MODEL= FALSE
      INTEGER:: N=Z
      INTEGER,         DIMENSION(:,:),ALLOCATABLE:: SR
      INTEGER,         DIMENSION(  :),ALLOCATABLE:: ISRR       !OLD SRD TFR POSITION
      INTEGER,         DIMENSION(  :),ALLOCATABLE:: ISTRM
      DOUBLE PRECISION,DIMENSION(  :),ALLOCATABLE:: WT
      DOUBLE PRECISION,DIMENSION(  :),ALLOCATABLE:: RUNOFF
      DOUBLE PRECISION:: LOST_RUNOFF = DZ
      DOUBLE PRECISION:: TOTLENGTH   = DZ
  END TYPE
  !
  TYPE NRD_VALUES
      DOUBLE PRECISION                          :: DEMAND = DZ
      DOUBLE PRECISION                          :: SUPPLY = DZ
      INTEGER,          DIMENSION(:),ALLOCATABLE:: RANKPOS        ! RANKPOS(1) points to position where RANK 1 deliv is, RANKPOS(2) points to position where RANK 2 deliv is
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: AVALIBLE_WATER
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: CONSUMED_WATER
      !
      CONTAINS
      !
      PROCEDURE, PASS(NRD):: INIT        =>    INIT_NRD_VALUES !(MXNRD)
      PROCEDURE, PASS(NRD):: SETUP       =>   SETUP_NRD_VALUES !(UNDR, SCALE)
      PROCEDURE, PASS(NRD):: INIT_CONSUME=>    INIT_CONSUME_NRD_VALUES !()
      PROCEDURE, PASS(NRD):: CONSUME     => CONSUME_NRD_VALUES !(DEMAND, CONSUMED)
      PROCEDURE, PASS(NRD):: SIZE        =>    SIZE_NRD_VALUES !(MXNRD)
      !
      FINAL:: FINAL_NRD_VALUES
  END TYPE
  !
  TYPE SURFACE_WATER_DATA
      LOGICAL:: HAS_SW = FALSE
      INTEGER:: IOUT=Z, LOUT=Z
      INTEGER:: NFARM = Z
      INTEGER:: NSFR_DELIV  = Z
      INTEGER:: NSFR_RETURN = Z
      INTEGER:: IRRFL = Z
      !INTEGER:: IRDFL = Z
      INTEGER:: MXNRD = Z
      INTEGER:: NSEG = Z
      LOGICAL:: REQ_SFR    = FALSE
      LOGICAL:: HAS_NRD    = FALSE
      LOGICAL:: HAS_SRD    = FALSE
      LOGICAL:: HAS_RET    = FALSE
      LOGICAL:: NRD_IS_RAT = FALSE
      LOGICAL:: HAS_NRD_LOC= FALSE
      LOGICAL:: NORETURNFLOW=FALSE
      LOGICAL:: TFR_READ   = FALSE
      LOGICAL:: ALWAYS_BUILD_FULLY_ROUTED_RETURN = FALSE
      LOGICAL:: BUILD_FULLY_ROUTED_RETURN = FALSE  ! = ANY(BUILD_FRR)
      LOGICAL:: CMD_RUNOFF_PRNT = TRUE
      LOGICAL, DIMENSION(:),   ALLOCATABLE:: RUNOFF_PRNT   ! 0: Printed Before, 1: Not Printed Yet
      LOGICAL, DIMENSION(:),   ALLOCATABLE:: BUILD_FRR
      INTEGER, DIMENSION(:,:), ALLOCATABLE:: H2ORETURN
      LOGICAL, DIMENSION(:),   ALLOCATABLE:: HAS_SRD_WBS
      INTEGER:: NORETURNFLOW_TFR_FLAG = Z                  !0: Not InUse,  1:All Set to NORETURNFLOW, 2:Some WBS set to 1
      !
      DOUBLE PRECISION:: SRD_TOL     = UNO
      INTEGER::          SRD_TOL_CNT = Z
      !
      INTEGER,          DIMENSION(:,:), ALLOCATABLE:: NRD_DP_LOC
      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: NRD_DP
      TYPE(NRD_VALUES), DIMENSION(:),   ALLOCATABLE:: NRD
      !
      TYPE(SRD_LOC),   DIMENSION(:), ALLOCATABLE:: SRDLOC
      TYPE(RETURN_LOC),DIMENSION(:), ALLOCATABLE:: SRRLOC
      !
      !TYPE(LIST_ARRAY_INPUT_INT):: ISRD
      !TYPE(LIST_ARRAY_INPUT_INT):: ISRR
      TYPE(WBS_SEG_RCH_WT_TFR):: ISRD_TFR
      TYPE(WBS_SEG_RCH_WT_TFR):: ISRR_TFR
      !TYPE(SFR_SEGRCH_TFR):: ISRR
      TYPE(LIST_ARRAY_INPUT_INT):: NRD_DP_TFR
      TYPE(LIST_ARRAY_INPUT_INT):: CHOICE
      TYPE(LIST_ARRAY_INPUT_INT):: NORETURNFLOW_TFR
      TYPE(LIST_ARRAY_INPUT    ):: NRD_TFR
      TYPE(LIST_ARRAY_INPUT    ):: DELIV_L_LIM
      TYPE(LIST_ARRAY_INPUT    ):: DELIV_U_LIM
      !
      TYPE(GENERIC_OUTPUT_FILE):: OUT_SFR_SRD_BYWBS
      TYPE(GENERIC_OUTPUT_FILE):: OUT_SFR_SRD
      TYPE(GENERIC_OUTPUT_FILE):: OUT_SFR_SRR
      TYPE(GENERIC_OUTPUT_FILE):: OUT_SFR_RET
      TYPE(GENERIC_OUTPUT_FILE):: OUT_NRD_BUD
      TYPE(GENERIC_OUTPUT_FILE):: OUT_NRD_BUD_WBS
      !
      CONTAINS
      !
      PROCEDURE, PASS(SWF):: NEXT     => SETUP_NEXT_STRESS_PERIOD
      PROCEDURE, PASS(SWF):: NEXT_TS  => SETUP_NEXT_TIME_STEP
      PROCEDURE, PASS(SWF):: SET_NRD_ARRAY
      !PROCEDURE, PASS(SWF):: SET_SRD_ARRAY
      !PROCEDURE, PASS(SWF):: SET_SRR_ARRAY
      PROCEDURE, PASS(SWF):: SET_CHOICE_ARRAY
      PROCEDURE, PASS(SWF):: NO_SURFACE_WATER_DATA!( FDIM, IOUT )
      !
      !!!PROCEDURE, PASS(SWF):: SET_SFR_SRD_FLOW
      PROCEDURE, PASS(SWF):: BUILD_SRD_LOC_FLOW
      PROCEDURE, PASS(SWF):: ADD_SRD_TO_SFR_DELIV!(SFR_DELIV)
      PROCEDURE, PASS(SWF):: SET_DEMAND_INI      !(F, DEMAND)                  ->  Note this sets TOT_DMD_INI and zeros out TOT_DMD_MET
      PROCEDURE, PASS(SWF):: APPLY_SRD_DEMAND    !(F, DEMAND, SFR_DELIV)
      PROCEDURE, PASS(SWF):: APPLY_SRD_SURPLUS   !(F, SURPLUS, STRM)
      PROCEDURE, PASS(SWF):: APPLY_RUNOFF_TO_SFR !(RUNOFF, STRM)
      PROCEDURE, PASS(SWF):: RUNOFF_LOST_CHECK   !()
      !
      PROCEDURE, PASS(SWF):: BUILD_SRR_LOC_FLOW
      PROCEDURE, PASS(SWF):: BUILD_FULLY_ROUTED_RETURN_SRRLOC!(WBS, IDIVAR, ISTRM, STRM)
      !
      PROCEDURE, PASS(SWF):: PRINT_OUT_SFR_SRD!(DMD, STRM, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(SWF):: PRINT_OUT_SFR_SRR!(DMD, STRM, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(SWF):: PRINT_OUT_SFR_RET!(DMD, STRM, KPER, KSTP, DELT, DYEAR, DATE)
      PROCEDURE, PASS(SWF):: PRINT_OUT_SFR_SRD_BYWBS
      !
      PROCEDURE, PASS(SWF):: PRINT_OUT_NRD_BUD
      PROCEDURE, PASS(SWF):: PRINT_OUT_NRD_BUD_BYWBS
      !
      FINAL:: DEALLOCATE_SURFACE_WATER_FINAL
  END TYPE
  !
  CONTAINS
  !
  PURE SUBROUTINE DEALLOCATE_SURFACE_WATER_FINAL(SWF)
    TYPE(SURFACE_WATER_DATA), INTENT(INOUT)::SWF
    CALL DEALLOCATE_SURFACE_WATER(SWF)
  END SUBROUTINE
  !
  PURE SUBROUTINE DEALLOCATE_SURFACE_WATER(SWF)
    CLASS(SURFACE_WATER_DATA), INTENT(INOUT)::SWF
    !
    SWF%IOUT  = Z
    SWF%LOUT  = Z
    SWF%NFARM = Z
    SWF%IRRFL = Z
    !SWF%IRDFL = Z
    SWF%MXNRD = Z
    SWF%NSFR_DELIV = Z
    SWF%NSFR_RETURN= Z
    SWF%HAS_SW      = FALSE
    SWF%REQ_SFR     = FALSE
    SWF%HAS_RET     = FALSE
    SWF%HAS_SRD     = FALSE
    SWF%HAS_NRD     = FALSE
    SWF%NRD_IS_RAT  = FALSE
    SWF%HAS_NRD_LOC = FALSE
    SWF%NORETURNFLOW= FALSE
    SWF%TFR_READ    = FALSE
    SWF%BUILD_FULLY_ROUTED_RETURN = FALSE
    SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN = FALSE
    !
    IF(ALLOCATED(SWF%H2ORETURN )) DEALLOCATE(SWF%H2ORETURN )
    IF(ALLOCATED(SWF%SRDLOC    )) DEALLOCATE(SWF%SRDLOC    )
    IF(ALLOCATED(SWF%SRRLOC    )) DEALLOCATE(SWF%SRRLOC    )
    IF(ALLOCATED(SWF%BUILD_FRR )) DEALLOCATE(SWF%BUILD_FRR )
    IF(ALLOCATED(SWF%NRD_DP_LOC)) DEALLOCATE(SWF%NRD_DP_LOC)
    IF(ALLOCATED(SWF%NRD_DP    )) DEALLOCATE(SWF%NRD_DP    )
    IF(ALLOCATED(SWF%RUNOFF_PRNT)) DEALLOCATE(SWF%RUNOFF_PRNT)
    IF(ALLOCATED(SWF%HAS_SRD_WBS)) DEALLOCATE(SWF%HAS_SRD_WBS)
    IF(ALLOCATED(SWF%NRD        )) DEALLOCATE(SWF%NRD        )
    !
  END SUBROUTINE
  !  
  SUBROUTINE NO_SURFACE_WATER_DATA(SWF, FDIM, IOUT )
    CLASS(SURFACE_WATER_DATA), INTENT(INOUT):: SWF
    TYPE(FMP_DIMENSION),       INTENT(IN   ):: FDIM
    INTEGER,                   INTENT(IN   ):: IOUT
    INTEGER:: F
    !
    CALL DEALLOCATE_SURFACE_WATER(SWF)
    !
    SWF%IOUT = IOUT
    SWF%LOUT = IOUT
    SWF%NFARM= FDIM%NFARM
    IF(SWF%NFARM < ONE) SWF%NFARM = ONE
    SWF%MXNRD= FDIM%MXNRD
    !
    SWF%NORETURNFLOW = TRUE
    SWF%NORETURNFLOW_TFR_FLAG = Z
    !
    ALLOCATE(SWF%H2ORETURN(TWO,SWF%NFARM), SOURCE=Z)
    ALLOCATE(SWF%SRDLOC(SWF%NFARM))
    ALLOCATE(SWF%SRRLOC(SWF%NFARM))
    ALLOCATE(SWF%RUNOFF_PRNT(SWF%NFARM), SOURCE=TRUE)
    ALLOCATE(SWF%HAS_SRD_WBS(SWF%NFARM), SOURCE=TRUE)
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%HAS_SRD_WBS(F) = FALSE
    END DO
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%HAS_RETURN = FALSE
    END DO
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%N = Z
    END DO
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%TOTLENGTH = DZ
    END DO
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%LOST_RUNOFF = DZ
    END DO
    !
  END SUBROUTINE
  !  
  SUBROUTINE INITIALIZE_SURFACE_WATER_DATA( BL, SWF, LINE, FDIM, NSEG )
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(SURFACE_WATER_DATA),   INTENT(INOUT):: SWF
    CHARACTER(*),                INTENT(INOUT):: LINE
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    INTEGER,                     INTENT(IN   ):: NSEG
    CHARACTER(5):: ERROR
    LOGICAL:: EOF, BINARY
    INTEGER:: LLOC, ISTART, ISTOP, F
    INTEGER:: RET_SET
    TYPE(WARNING_TYPE):: WARN_MSG
    !FDIM%SFR_ID%GET(LINE, LLOC, ISTART, ISTOP, SEG, RCH)
    WRITE(BL%IOUT,'(/A/)') 'SURFACEWATER BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    SWF%HAS_SW      = TRUE
    SWF%HAS_RET     = FALSE
    SWF%HAS_SRD     = FALSE
    SWF%HAS_NRD     = FALSE
    SWF%NRD_IS_RAT  = FALSE
    SWF%HAS_NRD_LOC = FALSE
    !
    SWF%BUILD_FULLY_ROUTED_RETURN = FALSE
    SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN = FALSE !IF TRUE THEN SFR RETURN FLOW NETWORK IS SCANNED EVERY STRESS PERIOD INSTEAD OF THE FIRST PERIOD
    !
    SWF%IOUT = BL%IOUT
    SWF%LOUT = BL%IOUT
    SWF%NFARM= FDIM%NFARM
    IF(SWF%NFARM < ONE) SWF%NFARM = ONE
    SWF%MXNRD= FDIM%MXNRD
    SWF%NSFR_DELIV = FDIM%NSFR_DELIV
    SWF%NSFR_RETURN= FDIM%NSFR_RETURN
    SWF%NSEG = NSEG
    SWF%SRD_TOL = 0.02D0  !DIVERIES BETWEEN SOLVER ITERATIONS MUST BE WITHIN 2% OF EACH OTHER
    SWF%NORETURNFLOW_TFR_FLAG = Z
    !
    RET_SET = Z
    ERROR='ERROR'
    CALL WARN_MSG%INIT()
    ALLOCATE(SWF%H2ORETURN(TWO,SWF%NFARM))
    ALLOCATE(SWF%SRDLOC(SWF%NFARM))
    ALLOCATE(SWF%SRRLOC(SWF%NFARM))
    ALLOCATE(SWF%BUILD_FRR(SWF%NFARM))         ! = SWF%SRRLOC(F)%HAS_RETURN .AND. SWF%SRRLOC(F)%FULLY .AND. SWF%SRRLOC(F)%BUILD_FULLY
    ALLOCATE(SWF%RUNOFF_PRNT(SWF%NFARM), SOURCE=TRUE)
    ALLOCATE(SWF%HAS_SRD_WBS(SWF%NFARM), SOURCE=FALSE)
    !
    DO CONCURRENT(LLOC=ONE:SWF%NFARM); 
        SWF%SRRLOC(LLOC)%BUILD_FULLY = TRUE     !FLAG TO INDICATE THAT FRR NETWORK MUST BE BUILT
        SWF%SRRLOC(LLOC)%FULLY       = FALSE    !FLAG TO INDICATE THAT FRR IS IN USE FOR FARM
    END DO
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF, LINE)
    !
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      CASE ("NON_ROUTED_DELIVERY", "NRD")
                        WRITE(BL%IOUT,'(A)') '   NON_ROUTED_DELIVERY (NRD)       KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN NRD_TYPE TRIPLETS OF NRDs.'
                        IF (SWF%MXNRD>Z) THEN
                            !
                            CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                            SELECT CASE ( LINE(ISTART:ISTOP) )
                            CASE("RATE"  ); SWF%NRD_IS_RAT  = TRUE
                            CASE("VOLUME"); CONTINUE
                            CASE DEFAULT;   LLOC=ISTART
                            END SELECT
                            !CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SWF%MXNRD,  MSG='FMP OUTPUT BLOCK ERROR; OUTPUT NON_ROUTED_DELIVERY MUST BE FOLLOWED BY INTEGER "MXNRD" (TOTAL/MAX NUMBER OF NRDs).')
                            CALL SWF%NRD_TFR%INIT('NRD',  LLOC, LINE, BL%IOUT, BL%IU,SWF%NFARM, SWF%MXNRD*THREE, Z, Z, SWF%NFARM, 'BYWBS', SWF%MXNRD, 'BYNRD', SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                            !
                            IF(SWF%NRD_TFR%IS_CONSTANT) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK ERROR. KEYWORD NON_ROUTED_DELIVERY DOES NOT ALLOW THE USE OF KEYWORD "CONSTANT". PLEASE DIRECTLY SPECIFY THE NRD TRIPLETS WITH INTERNAL, EXTERNAL, OPEN/CLOSE, DATAFILE, DATAUNIT.')
                            !
                            SWF%HAS_NRD = SWF%NRD_TFR%INUSE
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "NON_ROUTED_DELIVERY" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NRD_TYPES" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NRD_TYPES WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%MXNRD)//BLN//'NON-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
                        END IF
      CASE ("NRD_INFILTRATION_LOCATION")
                        WRITE(BL%IOUT,'(A)') '   NRD_INFILTRATION_LOCATION    KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD.'
                        !
                        CALL SWF%NRD_DP_TFR%INIT('NRD_DP_LOC', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH, CDIM=[3,0,0]) 
                        !
                        ALLOCATE(SWF%NRD_DP_LOC(FDIM%NCOL,FDIM%NROW), SOURCE=Z)
                        ALLOCATE(SWF%NRD_DP    (FDIM%NCOL,FDIM%NROW))
                        !
      CASE ("NORETURNFLOW", "NO_RETURN_FLOW")
                        WRITE(BL%IOUT,'(A)') '   NORETURNFLOW                    KEYWORD FOUND. ALL RUNOFF WILL BECOME INFILTRATION'
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE(LINE(ISTART:ISTOP))
                        CASE("STATIC","TRANSIENT","LIST")
                                   LLOC = ISTART
                                   CALL SWF%NORETURNFLOW_TFR%INIT('NORETURNFLOW', LLOC, LINE, BL%IOUT, BL%IU, SWF%NFARM, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                                   !
                                   IF( .NOT. SWF%NORETURNFLOW_TFR%TRANSIENT  ) THEN
                                     IF( ALL(SWF%NORETURNFLOW_TFR%LIST == 1) ) THEN
                                                                              CALL SWF%NORETURNFLOW_TFR%DESTROY()
                                                                              SWF%NORETURNFLOW = TRUE
                                     END IF
                                   END IF
                        CASE DEFAULT
                                   SWF%NORETURNFLOW = TRUE
                        END SELECT
                        !
      CASE ("RETURN_FLOW_CHOICES")
                        WRITE(BL%IOUT,'(A)') '   RETURN_FLOW_CHOICES             KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE SEGMENT AND REACH INTEGERS.'
                        CALL SWF%CHOICE%INIT('RET_TYP', LLOC, LINE, BL%IOUT, BL%IU, SWF%NFARM, TWO, Z, Z, SCRATCH=BL%SCRATCH)
                        SWF%REQ_SFR = TRUE
                        !
      CASE ("SEMI_ROUTED_DELIVERY","SRD")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_DELIVERY (SRD)      KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
                        !
                        IF(SWF%NSFR_DELIV > Z) THEN
                            CALL SWF%ISRD_TFR%INIT('ISRD', LLOC, LINE, BL%IOUT, BL%IU, SCRATCH=BL%SCRATCH, DIM=[SWF%NSFR_DELIV], WILD_IN=FDIM%SFR_ID )
                            !
                            SWF%REQ_SFR = TRUE
                            !
                            SWF%HAS_SRD = SWF%ISRD_TFR%INUSE
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "SEMI_ROUTED_DELIVERY" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%NSFR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
                        END IF
                        !
      CASE ("SEMI_ROUTED_DELIVERY_LOWER_LIMIT")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_DELIVERY_LOWER_LIMIT KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
                        !
                        IF(SWF%NSFR_DELIV > Z) THEN
                            CALL SWF%DELIV_L_LIM%INIT('SRD_LOWER_LIM',  LLOC, LINE, BL%IOUT, BL%IU,SWF%NSFR_DELIV, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "SEMI_ROUTED_DELIVERY_LOWER_LIMIT" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%NSFR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
                        END IF
                        !
      CASE ("SEMI_ROUTED_DELIVERY_UPPER_LIMIT")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_DELIVERY_UPPER_LIMIT KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
                        !
                        IF(SWF%NSFR_DELIV > Z) THEN
                            CALL SWF%DELIV_U_LIM%INIT('SRD_UPPER_LIM',  LLOC, LINE, BL%IOUT, BL%IU,SWF%NSFR_DELIV, ONE, Z, Z, SCRATCH=BL%SCRATCH)
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "SEMI_ROUTED_DELIVERY_UPPER_LIMIT" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_DELIV" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_DELIV WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%NSFR_DELIV)//BLN//'SEMI-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
                        END IF
                        !
      CASE ("SEMI_ROUTED_RETURN", "SRR")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_RETURN (SRR)        KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND THEN LIST STYLE INPUT OF SEGMENT AND REACH INTEGERS.'
                        !
                        IF(SWF%NSFR_RETURN > Z) THEN
                            CALL SWF%ISRR_TFR%INIT('ISRR', LLOC, LINE, BL%IOUT, BL%IU, SCRATCH=BL%SCRATCH, DIM=[SWF%NSFR_RETURN], WILD_IN=FDIM%SFR_ID )
                            !
                            SWF%REQ_SFR = TRUE
                        ELSE
                            CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK "SEMI_ROUTED_RETURN" KEYWORD IS ONLY ALLOWED'//BLN//'IF YOU SPECIFY IN THE "GLOBAL DIMENSION" BLOCK THE "NSFR_RETURN" KEYWORD WITH A VALUE GREATER THAN ZERO.'//BLN//'EITHER KEYWORD NSFR_RETURN WAS NOT FOUND IN THE GLOBAL DIMENSION BLOCK OR IT WAS SET TO ZERO OR LESS.'//NL//'ITS CURRENT VALUE IS:'//NUM2STR(SWF%NSFR_RETURN)//BLN//'SEMI-ROUTED RETURN FLOW WILL BE IGNORED DURING SIMULATION.')
                        END IF
                        !!!!CALL SWF%ISRR%INIT('ISRR', LLOC, LINE, BL%IOUT, BL%IU, SCRATCH=BL%SCRATCH, DIM=[TWO, SWF%NFARM], WILD_IN=FDIM%SFR_ID )
                        !!!!SWF%REQ_SFR = TRUE
                        !
      !!!CASE ("ROUTED_DELIVERY_UPPER_DIVERSION")
      !!!                  WRITE(BL%IOUT,'(A)') '   ROUTED_DELIVERY_UPPER_DIVERSION KEYWORD FOUND. IF SEMI-ROUTED DELIVERY NOT SPECIFIED THEN WBS/FARM WILL TAKE FROM UPPER MOST DIVERSION SEGEMENT LOCATED IN WBS.'
      !!!                  SWF%IRDFL = ONE
      !!!                  SWF%REQ_SFR = TRUE
      !!!                  DIV_SET = DIV_SET + ONE
      !!!                  !
      !!!CASE ("ROUTED_DELIVERY_UPPER_REACH")
      !!!                  WRITE(BL%IOUT,'(A)') '   ROUTED_DELIVERY_UPPER_REACH     KEYWORD FOUND.  IF SEMI-ROUTED DELIVERY NOT SPECIFIED THEN WBS/FARM WILL TAKE FROM UPPER MOST REACH LOCATED IN WBS.'
      !!!                  SWF%IRDFL = NEG
      !!!                  SWF%REQ_SFR = TRUE
      !!!                  DIV_SET = DIV_SET + ONE
      !!!                  !
      CASE ("ROUTED_RETURN_ANY_NON_DIVERSION_REACH")
                        WRITE(BL%IOUT,'(A)') '   ROUTED_RETURN_NON_DIVERSION     KEYWORD FOUND. IF SEMI-ROUTED RETURN FLOW NOT SPECIFIED THEN WBS/FARM WILL PRORATE RUNOFF ACROSS ALL NON-DIVERSION REACHES BY LENGTH WITHIN WBS.'
                        SWF%IRRFL = ONE
                        SWF%REQ_SFR = TRUE
                        RET_SET = RET_SET + ONE
                        !
      CASE ("ROUTED_RETURN_ANY_REACH")
                        WRITE(BL%IOUT,'(A)') '   ROUTED_RETURN_ANY_REACH         KEYWORD FOUND. IF SEMI-ROUTED RETURN FLOW NOT SPECIFIED THEN WBS/FARM WILL PRORATE RUNOFF ACROSS ALL REACHES BY LENGTH WITHIN WBS.'
                        SWF%IRRFL = NEG
                        SWF%REQ_SFR = TRUE
                        RET_SET = RET_SET + ONE
                        !
      CASE ("REBUILD_FULLY_ROUTED_RETURN")
                        WRITE(BL%IOUT,'(A)') '   REBUILD_FULLY_ROUTED_RETURN      KEYWORD FOUND. FULLY ROUTED RETURN FLOW NETWORK MAP WILL BE REBUILT AT THE START OF EVERY STRESS PERIOD.'
                        SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN = TRUE
      CASE("SEMI_ROUTED_DELIVERY_CLOSURE_TOLERANCE")
                        WRITE(BL%IOUT,'(A)') '   SEMI_ROUTED_DELIVERY_CLOSURE_TOLERANCE KEYWORD FOUND, NOW LOADING NEW CONVERTGENCE TOLERANCE.'
                        CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,SWF%SRD_TOL,MSG='FMP SURFACE_WATER BLOCK ERROR; FOUND KEYWORD "SEMI_ROUTED_DELIVERY_CLOSURE_TOLERANCE" BUT FAILED TO LOAD THE NUMBER AFTER IT.')
                        !
                        IF(SWF%SRD_TOL < NEARZERO_7) SWF%SRD_TOL= NEARZERO_7
      CASE ("PRINT")
                        BINARY = FALSE
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        IF(LINE(ISTART:ISTOP) == 'BINARY') THEN
                            BINARY = TRUE
                            CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        END IF
                        !
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE ("SFR_DELIVERY_BY_WBS", "SFR_DELIVERY_BYWBS")
                                          CALL SWF%OUT_SFR_SRD_BYWBS%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("SFR_DELIVERY")
                                          CALL SWF%OUT_SFR_SRD%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("SFR_SRR_ONLY")
                                          CALL SWF%OUT_SFR_SRR%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("SFR_RETURN")
                                          CALL SWF%OUT_SFR_RET%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("NRD_BY_WBS", "NRD_BYWBS")
                                          CALL SWF%OUT_NRD_BUD_WBS%OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        CASE ("NRD")
                                          CALL SWF%OUT_NRD_BUD    %OPEN(LINE,LLOC,BL%IOUT,BL%IU,BINARY=BINARY,SPLITMAXCOUNT=11)
                        !
                        CASE DEFAULT;     CALL STOP_ERROR(LINE,BL%IU,BL%IOUT,'FMP SURFACE_WATER BLOCK KEYWORD ERROR. IDENTIFIED KEYWORD "PRINT", BUT THE NEXT WORD WAS NOT IDENTIFIED.'//NL//'WORDS EXPECTED ARE: "SFR_DELIVERY", "SFR_DELIVERY_BY_WBS", "SFR_RETURN", "SFR_SRR_ONLY", "NRD_BUDGET_BY_WBS"')
                        END SELECT
      CASE DEFAULT
                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
                        
      END SELECT
      !
      !IF(DIV_SET > ONE) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK ERROR. YOU CAN ONLY SELECT AT MOST ONE FULLY-ROUTED DELIVERY OPTION, FOUND KEYWORDS "ROUTED_DELIVERY_UPPER_DIVERSION" AND "ROUTED_RETURN_NON_DIVERSION". PROGRAM WILL NOW TERMINATE.')
      !
      IF(RET_SET > ONE) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK ERROR. YOU CAN ONLY SELECT AT MOST ONE FULLY-ROUTED RETURN FLOW OPTION, FOUND KEYWORDS "ROUTED_RETURN_NON_DIVERSION" AND "ROUTED_RETURN_ANY_REACH". PROGRAM WILL NOW TERMINATE.')
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN_MSG%CHECK(HED='FMP SURFACE_WATER BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL)
    !
    IF (SWF%MXNRD > Z .AND. .NOT. SWF%HAS_NRD) THEN
        SWF%MXNRD = Z
        CALL WARNING_MESSAGE(LINE=LINE, INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FMP SURFACE_WATER BLOCK FAILED TO LOCATE "NON_ROUTED_DELIVERY" WHEN THE "GLOBAL DIMENSION" BLOCK SPECIFIED A NONZERO "NRD_TYPES"'//BLN//'THE FOLLOWING IS THE NUMBER OF NRD_TYPES EXPECTED: '//NUM2STR(SWF%MXNRD)//BLN//'NON-ROUTED DILIVERIES WILL BE IGNORED DURING SIMULATION.')
        !CALL SWF%NRD_TFR%INIT('NRD', DZ, BL%IOUT, BL%IU, SWF%NFARM, SWF%MXNRD*THREE, Z, Z)
        !
        !DO CONCURRENT(J=ONE:SWF%NFARM, I=ONE:SWF%MXNRD); SWF%NRD_TFR%ARRAY( (I-ONE)*THREE + TWO, J ) = DBLE(I)
        !END DO
    END IF
    !
    IF(SWF%NSFR_DELIV > Z .AND. SWF%HAS_SRD) THEN
        !
        IF(.NOT. SWF%DELIV_L_LIM%INUSE) CALL SWF%DELIV_L_LIM%INIT('SRD_LOWER_LIM', DZ,   BL%IOUT, BL%IU, SWF%NSFR_DELIV, ONE, Z, Z)
        IF(.NOT. SWF%DELIV_U_LIM%INUSE) CALL SWF%DELIV_U_LIM%INIT('SRD_UPPER_LIM', D100, BL%IOUT, BL%IU, SWF%NSFR_DELIV, ONE, Z, Z)
        
    END IF
    !
    DO CONCURRENT(F=ONE:SWF%NFARM); SWF%SRRLOC(F)%TOTLENGTH = DZ  !INITIALIZE
    END DO
    !
    IF(SWF%NORETURNFLOW) THEN
                             SWF%H2ORETURN = Z
                             SWF%IRRFL     = Z
                             SWF%REQ_SFR   = SWF%HAS_SRD 
                             SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN = FALSE
                             !
                             CALL SWF%CHOICE%DESTROY()
                             CALL SWF%ISRR_TFR%DESTROY()
    ELSE
        SWF%HAS_RET = SWF%ISRR_TFR%INUSE .OR. RET_SET > Z
    END IF
    !
    !IF(.NOT. SWF%ISRD%INUSE) THEN
    !                             CALL SWF%ISRD%INIT('ISRD', Z, BL%IOUT, BL%IU, SWF%NFARM, TWO, Z, Z)
    !                             SWF%ISRD%INUSE = FALSE
    !END IF
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(SWF, FDIM, NEW_FID, SW_SOURCE, SEG_NSTRM, STRM)
    !
    CLASS(SURFACE_WATER_DATA),                    INTENT(INOUT):: SWF
    TYPE(FMP_DIMENSION),                          INTENT(IN   ):: FDIM
    LOGICAL,                                      INTENT(IN   ):: NEW_FID
    LOGICAL, DIMENSION(:),  CONTIGUOUS,           INTENT(IN   ):: SW_SOURCE
    INTEGER, DIMENSION(:),  CONTIGUOUS, OPTIONAL, INTENT(IN   ):: SEG_NSTRM
    REAL,    DIMENSION(:,:),CONTIGUOUS, OPTIONAL, INTENT(IN   ):: STRM
    !
    INTEGER:: I,J,K,F,N
    LOGICAL:: UPDATE, UPDATE_RETURN, NO_RETURN, IS_FULLY_RETURN
    LOGICAL:: SRD_CHK, SRR_CHK
    TYPE(WARNING_TYPE):: WRN
    !
    IF(.NOT. SWF%HAS_SW) RETURN
    !
    IF(SWF%TFR_READ) THEN
        !
        UPDATE = FALSE
        !
        CALL SWF%ISRD_TFR%NEXT(FDIM%SFR_ID)
        CALL SWF%ISRR_TFR%NEXT(FDIM%SFR_ID)
        CALL SWF%DELIV_L_LIM%NEXT()
        CALL SWF%DELIV_U_LIM%NEXT()
        CALL SWF%CHOICE     %NEXT()
        CALL SWF%NRD_TFR    %NEXT()
        CALL SWF%NRD_DP_TFR      %NEXT()
        CALL SWF%NORETURNFLOW_TFR%NEXT()
        !
    ELSE
        !
        UPDATE = TRUE
        !
        SWF%TFR_READ = TRUE
    END IF
    !
    CALL WRN%INIT()
    !
    !------------------------------------------------------------------------
    !
    IF(UPDATE .OR. SWF%DELIV_L_LIM%TRANSIENT) THEN
           DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%DELIV_L_LIM%LIST(K) < DZ );   SWF%DELIV_L_LIM%LIST(K) = DZ
           END DO
    END IF
    !
    IF(UPDATE .OR. SWF%DELIV_U_LIM%TRANSIENT) THEN
           DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%DELIV_U_LIM%LIST(K) < DZ );   SWF%DELIV_U_LIM%LIST(K) = D100
           END DO
    END IF
    !
    !------------------------------------------------------------------------
    !
    IF(SWF%HAS_SRD) THEN
                   SRD_CHK = UPDATE .OR. (SWF%ISRD_TFR%TRANSIENT .AND. .NOT. SWF%ISRD_TFR%TFR%REPEAT)
    ELSE
                   SRD_CHK = FALSE
    END IF
    !
    IF(SWF%ISRR_TFR%INUSE) THEN
                   SRR_CHK = UPDATE .OR. (SWF%ISRR_TFR%TRANSIENT .AND. .NOT. SWF%ISRR_TFR%TFR%REPEAT)
    ELSE
                   SRR_CHK = FALSE
    END IF
    !
    IF(SRD_CHK) THEN  ! SWF%ISRD%ARRAY CHANGED SWF%ISRD%SEGRCH
        !
        DO K=ONE, SWF%NSFR_DELIV
            IF(SWF%ISRD_TFR%WBS(K) > SWF%NFARM) THEN
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
            END IF
            !
            IF(SWF%NSEG < SWF%ISRD_TFR%SR(ONE,K)) THEN
                J = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                CALL WRN%ADD( NUM2STR(J,-5)//BLNK//NUM2STR(I,-5)//'    Semi-Routed DELIVERY Segment is greater then SFR number of segments'//NL )
            END IF
        END DO
        !
    END IF
    !
    IF(SRR_CHK) THEN  ! SWF%ISRD%ARRAY CHANGED SWF%ISRD%SEGRCH
        !
        DO CONCURRENT (K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) < ONE .OR. SWF%ISRR_TFR%WBS(K) > SWF%NFARM)
                SWF%ISRR_TFR%SR(ONE,K) = Z
                SWF%ISRR_TFR%SR(TWO,K) = Z
                SWF%ISRR_TFR%WBS(K)    = Z
                SWF%ISRR_TFR%WT(K)     = DZ
        END DO
        !
        DO K=ONE, SWF%NSFR_RETURN
            !
            IF(SWF%NSEG < SWF%ISRR_TFR%SR(ONE,K)) THEN
                J = SWF%ISRR_TFR%WBS(K)
                I = SWF%ISRR_TFR%SR(ONE,K)
                CALL WRN%ADD( NUM2STR(J,-5)//BLNK//NUM2STR(I,-5)//'    Semi-Routed RETURN Segment is greater then SFR number of segments'//NL )
            END IF
        END DO
        !
    END IF
    !
    IF(WRN%RAISED) CALL WRN%CHECK('SURFACE_WATER BLOCK ERROR.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS AND THE REASON THEY ARE BAD.'//BLN//'WBS  SEGMENT  REASON', OUTPUT=SWF%IOUT, KILL=TRUE)
    !
    IF(SRR_CHK) THEN  ! Check for runoff leaving model requests
        !I,J,K,F,
        DO F=ONE, SWF%NFARM
            N = Z  ! Number of ISRR  points for F
            I = Z  ! Number of SEG=0
            J = Z  ! Number of SEG=0 and WT > 0.0
            
            DO K=ONE, SWF%NSFR_RETURN
                !
                IF( F == SWF%ISRR_TFR%WBS(K) ) THEN
                    N = N + ONE
                    IF(SWF%ISRR_TFR%SR(ONE,K) == Z) THEN
                        I = I + ONE
                        IF(NEGNEARZERO_5 < SWF%ISRR_TFR%WT(K)) J = J + ONE
                    END IF
                END IF
            END DO
            IF( N > ONE .AND. I > Z .AND. I /= J) THEN  ! More than 1 ISRR defined, and some have SEG=0 but does not specify a weight
                DO K=ONE, SWF%NSFR_RETURN
                    !
                    IF( F == SWF%ISRR_TFR%WBS(K)) THEN
                        IF(SWF%ISRR_TFR%SR(ONE,K) == Z .AND. SWF%ISRR_TFR%WT(K) < NEGNEARZERO_5) THEN
                                CALL WRN%ADD( NUM2STR(F,-4)//BLNK//NUM2STR(K))
                        END IF
                    END IF
                END DO
            END IF
            
        END DO
        IF(WRN%RAISED) CALL WRN%CHECK('SURFACE_WATER BLOCK ERROR.'//NL// &
                                      'The following are a list bad FMP Semi-Routed Return points (ISRR).'//NL// &
                                      'If a WBS contains more than one ISRR (multiple return locations defined),'//NL// &
                                      'then any ISRR with segment set to zero (SEG=0) must define a fraction of surface runoff (FRAC).'//BLN// &
                                      'That is, if you have a mixture of return flow points: flow to SFR and flow that leaves the model domain,'//NL// &
                                      'then you have to specify FRAC for each SEG=0 return flow point,'//NL// &
                                      'otherwise FMP does not know how much return flow leaves the model.'//BLN// &
                                      'Note the SEMI_ROUTED_RETURN input is: ISRR, WBS_ID, SEGMENT, REACH, [FRAC]'//BLN// &
                                      'The following need to specify FRAC.'//BLN// &
                                      'WBS  ISRR', OUTPUT=SWF%IOUT, KILL=TRUE)
    END IF
    !
    IF(SRD_CHK) THEN
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z )
            IF( SWF%ISRD_TFR%SR(ONE,K) > Z .AND. SWF%ISRD_TFR%SR(TWO,K) < ONE) THEN
                F = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                J = SWF%ISRD_TFR%SR(TWO,K)
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed DELIVERY Segment is greater then 0, but delivery Reach is  0, the delivery Segment is reset to 0'//NL )
            END IF
        END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z )
            IF( SWF%ISRD_TFR%SR(ONE,K) < ONE) THEN
                F = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                J = SWF%ISRD_TFR%SR(TWO,K)
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed DELIVERY Segment is less than 0, it is reset to 0'//NL )
            END IF
        END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z )
            IF( SWF%ISRD_TFR%SR(TWO,K) < Z) THEN
                F = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                J = SWF%ISRD_TFR%SR(TWO,K)
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed DELIVERY Reach is less than 0, reset to 0'//NL )
            END IF
        END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z )
            IF( SWF%ISRD_TFR%SR(ONE,K) == Z .AND. SWF%ISRD_TFR%SR(TWO,K) > Z) THEN
                F = SWF%ISRD_TFR%WBS(K)
                I = SWF%ISRD_TFR%SR(ONE,K)
                J = SWF%ISRD_TFR%SR(TWO,K)
                SWF%ISRD_TFR%WBS(K)  = Z
                SWF%ISRD_TFR%SR(:,K) = Z
                SWF%ISRD_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed DELIVERY Segment is 0, but delivery Reach is greater than 0, the delivery Reach is reset to 0'//NL )
            END IF
        END DO
        !
    END IF
    !
    IF(SRR_CHK) THEN
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
            IF( SWF%ISRR_TFR%SR(ONE,K) > Z .AND. SWF%ISRR_TFR%SR(TWO,K) < Z) THEN
                SWF%ISRR_TFR%SR(TWO,K) = Z
                !!!F = SWF%ISRR_TFR%WBS(K)
                !!!I = SWF%ISRR_TFR%SR(ONE,K)
                !!!J = SWF%ISRR_TFR%SR(TWO,K)
                !!!SWF%ISRR_TFR%WBS(K)  = Z
                !!!SWF%ISRR_TFR%SR(:,K) = Z
                !!!SWF%ISRR_TFR%WT(K)   = DZ
                !!!CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed RETURN Segment is greater then 0, but return Reach is  0, the return Segment is reset to 0'//NL )
            END IF
        END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
            IF( SWF%ISRR_TFR%SR(ONE,K) < Z) THEN
                F = SWF%ISRR_TFR%WBS(K)
                I = SWF%ISRR_TFR%SR(ONE,K)
                J = SWF%ISRR_TFR%SR(TWO,K)
                SWF%ISRR_TFR%WBS(K)  = Z
                SWF%ISRR_TFR%SR(:,K) = Z
                SWF%ISRR_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed RETURN Segment is less than 0, it is reset to 0'//NL )
            END IF
        END DO
        !
        !!!DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
        !!!    IF( SWF%ISRR_TFR%SR(TWO,K) < Z) THEN
        !!!        F = SWF%ISRR_TFR%WBS(K)
        !!!        I = SWF%ISRR_TFR%SR(ONE,K)
        !!!        J = SWF%ISRR_TFR%SR(TWO,K)
        !!!        SWF%ISRR_TFR%WBS(K)  = Z
        !!!        SWF%ISRR_TFR%SR(:,K) = Z
        !!!        SWF%ISRR_TFR%WT(K)   = DZ
        !!!        CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed RETURN Reach is less than 0, reset to 0'//NL )
        !!!    END IF
        !!!END DO
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z )
            IF( SWF%ISRR_TFR%SR(ONE,K) == Z .AND. SWF%ISRR_TFR%SR(TWO,K) > Z) THEN
                F = SWF%ISRR_TFR%WBS(K)
                I = SWF%ISRR_TFR%SR(ONE,K)
                J = SWF%ISRR_TFR%SR(TWO,K)
                !SWF%ISRR_TFR%WBS(K)  = Z
                SWF%ISRR_TFR%SR(:,K) = Z
                SWF%ISRR_TFR%WT(K)   = DZ
                CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'  Semi-Routed RETURN Segment is 0, but return Reach is greater than 0, the return Reach is reset to 0'//NL )
            END IF
        END DO
        !
        !!!DO F=ONE, SWF%NFARM
        !!!  J = COUNT(SWF%ISRR_TFR%WBS == F)
        !!!  IF( J > ONE ) THEN              ! More than 1 SRR defined for WBS
        !!!    I = Z
        !!!    DO K=ONE, SWF%NSFR_RETURN
        !!!      IF( SWF%ISRR_TFR%WBS(K) == F .AND. SWF%ISRR_TFR%SR(ONE,K) == Z ) THEN
        !!!          I = K
        !!!          EXIT
        !!!      END IF
        !!!    END DO
        !!!    !
        !!!    IF( I > Z ) THEN ! NO FLOW OPTION IS ON, BUT WBS DEFINED MORE THEN ONCE
        !!!        DO CONCURRENT (K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) == F .AND. I.NE.K)
        !!!          IF    (SWF%ISRR_TFR%SR(ONE,K) > Z ) THEN
        !!!              !
        !!!              CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(SWF%ISRR_TFR%SR(1,K),-5)//'   '//NUM2STR(SWF%ISRR_TFR%SR(2,K),-5)//'  Semi-Routed RETURN - WBS had a record with SEGMENT = 0 to indicate flow leaves model, but found additional records with SEGMENT > 0 -- This record is Disabled/Ignored'//NL )
        !!!              !
        !!!          ELSEIF(SWF%ISRR_TFR%SR(ONE,K) == Z) THEN
        !!!              !
        !!!              CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(SWF%ISRR_TFR%SR(1,K),-5)//'   '//NUM2STR(SWF%ISRR_TFR%SR(2,K),-5)//'  Semi-Routed RETURN - WBS has multiple entires defining SEGMENT = 0 to indicate flow leaves model -- This record is Disabled/Ignored'//NL )
        !!!          END IF
        !!!          SWF%ISRR_TFR%WBS(K)  = Z
        !!!          SWF%ISRR_TFR%SR(:,K) = Z
        !!!          SWF%ISRR_TFR%WT(K)   = DZ
        !!!        END DO
        !!!    END IF
        !!!  END IF
        !!!END DO
        !
    END IF
    !
    IF(WRN%RAISED) CALL WRN%CHECK('SURFACE_WATER BLOCK WARNING.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS THAT CONTAINED PROBLEM SEGMENTS THAT HAD TO BE CHANGED.'//BLN//'WBS  SEGMENT REACH  REASON', OUTPUT=SWF%IOUT, INIT=TRUE)
    !
    ! CHECK FOR BAD REACHES
    !
    IF(SRD_CHK) THEN
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_DELIV, SWF%ISRD_TFR%WBS(K) > Z .AND. SWF%ISRD_TFR%SR(ONE,K) > Z )
           I = SWF%ISRD_TFR%SR(ONE,K)            !ISEG
           J = SWF%ISRD_TFR%SR(TWO,K)            !IRCH
           N = SEG_NSTRM(I+ONE) -  SEG_NSTRM(I)  !NRCH
           IF(J > N) THEN
                 F = SWF%ISRD_TFR%WBS(K)
                 SWF%ISRD_TFR%WBS(K)  = Z
                 SWF%ISRD_TFR%SR(:,K) = Z
                 SWF%ISRD_TFR%WT(K)   = DZ
                 CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'    Semi-Routed DELIVERY reach is greater then SFR number of reaches ('//NUM2STR(N)//') for specified segment'//NL )
           END IF
        END DO
    END IF
    !
    IF(SRR_CHK) THEN
        !
        DO CONCURRENT(K=ONE:SWF%NSFR_RETURN, SWF%ISRR_TFR%WBS(K) > Z .AND. SWF%ISRR_TFR%SR(ONE,K) > Z)
           I = SWF%ISRR_TFR%SR(ONE,K)            !ISEG
           J = SWF%ISRR_TFR%SR(TWO,K)            !IRCH
           N = SEG_NSTRM(I+ONE) -  SEG_NSTRM(I)  !NRCH
           IF(J > N) THEN
                 F = SWF%ISRR_TFR%WBS(K)
                 SWF%ISRR_TFR%WBS(K)  = Z
                 SWF%ISRR_TFR%SR(:,K) = Z
                 SWF%ISRR_TFR%WT(K)   = DZ
                 CALL WRN%ADD( NUM2STR(F,-5)//BLNK//NUM2STR(I,-5)//'   '//NUM2STR(J,-5)//'    Semi-Routed RETURN reach is greater then SFR number of reaches ('//NUM2STR(N)//') for specified segment'//NL )
           END IF
        END DO
    END IF
    !
    IF(WRN%RAISED) CALL WRN%CHECK('SURFACE_WATER BLOCK ERROR.'//NL//'THE FOLLOWING ARE A LIST OF BAD FMP-SFR LINKS AND THE REASON THEY ARE BAD.'//BLN//'WBS  SEGMENT REACH  REASON', OUTPUT=SWF%IOUT, KILL=TRUE)
    !
    IF(SWF%CHOICE%INUSE .AND. (UPDATE .OR. SWF%CHOICE%TRANSIENT)) THEN
          DO CONCURRENT(J=ONE:SWF%NFARM)
              IF(SWF%CHOICE%ARRAY(ONE,J) > ONE) SWF%CHOICE%ARRAY(ONE,J) = ONE
              IF(SWF%CHOICE%ARRAY(ONE,J) < Z  ) SWF%CHOICE%ARRAY(ONE,J) = Z
              !
              IF(SWF%CHOICE%ARRAY(TWO,J) > ONE) SWF%CHOICE%ARRAY(TWO,J) = ONE
              IF(SWF%CHOICE%ARRAY(TWO,J) < Z  ) SWF%CHOICE%ARRAY(TWO,J) = Z
          END DO
    END IF
    !
    IF(SWF%NORETURNFLOW_TFR%INUSE .AND. (UPDATE .OR. SWF%NORETURNFLOW_TFR%TRANSIENT) ) THEN
        !
        SWF%NORETURNFLOW_TFR_FLAG = Z
        !
        IF    ( ALL(SWF%NORETURNFLOW_TFR%LIST == ONE) ) THEN
                                                        SWF%NORETURNFLOW_TFR_FLAG = ONE
        ELSEIF( ANY(SWF%NORETURNFLOW_TFR%LIST == ONE) ) THEN
                                                        SWF%NORETURNFLOW_TFR_FLAG = TWO
        END IF
    END IF
    !
    IF(.NOT. SWF%NORETURNFLOW .AND. (UPDATE .OR. SWF%CHOICE%TRANSIENT .OR. SWF%NORETURNFLOW_TFR%TRANSIENT) ) THEN
        !
        !DO CONCURRENT(J=ONE:SWF%NFARM)
        DO J=ONE, SWF%NFARM
          !
          ASSOCIATE(FULY => SWF%H2ORETURN(ONE,J), SEMI => SWF%H2ORETURN(TWO,J))
              !
              IF(SWF%CHOICE%INUSE) THEN
                  FULY = SWF%CHOICE%ARRAY(ONE,J)
                  SEMI = SWF%CHOICE%ARRAY(TWO,J)
              ELSE
                  FULY = ONE
                  SEMI = ONE
              END IF
              !
              IF(FULY == ONE .AND. SWF%IRRFL==Z) FULY = Z
              !
              IF(SWF%NORETURNFLOW_TFR%INUSE) THEN
                  IF(SWF%NORETURNFLOW_TFR%LIST(J)==ONE) THEN
                      FULY = Z
                      SEMI = Z
                  END IF
              END IF
          END ASSOCIATE
        END DO
    END IF
    !
    IF(SWF%NRD_DP_TFR%INUSE ) THEN
        IF(UPDATE .OR. SWF%NRD_DP_TFR%TRANSIENT .OR. SWF%NRD_TFR%TRANSIENT) THEN
            !
            K = SWF%MXNRD*THREE
            SWF%HAS_NRD_LOC = FALSE
            OUTER: DO J=ONE,   SWF%NFARM
                   DO I=THREE, K, THREE
                         IF(SWF%NRD_TFR%ARRAY(I,J) >9.99999999D0) THEN
                             SWF%HAS_NRD_LOC = TRUE
                             EXIT OUTER
                         END IF
                   END DO
            END DO OUTER
        END IF
        !
        IF(SWF%HAS_NRD_LOC .AND. (UPDATE .OR. SWF%NRD_DP_TFR%TRANSIENT)) THEN
            CONTINUE
        END IF
    END IF
    !
    !------------------------------------------------------------------------
    !
    IF(SRD_CHK .and. PRESENT(SEG_NSTRM)) CALL BUILD_SRD_LOC_FLOW(SWF, SW_SOURCE, SEG_NSTRM)
    !
    IF(SRD_CHK .OR. SWF%DELIV_L_LIM%TRANSIENT .OR. SWF%DELIV_U_LIM%TRANSIENT) THEN
        !
        ASSOCIATE(WBS  => SWF%ISRD_TFR%WBS,     &
                  LLIM => SWF%DELIV_L_LIM%LIST, &
                  ULIM => SWF%DELIV_U_LIM%LIST   )
                 !
           DO K=ONE, SWF%NSFR_DELIV
             IF(WBS(K) > Z) THEN
               !
               DO I=ONE, SWF%SRDLOC(WBS(K))%N
                   !
                   IF(SWF%SRDLOC(WBS(K))%ISRD(I) == K) THEN
                       !
                       SWF%SRDLOC(WBS(K))%LLIM(I) = LLIM(K)
                       SWF%SRDLOC(WBS(K))%ULIM(I) = ULIM(K)
                       EXIT
                   END IF
               END DO
             END IF
           END DO
        END ASSOCIATE
    END IF
    !
    !------------------------------------------------------------------------
    !
    UPDATE_RETURN = UPDATE
    !
    IF(.NOT. UPDATE_RETURN .AND. SWF%CHOICE%TRANSIENT) UPDATE_RETURN = TRUE
    IF(.NOT. UPDATE_RETURN .AND. SRR_CHK             ) UPDATE_RETURN = TRUE
    !
    IF(UPDATE_RETURN) THEN
        !
        DO F=ONE, SWF%NFARM
          !
          NO_RETURN       = FALSE
          IS_FULLY_RETURN = FALSE
          !
          IF(SWF%H2ORETURN(1,F) == Z .AND. SWF%H2ORETURN(2,F) == Z) THEN ! NO RETURN FLOW
              !
              NO_RETURN = TRUE
              !
          ELSEIF( SWF%NSFR_RETURN == Z .OR. .NOT. SWF%ISRR_TFR%INUSE .OR. SWF%H2ORETURN(TWO,F) == Z) THEN  !SEMI => SWF%H2ORETURN(TWO,F)
              !
              IF(SWF%IRRFL .NE. Z .AND. SWF%H2ORETURN(ONE,F)==ONE) THEN !FULY => SWF%H2ORETURN(ONE,F)
                  !
                  IS_FULLY_RETURN = TRUE
              ELSE
                  NO_RETURN = TRUE
              END IF
          ELSE
              DO K=ONE, SWF%NSFR_RETURN
                  IF(F == SWF%ISRR_TFR%WBS(K)) THEN    ! .AND. SWF%ISRR_TFR%SR(ONE,K) > Z
                      SWF%SRRLOC(F)%HAS_RETURN  = TRUE
                      SWF%SRRLOC(F)%FULLY       = FALSE
                      EXIT
                  ELSEIF(K == SWF%NSFR_RETURN) THEN
                      IF(SWF%IRRFL .NE. Z .AND. SWF%H2ORETURN(ONE,F)==ONE) THEN !FULY => SWF%H2ORETURN(ONE,F))
                          !
                          IS_FULLY_RETURN = TRUE
                      ELSE
                          NO_RETURN = TRUE
                      END IF
                  END IF
              END DO
          END IF
          !
          IF(IS_FULLY_RETURN) THEN
                 !
                 SWF%SRRLOC(F)%HAS_RETURN  = TRUE
                 !
                 IF(.NOT. SWF%SRRLOC(F)%FULLY) THEN         !NEW FULLY ROUTED NETWORK NEED TO REBUILD IT
                          SWF%SRRLOC(F)%FULLY       = TRUE
                          SWF%SRRLOC(F)%BUILD_FULLY = TRUE
                 END IF
                 !
          ELSEIF(NO_RETURN) THEN                           !DISABLE RETURN FLOW
                          SWF%SRRLOC(F)%HAS_RETURN  = FALSE
                          SWF%SRRLOC(F)%FULLY       = FALSE
                          SWF%SRRLOC(F)%N = Z
          END IF
        END DO
    END IF
    !
    !------------------------------------------------------------------------
    ! 
    IF(SRR_CHK) THEN
                CALL BUILD_SRR_LOC_FLOW(SWF, SEG_NSTRM, STRM)
    ELSE
        DO CONCURRENT (F=ONE:SWF%NFARM, .NOT. SWF%SRRLOC(F)%HAS_RETURN)
                 SWF%SRRLOC(F)%N = Z
        END DO
    END IF
    DO CONCURRENT (F=ONE:SWF%NFARM)
                SWF%SRRLOC(F)%LOST_RUNOFF = DZ
    END DO
    !
    !------------------------------------------------------------------------
    ! 
    IF(SWF%ALWAYS_BUILD_FULLY_ROUTED_RETURN .OR. NEW_FID) THEN
        DO CONCURRENT (F=ONE:SWF%NFARM)
            SWF%BUILD_FRR(F) = SWF%SRRLOC(F)%HAS_RETURN .AND. SWF%SRRLOC(F)%FULLY  !BUILD FRR NETWORK EVEN IF IT HAS ALREADY BEEN BUILT
        END DO
    ELSE
        DO CONCURRENT (F=ONE:SWF%NFARM)
            SWF%BUILD_FRR(F) = SWF%SRRLOC(F)%HAS_RETURN .AND. SWF%SRRLOC(F)%FULLY .AND. SWF%SRRLOC(F)%BUILD_FULLY
        END DO
    END IF
    !
    SWF%BUILD_FULLY_ROUTED_RETURN = ANY(SWF%BUILD_FRR)
    !
  END SUBROUTINE
  !
  SUBROUTINE SETUP_NEXT_TIME_STEP(SWF)
    !
    CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
    INTEGER:: F, I
    DOUBLE PRECISION:: WT_SUM
    !
    DO F=ONE, SWF%NFARM
      !
      SWF%SRDLOC(F)%TOT_DMD_INI = DZ
      SWF%SRDLOC(F)%TOT_DMD_MET = DZ
    END DO
    !
    DO CONCURRENT (F=ONE:SWF%NFARM, SWF%SRDLOC(F)%N > Z) 
      DO CONCURRENT (I = ONE:SWF%SRDLOC(F)%N)
            !
      SWF%SRDLOC(F)%FLOW(I)   = DZ
      SWF%SRDLOC(F)%MAXDEL(I) = DZ
      END DO
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE ADD_SRD_TO_SFR_DELIV(SWF, SFR_DELIV)
    !
    CLASS(SURFACE_WATER_DATA), INTENT(IN):: SWF
    TYPE(FMP_FLOW_REMOVE_SFR), INTENT(INOUT):: SFR_DELIV
    INTEGER:: F, K
    !
    DO CONCURRENT (F=ONE:SWF%NFARM, SWF%SRDLOC(F)%N > Z) 
      DO CONCURRENT (K = ONE:SWF%SRDLOC(F)%N,  SWF%SRDLOC(F)%ISTRM(K) > Z)
            !
            CALL SFR_DELIV%ADD_ISTRM( SWF%SRDLOC(F)%ISTRM(K) )
      END DO
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE BUILD_SRD_LOC_FLOW(SWF, SW_SOURCE, SEG_NSTRM)
    !
    CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
    LOGICAL, DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: SW_SOURCE
    INTEGER, DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: SEG_NSTRM
    INTEGER:: F, K, DIM
    DOUBLE PRECISION:: WT_SUM
    !
    DO F=ONE, SWF%NFARM
      !
      SWF%SRDLOC(F)%TOT_DMD_INI = DZ
      SWF%SRDLOC(F)%TOT_DMD_MET = DZ
      !
      SWF%SRDLOC(F)%N = Z
      SWF%SRDLOC(F)%NO_WT = TRUE
      SWF%HAS_SRD_WBS(F)  = FALSE
      !
      !
      IF(SW_SOURCE(F)) THEN
         !
         DIM = COUNT(F == SWF%ISRD_TFR%WBS)
         !
         IF(DIM > Z) THEN
             SWF%SRDLOC(F)%N = DIM
             SWF%HAS_SRD_WBS(F) = TRUE
             !
             CALL ALLOC(SWF%SRDLOC(F)%ISRD,DIM)         !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%ISTRM,DIM)        !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%WT,DIM)           !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%FLOW,DIM)         !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%FLOW_OLD,DIM)     !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%LLIM,  DIM)       !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%ULIM,  DIM)       !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%MAXDEL,DIM)       !(ARR, N)
             CALL ALLOC(SWF%SRDLOC(F)%SR,TWO,DIM,Z) !(ARR, N, M, DIMCHK)
             !
             DIM = Z
             DO K=ONE, SWF%NSFR_DELIV
                 IF(F == SWF%ISRD_TFR%WBS(K)) THEN
                     DIM = DIM + ONE
                     !
                     SWF%SRDLOC(F)%ISRD(DIM) = K
                     !
                     SWF%SRDLOC(F)%SR(ONE,DIM) = SWF%ISRD_TFR%SR(ONE,K)
                     SWF%SRDLOC(F)%SR(TWO,DIM) = SWF%ISRD_TFR%SR(TWO,K)
                     !
                     SWF%SRDLOC(F)%ISTRM(DIM) = SEG_NSTRM(SWF%ISRD_TFR%SR(ONE,K))  + SWF%ISRD_TFR%SR(TWO,K)
                     !
                     SWF%SRDLOC(F)%WT(DIM) = SWF%ISRD_TFR%WT(K)
                     !
                 END IF
             END DO
             !
             !Assumed SWF%SRDLOC(F)%NO_WT = TRUE
             !
             IF(DIM > ONE) THEN
                IF( ALL(NEGNEARZERO_5 < SWF%SRDLOC(F)%WT .AND. SWF%SRDLOC(F)%WT < NEAR_ONE_5) ) THEN
                    !
                    SWF%SRDLOC(F)%NO_WT = FALSE
                    !
                    DO CONCURRENT(K=ONE:DIM)
                        IF(   SWF%SRDLOC(F)%WT(K) < DZ  ) THEN
                                                               SWF%SRDLOC(F)%WT(K) = DZ
                        ELSEIF(SWF%SRDLOC(F)%WT(K) > UNO) THEN
                                                               SWF%SRDLOC(F)%WT(K) = UNO
                        END IF
                    END DO
                    !
                    WT_SUM = SUM( SWF%SRDLOC(F)%WT )
                    !
                    IF(WT_SUM.NE.UNO) SWF%SRDLOC(F)%WT = SWF%SRDLOC(F)%WT / WT_SUM  !RESCALE TO SUM TO ONE
                    !
                    CALL SORT(SWF%SRDLOC(F)%WT,SWF%SRDLOC(F)%ISTRM, SORT_B=FALSE, DESCEND=TRUE, STABLE=TRUE) !Sort in order of largest weight to smallest. Same weights are processed in the order they are specified (from SORT_B=FALSE, STABLE=TRUE)
                    !
                    !
                    !!!ASSOCIATE(IDX=>SWF%SRDLOC(F)%ISTRM)
                    !!!   DO CONCURRENT(K=ONE:DIM)
                    !!!          SWF%SRDLOC(F)%SEGRCH(ONE,K) = ISTRM(4,IDX(K)) !SEG
                    !!!          SWF%SRDLOC(F)%SEGRCH(TWO,K) = ISTRM(5,IDX(K)) !RCH
                    !!!   END DO
                    !!!END ASSOCIATE
                END IF !( ALL(NEGNEARZERO_5 < SWF%SRDLOC(F)%WT .AND. SWF%SRDLOC(F)%WT < NEAR_ONE_5) ) THEN
             END IF !(DIM > ONE) THEN
         END IF !(DIM > Z) THEN
      END IF !(SW_SOURCE(F)) THEN
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_DEMAND_INI(SWF, F, DEMAND) ! Note this sets TOT_DMD_INI and zeros out TOT_DMD_MET
    CLASS(SURFACE_WATER_DATA), INTENT(INOUT):: SWF
    INTEGER,                   INTENT(IN   ):: F
    DOUBLE PRECISION,          INTENT(IN   ):: DEMAND
    IF(DEMAND > NEARZERO_29) THEN
        SWF%SRDLOC(F)%TOT_DMD_INI = DEMAND
    ELSE
        SWF%SRDLOC(F)%TOT_DMD_INI = DZ
    END IF
    SWF%SRDLOC(F)%TOT_DMD_MET = DZ
  END SUBROUTINE
  !
  SUBROUTINE APPLY_SRD_DEMAND(SWF, F, DEMAND, SFR_DELIV)
    !
    CLASS(SURFACE_WATER_DATA), INTENT(INOUT):: SWF
    INTEGER,                   INTENT(IN   ):: F
    DOUBLE PRECISION,          INTENT(IN   ):: DEMAND
    TYPE(FMP_FLOW_REMOVE_SFR), INTENT(INOUT):: SFR_DELIV
    INTEGER:: K
    DOUBLE PRECISION:: DMD,SUP,DTMP,TOT_FLOW
    !
    IF(DEMAND < NEARZERO_29 .OR. SWF%SRDLOC(F)%N < ONE) THEN     ! Demand too small to account for or no SRD to supply demand
                       DO K=ONE, SWF%SRDLOC(F)%N
                                 SWF%SRDLOC(F)%FLOW(K) = DZ
                       END DO
                       RETURN
    END IF
    !
    ASSOCIATE(         DIM => SWF%SRDLOC(F)%N,           &
                      NO_WT=> SWF%SRDLOC(F)%NO_WT,       &
               TOT_DMD_MET => SWF%SRDLOC(F)%TOT_DMD_MET, &
                      FLOW => SWF%SRDLOC(F)%FLOW,        &
                      LLIM => SWF%SRDLOC(F)%LLIM,        &
                      ULIM => SWF%SRDLOC(F)%ULIM,        &
                    MAXDEL => SWF%SRDLOC(F)%MAXDEL,      &
                     ISTRM => SWF%SRDLOC(F)%ISTRM,       &
                        WT => SWF%SRDLOC(F)%WT)
      DMD = DEMAND
      IF    (DIM == ONE) THEN
                               CALL SFR_DELIV%APPLY_DMD(ISTRM(ONE), DMD, TOT_DMD_MET, LLIM(ONE), ULIM(ONE), MAXDEL(ONE))
                               FLOW(ONE) = TOT_DMD_MET
      ELSEIF(DIM  > ONE) THEN
          !
          DO CONCURRENT(K=ONE:DIM); FLOW(K) = DZ
          END DO
          !
          TOT_FLOW = DZ
          DO K=ONE, DIM
             !
             CALL SFR_DELIV%SET_TO_INFLOW(ISTRM(K), DTMP, LLIM(K), ULIM(K))
             !
             TOT_FLOW = TOT_FLOW + DTMP
          END DO
          !
          IF(DEMAND > TOT_FLOW) THEN  !SRD WILL NEVER MEET DEMAND
              !
              DO K=ONE, DIM
                  !
                  CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DMD, SUP, LLIM(K), ULIM(K), MAXDEL(K))
                  !
                  FLOW(K)     = FLOW(K)     + SUP
                  TOT_DMD_MET = TOT_DMD_MET + SUP
                  !
                  DMD = DMD - SUP
              END DO
              !
          ELSEIF(NO_WT) THEN !REMOVE DEMAND IN ORDER
              !
              DO K=ONE, DIM
                  !
                  CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DMD, SUP, LLIM(K), ULIM(K), MAXDEL(K))
                  !
                  FLOW(K)     = FLOW(K)     + SUP
                  TOT_DMD_MET = TOT_DMD_MET + SUP
                  !
                  DMD = DMD - SUP
                  !
              END DO
          ELSE
              DO K=ONE, DIM !FIRST PASS
                  !
                  DTMP = DEMAND * WT(K)
                  !
                  CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DTMP, SUP, LLIM(K), ULIM(K), MAXDEL(K))
                  !
                  FLOW(K)     = FLOW(K)     + SUP
                  TOT_DMD_MET = TOT_DMD_MET + SUP
                  !
                  DMD = DMD - SUP
              END DO
              !
              IF(DEMAND - TOT_DMD_MET > NEARZERO_29) THEN  !NOT FULL MET, UPDATE AVAILIBLE FLOW
                  !
                  TOT_FLOW = DZ
                  DO K=ONE, DIM
                     TOT_FLOW = TOT_FLOW + SFR_DELIV%GET_INFLOW(ISTRM(K))
                  END DO
                  !
                  IF(TOT_FLOW > NEARZERO_29) THEN
                      !
                      TOT_FLOW = DMD / TOT_FLOW !FRACTION OF DEMAND == USED FOR DMD * (SFR_DELIV%GET_INFLOW(ISTRM(K))/TOT_FLOW) -- BUT INSTEAD HOLDING DMD/TOT_INFLOW
                      !
                      DO K=ONE, DIM !SECOND PASS
                          !
                          DTMP = SFR_DELIV%GET_INFLOW(ISTRM(K)) * TOT_FLOW  ! TOT_FLOW = DMD / TOT_FLOW
                          !
                          IF(DTMP > NEARZERO_29) THEN
                              CALL SFR_DELIV%APPLY_DMD(ISTRM(K), DTMP, SUP, LLIM(K), ULIM(K))
                              !
                              FLOW(K)     = FLOW(K)     + SUP
                              TOT_DMD_MET = TOT_DMD_MET + SUP
                              !
                              DMD = DMD - SUP
                              IF(DMD < NEARZERO_29) EXIT
                          END IF
                          !
                      END DO
                  END IF
              END IF
          END IF
      END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  SUBROUTINE APPLY_SRD_SURPLUS(SWF, F, SURPLUS, STRM)
    !
    CLASS(SURFACE_WATER_DATA),       INTENT(INOUT):: SWF
    INTEGER,                         INTENT(IN   ):: F
    DOUBLE PRECISION,                INTENT(IN   ):: SURPLUS
    REAL,DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: STRM
    INTEGER:: I, K
    DOUBLE PRECISION:: DTMP
    !
    ASSOCIATE(  DIM => SWF%SRDLOC(F)%N,       &
               FLOW => SWF%SRDLOC(F)%FLOW,    &
          LOWER_LIM => SWF%SRDLOC(F)%LLIM,    &
          UPPER_LIM => SWF%SRDLOC(F)%ULIM,    &
             MAXDEL => SWF%SRDLOC(F)%MAXDEL,  &
              ISTRM => SWF%SRDLOC(F)%ISTRM    )
              !
      DO K=ONE, DIM 
          !
          I = ISTRM(K)
          !
          MAXDEL(K) = STRM(10,I)
          !
          IF(MAXDEL(K) > UPPER_LIM(K)) MAXDEL(K) = UPPER_LIM(K)
          !
          IF(MAXDEL(K) <= LOWER_LIM(K)) THEN
             MAXDEL(K) = DZ
          ELSE
             MAXDEL(K) = MAXDEL(K) - LOWER_LIM(K)
          END IF
          !
          IF(MAXDEL(K) < DZ) MAXDEL(K) = DZ
      END DO
      ! 
      IF(DIM == ONE) THEN
          !
          I = ISTRM(ONE)
          !
          STRM(12,I) = STRM(12,I) + SURPLUS
          !
          IF(SURPLUS < FLOW(ONE)) THEN
              FLOW(ONE) = FLOW(ONE) - SURPLUS
          ELSE
              FLOW(ONE) = DZ
          END IF
          !
      ELSEIF(DIM  > ONE) THEN
          !
          IF    (DIM == ONE  ) THEN; DTMP = UNO
          ELSEIF(DIM == TWO  ) THEN; DTMP = HALF
          ELSEIF(DIM == THREE) THEN; DTMP = THIRD
          ELSEIF(DIM == FOUR ) THEN; DTMP = FOURTH
          ELSEIF(DIM == FIVE ) THEN; DTMP = FIFTH
          ELSE;                      DTMP = UNO / DBLE(DIM)
          END IF
          !
          DTMP = DTMP * SURPLUS
          !
          DO CONCURRENT (K=ONE:DIM)
             IF    (DTMP < FLOW(K)) THEN
                 FLOW(K) = FLOW(K) - DTMP
             ELSE
                 FLOW(K) = DZ
             END IF
          END DO
          !
          DO K=ONE, DIM 
              !
              I = ISTRM(K)
              !
              STRM(12,I) = STRM(12,I) + DTMP
              !
          END DO
      END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  SUBROUTINE BUILD_SRR_LOC_FLOW(SWF, SEG_NSTRM, STRM)
    !
    CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
    INTEGER, DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: SEG_NSTRM
    REAL,    DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: STRM
    INTEGER:: F, K, IRCH, ISTRM, NRCH, S, DIM
    DOUBLE PRECISION:: WT_SUM, LN_SUM
    !
    DO F=ONE, SWF%NFARM
       IF    ( .NOT. SWF%SRRLOC(F)%HAS_RETURN) THEN
             !
             SWF%SRRLOC(F)%N = Z
             !
       ELSEIF(       SWF%SRRLOC(F)%HAS_RETURN  .AND. .NOT. SWF%SRRLOC(F)%FULLY) THEN
         !
         DIM = Z
         DO K=ONE, SWF%NSFR_RETURN
             IF(F == SWF%ISRR_TFR%WBS(K)) THEN
                 IF( SWF%ISRR_TFR%SR(ONE,K) == Z .OR. SWF%ISRR_TFR%SR(TWO,K)  > Z) THEN ! =Z INDICATES RETURN FLOW LEAVES MODEL; >Z INDICATES SINGLE REACH 
                                                 DIM = DIM + ONE
                 ELSE !OR USE ALL REACHES
                                                 S    = SWF%ISRR_TFR%SR(ONE,K)
                                                 NRCH = SEG_NSTRM(S+ONE) - SEG_NSTRM(S)
                                                 DIM  = DIM + NRCH
                 END IF
             END IF
         END DO
         !
         SWF%SRRLOC(F)%N = DIM
         SWF%SRRLOC(F)%TOTLENGTH = DZ
         SWF%SRRLOC(F)%LEAVE_MODEL = DIM == Z
         !
         IF(DIM > Z) THEN      
             CALL ALLOC(SWF%SRRLOC(F)%WT,    DIM)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%ISTRM, DIM)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%RUNOFF,DIM)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%ISRR,  DIM)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%SR,TWO,DIM,Z) !(ARR, N, M, DIMCHK)
             !
             DIM = Z
             DO K=ONE, SWF%NSFR_RETURN
                 IF(F == SWF%ISRR_TFR%WBS(K)) THEN
                     S     = SWF%ISRR_TFR%SR(ONE,K)
                     IRCH  = SWF%ISRR_TFR%SR(TWO,K)
                     !ISTRM = SEG_NSTRM(S)
                     !
                     IF( S == Z ) THEN          !Segment not defined, so user wants the runoff to leave the model
                         !
                         DIM = DIM + ONE
                         !
                         SWF%SRRLOC(F)%ISTRM(DIM) = Z
                         SWF%SRRLOC(F)%WT(DIM)    = SWF%ISRR_TFR%WT(K)
                         !
                         SWF%SRRLOC(F)%SR(:,DIM) = Z
                         !
                         SWF%SRRLOC(F)%ISRR(DIM) = K
                     ELSEIF( IRCH > Z ) THEN
                         !
                         DIM = DIM + ONE
                         !
                         SWF%SRRLOC(F)%ISTRM(DIM) = SEG_NSTRM(S) + IRCH  !ISTRM LOCATION IN SFR
                         SWF%SRRLOC(F)%WT(DIM)    = SWF%ISRR_TFR%WT(K)
                         !
                         SWF%SRRLOC(F)%SR(ONE,DIM) = S
                         SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                         !
                         SWF%SRRLOC(F)%ISRR(DIM) = K
                     ELSE
                         ISTRM = SEG_NSTRM(S)
                         NRCH  = SEG_NSTRM(S+ONE) - ISTRM
                         !
                         IF    (NRCH == ONE) THEN  !ONLY ONE REACH IN SEGMENET
                                !
                                IRCH = ONE
                                DIM  = DIM + ONE
                                SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH  
                                SWF%SRRLOC(F)%WT(DIM)    = SWF%ISRR_TFR%WT(K)
                                !
                                SWF%SRRLOC(F)%SR(ONE,DIM) = S
                                SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                                !
                                SWF%SRRLOC(F)%ISRR(DIM) = K
                                !
                         ELSEIF( SWF%ISRR_TFR%WT(K) < NEGNEARZERO_5) THEN !IMPLIES LENGTH WEIGHTING
                             DO IRCH = ONE, NRCH
                                DIM = DIM + ONE
                                SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH  !ADD INDEX FOR EACH REACH
                                SWF%SRRLOC(F)%WT(DIM)    = DNEG          !FLAG TO INDICATE LENGTH WEIGHTING
                                !
                                SWF%SRRLOC(F)%SR(ONE,DIM) = S
                                SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                                !
                                SWF%SRRLOC(F)%ISRR(DIM) = K
                             END DO
                         ELSE             ! LENGTH PRORATE WEIGHT SPEFICIED FRACTION
                             WT_SUM = DZ  ! GET SEGMENT'S LENGTH
                             DO IRCH = ONE, NRCH
                                 WT_SUM = WT_SUM + STRM( 1, ISTRM + IRCH )
                             END DO
                             !
                             IF(WT_SUM > NEARZERO_29) THEN
                                 DO IRCH = ONE, NRCH
                                    DIM = DIM + ONE
                                    SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH
                                    SWF%SRRLOC(F)%WT(DIM)    = SWF%ISRR_TFR%WT(K) * STRM( 1, ISTRM + IRCH ) / WT_SUM  
                                    !
                                    SWF%SRRLOC(F)%SR(ONE,DIM) = S
                                    SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                                    !
                                    SWF%SRRLOC(F)%ISRR(DIM) = K
                                 END DO
                             ELSE
                                 WT_SUM = SWF%ISRR_TFR%WT(K) / DBLE(NRCH)  !LENGTH TOO SMALL JUST DO AVERAGE
                                 DO IRCH = ONE, NRCH
                                    DIM = DIM + ONE
                                    SWF%SRRLOC(F)%ISTRM(DIM) = ISTRM + IRCH  
                                    SWF%SRRLOC(F)%WT(DIM)    = WT_SUM  
                                    !
                                    SWF%SRRLOC(F)%SR(ONE,DIM) = S
                                    SWF%SRRLOC(F)%SR(TWO,DIM) = IRCH
                                    !
                                    SWF%SRRLOC(F)%ISRR(DIM) = K
                                 END DO
                             END IF
                         END IF
                     END IF
                 END IF
             END DO
             !
             ! GET TOTAL LEGNTH
             DO K=ONE, DIM
                 IF(SWF%SRRLOC(F)%ISTRM(K) > Z) SWF%SRRLOC(F)%TOTLENGTH = SWF%SRRLOC(F)%TOTLENGTH + STRM( 1, SWF%SRRLOC(F)%ISTRM(K) )
             END DO
             IF( SWF%SRRLOC(F)%TOTLENGTH < NEARZERO_29 ) SWF%SRRLOC(F)%TOTLENGTH = DZ
             !
             IF    (DIM == ONE) THEN
                                    SWF%SRRLOC(F)%WT(ONE) = UNO
             ELSEIF(DIM  > ONE) THEN
                !
                IF( ANY( SWF%SRRLOC(F)%WT < NEGNEARZERO_5) ) THEN !AT LEAST ONE LOCATION IS LENGTH PRORATED
                    !
                    ASSOCIATE(ISTRM=>SWF%SRRLOC(F)%ISTRM,     &
                            TOT_LEN=>SWF%SRRLOC(F)%TOTLENGTH, &
                                 WT=>SWF%SRRLOC(F)%WT          )
                                 !
                      IF(ALL( SWF%SRRLOC(F)%WT < NEGNEARZERO_5)) THEN
                          IF(TOT_LEN > NEARZERO_29) THEN
                              DO K=ONE, DIM
                                           WT(K) = STRM(1,ISTRM(K))/TOT_LEN
                              END DO
                          ELSE
                              SWF%SRRLOC(F)%N = Z              !NO STREAMS TO FLOW TOO
                              SWF%SRRLOC(F)%HAS_RETURN = FALSE
                          END IF
                      ELSE            !Mixture of length prorated with specified weights
                          LN_SUM = DZ
                          WT_SUM = DZ 
                          DO K=ONE, DIM
                                       IF(WT(K) < NEGNEARZERO_5) THEN
                                              !
                                              LN_SUM = LN_SUM + STRM(1,ISTRM(K))
                                              !
                                       ELSEIF(DZ < WT(K)) THEN
                                              !
                                              IF(WT(K) > UNO) WT(K) = UNO
                                              WT_SUM = WT_SUM + WT(K)
                                       END IF
                          END DO
                          !
                          WT_SUM = UNO - WT_SUM  !Invert weight cause we want the total weight for length prorated sections
                          !
                          IF(WT_SUM < NEARZERO_29 .OR. LN_SUM < NEARZERO_29) THEN
                             DO K=ONE, DIM
                                       IF(WT(K) < DZ) WT(K) = DZ
                             END DO
                          ELSE
                             DO K=ONE, DIM
                                       IF(WT(K) < DZ) WT(K) =  WT_SUM * STRM(1,ISTRM(K)) / LN_SUM
                             END DO
                          END IF
                      END IF
                      !
                    END ASSOCIATE
                ELSEIF( ALL(NEGNEARZERO_5 < SWF%SRRLOC(F)%WT .AND. SWF%SRRLOC(F)%WT < NEAR_ONE_5) ) THEN
                    !
                    DO CONCURRENT(K=ONE:DIM)
                        IF(   SWF%SRRLOC(F)%WT(K) < DZ  ) THEN
                                                               SWF%SRRLOC(F)%WT(K) = DZ
                        ELSEIF(SWF%SRRLOC(F)%WT(K) > UNO) THEN
                                                               SWF%SRRLOC(F)%WT(K) = UNO
                        END IF
                    END DO
                    !
                ELSE !ASSUME AN EVEN SPLIT OF RUNOFF
                    WT_SUM = DZ
                    IF(    DIM == TWO  ) THEN; WT_SUM = HALF
                    ELSEIF(DIM == THREE) THEN; WT_SUM = THIRD
                    ELSEIF(DIM == FOUR ) THEN; WT_SUM = FOURTH
                    ELSEIF(DIM == FIVE ) THEN; WT_SUM = FIFTH
                    ELSE;                      WT_SUM = UNO / DBLE(DIM)
                    END IF
                    !
                    DO CONCURRENT (K=ONE:DIM)
                                   SWF%SRRLOC(F)%WT(K) = WT_SUM
                    END DO
                END IF
                !
                ! Ensure weights sum to 1
                !
                WT_SUM = SUM( SWF%SRRLOC(F)%WT )
                !
                IF(WT_SUM.NE.UNO .AND. WT_SUM > NEARZERO_29) SWF%SRRLOC(F)%WT = SWF%SRRLOC(F)%WT / WT_SUM  !RESCALE TO SUM TO ONE
                !
                CALL SORT(SWF%SRRLOC(F)%ISTRM,SWF%SRRLOC(F)%WT) !SORTS FROM SMALLEST TO LARGESTs
             END IF
         END IF
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE BUILD_FULLY_ROUTED_RETURN_SRRLOC(SWF, WBS, IDIVAR, ISTRM, STRM)
    !
    CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: WBS
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: IDIVAR, ISTRM
    REAL,    DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: STRM
    TYPE(INTEGER_LINKED_LIST), DIMENSION(:), ALLOCATABLE:: LST
    INTEGER:: NSTRM, F, K, I, J, S
    LOGICAL:: ADD
    !
    !--------------------------------------
    !
    !
    NSTRM = SIZE(ISTRM, TWO)
    !
    ALLOCATE(LST(SWF%NFARM))
    !
    DO F = ONE, SWF%NFARM
                         CALL LST(F)%INIT()
    END DO
    !
    !--------------------------------------
    !
    DO K = ONE, NSTRM
       J = ISTRM(2,K) !row number
       I = ISTRM(3,K) !column number
       S = ISTRM(4,K) !Stream Segment Number
       F = WBS(I,J)
       IF(F > Z) THEN
        IF(SWF%BUILD_FRR(F)) THEN
            ADD = FALSE
            !
            IF(SWF%IRRFL == NEG) THEN
                                          ADD = TRUE
            ELSEIF(SWF%IRRFL == ONE) THEN
                     IF(IDIVAR(1,S) == Z) ADD = TRUE
            END IF
            !
            IF(ADD) CALL LST(F)%ADD(K)
            !
        END IF !( SWF%SRRLOC(F)%HAS_RETURN  .AND. SWF%SRRLOC(F)%FULLY)
       END IF  !(F > Z)
    END DO
    !
    !--------------------------------------
    !
    DO F = ONE, SWF%NFARM
        !
        IF( SWF%BUILD_FRR(F) ) THEN
         !
         SWF%SRRLOC(F)%BUILD_FULLY = FALSE     !NO NEED TO REBUILD UNLESS REQUESTED IN RP
         !
         SWF%SRRLOC(F)%LEAVE_MODEL = FALSE
         !
         SWF%SRRLOC(F)%N = LST(F)%LEN()
         !
         SWF%SRRLOC(F)%TOTLENGTH = DZ
         !
         IF(SWF%SRRLOC(F)%N > Z) THEN
             CALL ALLOC(SWF%SRRLOC(F)%RUNOFF,SWF%SRRLOC(F)%N, SRC=DZ)   !(ARR, N)
             CALL ALLOC(SWF%SRRLOC(F)%WT,    SWF%SRRLOC(F)%N)
             !CALL ALLOC(SWF%SRRLOC(F)%ISTRM, SWF%SRRLOC(F)%N)
             CALL ALLOC(SWF%SRRLOC(F)%SR,TWO,SWF%SRRLOC(F)%N,Z)         !(ARR, N, M, DIMCHK)
             !
             CALL LST(F)%TOARRAY(SWF%SRRLOC(F)%ISTRM)
             CALL LST(F)%DESTROY()                   !NO LONGER NEEDED
             !
             DO K=ONE, SWF%SRRLOC(F)%N                                    ! Assign Segnent and Reach that is used (only really used for output files).
                        I = SWF%SRRLOC(F)%ISTRM(K)
                            SWF%SRRLOC(F)%SR(1,K) = ISTRM(4, I)  ! SEG
                            SWF%SRRLOC(F)%SR(2,K) = ISTRM(5, I)  ! RCH
             END DO
             !
             IF(SWF%SRRLOC(F)%N > ONE) THEN !LENGTH PRORATED
                    !
                    ASSOCIATE(  DIM=>SWF%SRRLOC(F)%N,         &
                                IST=>SWF%SRRLOC(F)%ISTRM,     &
                                 SR=>SWF%SRRLOC(F)%SR,        &
                            TOT_LEN=>SWF%SRRLOC(F)%TOTLENGTH, &
                                 WT=>SWF%SRRLOC(F)%WT         )
                                 !
                        DO K=ONE, DIM
                                  TOT_LEN = TOT_LEN + STRM( 1, IST(K) )
                        END DO
                        !
                        IF(TOT_LEN > NEARZERO_29) THEN
                            DO K=ONE, DIM
                                         WT(K) = STRM(1,IST(K))/TOT_LEN
                            END DO
                        ELSE
                            SWF%SRRLOC(F)%N = Z !NO STREAMS TO FLOW TOO
                            TOT_LEN = DZ
                        END IF
                        !
                    END ASSOCIATE
             ELSE                             !Implies SWF%SRRLOC(F)%N == 1
                 SWF%SRRLOC(F)%WT(ONE)   = UNO
                 SWF%SRRLOC(F)%TOTLENGTH = STRM( 1, SWF%SRRLOC(F)%ISTRM(ONE) )
             END IF
         END IF
         !
      END IF
    END DO
    !
  END SUBROUTINE
  !
  !SUBROUTINE APPLY_RUNOFF_TO_SFR(SWF, RUNOFF, STRM)
  !  !
  !  CLASS(SURFACE_WATER_DATA),                   INTENT(INOUT):: SWF
  !  DOUBLE PRECISION,DIMENSION(:),   CONTIGUOUS, INTENT(IN   ):: RUNOFF
  !  REAL,            DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: STRM
  !  LOGICAL:: WRN_PRT
  !  INTEGER:: I, K, F
  !  DOUBLE PRECISION:: REACH_RUNFOFF
  !  TYPE(WARNING_TYPE):: WRN
  !  !
  !  CALL WRN%INIT()
  !  !
  !  WRN_PRT = FALSE
  !  !
  !  DO F=ONE, SWF%NFARM
  !      IF( SWF%SRRLOC(F)%HAS_RETURN  .AND. SWF%SRRLOC(F)%N > Z) THEN
  !          !
  !          ASSOCIATE(  DIM=>SWF%SRRLOC(F)%N,      &
  !                    ISTRM=>SWF%SRRLOC(F)%ISTRM,  &
  !                    RNOFF=>SWF%SRRLOC(F)%RUNOFF, &
  !                       WT=>SWF%SRRLOC(F)%WT       )
  !                       !
  !             IF(DIM==ONE) THEN
  !                 !
  !                 RNOFF(ONE) = RUNOFF(F)
  !                 !
  !                 I = ISTRM(ONE)
  !                 !
  !                 STRM(12,I) = STRM(12,I) + RUNOFF(F)
  !             ELSE
  !                 DO K=ONE, DIM
  !                     !
  !                     REACH_RUNFOFF = RUNOFF(F) * WT(K)
  !                     !
  !                     RNOFF(K) = REACH_RUNFOFF
  !                     !
  !                     I = ISTRM(K)
  !                     !
  !                     STRM(12,I) = STRM(12,I) + REACH_RUNFOFF
  !                     !
  !                 END DO
  !             END IF
  !          END ASSOCIATE
  !          !
  !      ELSEIF(RUNOFF(F) > NEARZERO_6 .AND. .NOT. SWF%SRRLOC(F)%LEAVE_MODEL)THEN
  !          !
  !          IF(SWF%RUNOFF_PRNT(F)) THEN
  !                                     SWF%RUNOFF_PRNT(F) = FALSE
  !                                     WRN_PRT = TRUE
  !          END IF
  !          !
  !          CALL WRN%ADD(NUM2STR(F,6)//'   '//NUM2STR(RUNOFF(F))//NL)
  !          SWF%SRRLOC(F)%RUNOFF(ONE) = RUNOFF(F)
  !      ELSE
  !          SWF%SRRLOC(F)%RUNOFF(ONE) = RUNOFF(F)
  !      END IF
  !  END DO
  !  !
  !  IF(WRN_PRT) THEN
  !     CALL WRN%CHECK(HED=NL//REPEAT('-',71)//NL//'   THIS IS A SOFT WARNING, IGNORE IT IF YOU INTENTIONALLY WANT THIS.  |'//NL//REPEAT('-',71)//BLN//   &
  !     'WBS RUNOFF IS NOT CONNECTED TO A SFR STREAM, SO RUNOFF WILL FLOW OUT OF THE MODEL DOMAIN'//BLN//         &
  !     'THIS OCCURS BECAUSE EITHER SFR IS NOT USED IN SIMULATION'//NL//                                          &
  !     'OR A SET OF REACHES COULD NOT BE FOUND WITHIN THE WBS/FARM AREA.'//BLN//                                 &
  !     'SINCE THE SURFACE WATER RUNOFF HAS NO WHERE TO GO IT IS REMOVED FROM THE MODEL.'//BLN//                  &
  !     'IF YOU WANT TO KEEP RUNOFF WITHIN THE MODEL USE THE SURFACE_WATER BLOCK KEYWORD "NORETURNFLOW"'//NL//    &
  !     'TO INDICATE THAT SURFACE RUNOFF SHOULD REINFILTRATE AS DEEP PERCOLATION'//NL//                           &
  !     'OR SPECIFY A "SEMI_ROUTED_RETURN" LOCATION FOR THE FOLLOWING WBS.'//BLN//                                &
  !     '(NOTE IF YOU DEFINE A WBS WITH A "SEMI_ROUTED_RETURN" SEGMENT=0 THEN THIS WARNING IS DISABLED.)'//BLN// &
  !     'THE FOLLOWING ARE THE WBS/FARMS THAT HAD RUNOFF THAT FLOWS OUT OF THE MODEL DOMAIN'//BLN//               &
  !     '   WBS   RUNOFF',                                        &
  !      OUTPUT=SWF%IOUT, CMD_PRINT=SWF%CMD_RUNOFF_PRNT, NO_NL=TRUE, TAIL=BLN//'THIS WARNING APPEARS THE FIRST TIME FMP HAS A WBS WITH RUNOFF > 0 AND THE RUNOFF HAS NO WHERE TO FLOW'//NL)
  !      !
  !      IF(SWF%CMD_RUNOFF_PRNT) SWF%CMD_RUNOFF_PRNT = FALSE
  !  END IF
  !  !
  !END SUBROUTINE
  !
  SUBROUTINE APPLY_RUNOFF_TO_SFR(SWF, RUNOFF, STRM)
    !
    CLASS(SURFACE_WATER_DATA),                             INTENT(INOUT):: SWF
    DOUBLE PRECISION,DIMENSION(:),   CONTIGUOUS,           INTENT(IN   ):: RUNOFF
    REAL,            DIMENSION(:,:), CONTIGUOUS, OPTIONAL, INTENT(INOUT):: STRM
    INTEGER:: I, K, F
    DOUBLE PRECISION:: REACH_RUNFOFF
    !
    DO F=ONE, SWF%NFARM
       SWF%SRRLOC(F)%LOST_RUNOFF = DZ
    END DO
    !
    DO F=ONE, SWF%NFARM
        IF(RUNOFF(F) < NEARZERO_6)THEN
            !
            DO K=ONE, SWF%SRRLOC(F)%N
                SWF%SRRLOC(F)%RUNOFF(K) = DZ
            END DO
            !
        ELSEIF( .NOT. SWF%SRRLOC(F)%HAS_RETURN  .OR. SWF%SRRLOC(F)%N == Z) THEN
            !
            SWF%SRRLOC(F)%LOST_RUNOFF = RUNOFF(F)  !Hold runoff even though it has no where to go
            !
        ELSE!IF( SWF%SRRLOC(F)%HAS_RETURN  .AND. SWF%SRRLOC(F)%N > Z) THEN
            !
            ASSOCIATE(  DIM=>SWF%SRRLOC(F)%N,      &
                      ISTRM=>SWF%SRRLOC(F)%ISTRM,  &
                      RNOFF=>SWF%SRRLOC(F)%RUNOFF, &
                         WT=>SWF%SRRLOC(F)%WT       )
                         !
               IF(DIM==ONE) THEN
                   !
                   RNOFF(ONE) = RUNOFF(F)
                   !
                   I = ISTRM(ONE)
                   !
                   IF( I > Z ) STRM(12,I) = STRM(12,I) + RUNOFF(F)
               ELSE
                   DO K=ONE, DIM
                       !
                       REACH_RUNFOFF = RUNOFF(F) * WT(K)
                       !
                       RNOFF(K) = REACH_RUNFOFF
                       !
                       I = ISTRM(K)
                       !
                       IF( I > Z ) STRM(12,I) = STRM(12,I) + REACH_RUNFOFF
                       !
                   END DO
               END IF
            END ASSOCIATE
            !
        END IF
    END DO
  END SUBROUTINE
  !
  SUBROUTINE RUNOFF_LOST_CHECK(SWF)
    !
    CLASS(SURFACE_WATER_DATA), INTENT(INOUT):: SWF
    LOGICAL:: WRN_PRT
    INTEGER:: F
    TYPE(WARNING_TYPE):: WRN
    !
    CALL WRN%INIT()
    !
    WRN_PRT = FALSE
    !
    DO F=ONE, SWF%NFARM
        IF(SWF%SRRLOC(F)%LOST_RUNOFF > NEARZERO_6)THEN
            !
            IF(SWF%RUNOFF_PRNT(F)) THEN
                                       SWF%RUNOFF_PRNT(F) = FALSE
                                       WRN_PRT = TRUE
            END IF
            !
            CALL WRN%ADD(NUM2STR(F,6)//'   '//NUM2STR(SWF%SRRLOC(F)%LOST_RUNOFF)//NL)
        END IF
    END DO
    !
    IF(WRN_PRT) THEN
       CALL WRN%CHECK(HED=NL//REPEAT('-',71)//NL//'   THIS IS A SOFT WARNING, IGNORE IT IF YOU INTENTIONALLY WANT THIS.  |'//NL//REPEAT('-',71)//BLN//   &
       'WBS runoff > 0, but WBS no SFR return flow point was defined, so runoff will leave the model domain.'//BLN//         &
       'This occurs because either SFR is not used in simulation,'//NL//                                                     &
       'or you have ROUTED_RETURN_ANY_REACH or ROUTED_RETURN_ANY_NON_DIVERSION_REACH option,'//NL//                          &
       '   but no SFR reaches are found in the WBS/FARM area to send the runoff,'//NL//                                      &
       'or you set NO_RETURN_FLOW, but runoff was generated outside of FMP, such as the DRT-FMP link.'//BLN//                &
       'Since the surface water runoff has no where to go it is removed from the model.'//BLN//                              &
       'If you want to keep runoff within the model please define either'//NL//                                              &
       '   define for the WBS a SEMI_ROUTED_RETURN location or'//NL//                                                        &
       '   define for the WBS the NO_RETURN_FLOW keyword to force surface runoff to reinfiltrate as deep percolation'//BLN// &
       'NOTE 1: If you define a wbs with a SEMI_ROUTED_RETURN and set the runoff segment to 0 (zero),'//NL//                 &
       '           then runoff leaves model without a this warning.'//BLN//                                                  &
       'NOTE 2: The NO_RETURN_FLOW flag supercedes SEMI_ROUTED_RETURN'//NL//                                                 &
       '           and will disable all return flow points to'//NL//                                                         &
       '           (a) force all FMP generated runoff to infiltrate and'//NL//                                               &
       '           (b) force external to FMP runoff to leave the model (and raise this warning).'//BLN//                     &
       'NOTE 3: If all the model cells beneath the surface are IBOUND=0, '//NL//                 &
       '           then all deep percolation is always shifted to runoff.'//BLN//                                                  &
       'The following are the WBS/FARMS that had runoff leave the model domain'//BLN//                                       &
       '   WBS   RUNOFF',                                                                                                    &
        OUTPUT=SWF%IOUT, CMD_PRINT=SWF%CMD_RUNOFF_PRNT, NO_NL=TRUE, TAIL=BLN//'This warning appears the first time FMP has a WBS with runoff > 0 and the runoff leaves the model domain.'//NL)
        !
        IF(SWF%CMD_RUNOFF_PRNT) SWF%CMD_RUNOFF_PRNT = FALSE
    END IF
    !
  END SUBROUTINE
  !
  !!!SUBROUTINE SET_SFR_SRD_FLOW(SWF, STRM)
  !!!  !
  !!!  CLASS(SURFACE_WATER_DATA),           INTENT(INOUT):: SWF
  !!!  REAL,    DIMENSION(:,:), CONTIGUOUS, INTENT(IN   ):: STRM
  !!!  INTEGER:: F, L, K
  !!!  !
  !!!  DO CONCURRENT (F=ONE:SWF%NFARM, SWF%SRDLOC(F)%N > Z) 
  !!!    DO K = ONE, SWF%SRDLOC(F)%N
  !!!       ASSOCIATE(IRCH  => SWF%SRDLOC(F)%SEGRCH(TWO,K), &
  !!!                 ISTRM => SWF%SRDLOC(F)%ISTRM(K     ), &
  !!!                 FLOW  => SWF%SRDLOC(F)%FLOW(      K)   )
  !!!                 !
  !!!          L = ISTRM
  !!!          !
  !!!          IF(IRCH == ONE) THEN
  !!!              FLOW = STRM(10, L) !INFLOW TO CURRENT REACH
  !!!          ELSE
  !!!              L = L - ONE
  !!!              FLOW = STRM(9, L) !OUTFLOW FROM PREVIOUS REACH -- WHICH IS THE SAME AS INFLOW
  !!!          END IF
  !!!       END ASSOCIATE
  !!!    END DO
  !!!  END DO
  !!!  !
  !!!END SUBROUTINE
  !  
  SUBROUTINE SET_NRD_ARRAY( SWF, NRD, UPDATE )
    CLASS(SURFACE_WATER_DATA),                    INTENT(IN   ):: SWF
    DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: NRD
    LOGICAL,                                      INTENT(IN   ):: UPDATE
    INTEGER:: I,J,II,DIM
    !
    IF(SWF%NRD_TFR%INUSE) THEN 
        !
        IF(UPDATE) THEN
                   DO CONCURRENT(J=ONE:SWF%NFARM); NRD(ONE,J) = J
                   END DO
        END IF
        !
        IF(UPDATE .OR. SWF%NRD_TFR%TRANSIENT) THEN 
            !
            DO CONCURRENT(J=ONE:SWF%NFARM, I=ONE:SWF%MXNRD*THREE)
                NRD(I+ONE,J) = SWF%NRD_TFR%ARRAY(I,J)
            END DO
            !
            DIM = SWF%MXNRD*THREE + ONE  !DIM OF NRD ARRAY
            !
            ASSOCIATE(SFAC=> SWF%NRD_TFR%SFAC)
                IF(SFAC%HAS_ALL) THEN
                    DO CONCURRENT(J=ONE:SWF%NFARM, I=TWO:DIM:THREE)  !I=ONE:SWF%MXNRD and II = (I-ONE)*THREE + TWO
                          NRD(I,J) = NRD(I,J) * SFAC%ALL
                    END DO
                END IF
                IF(SFAC%HAS_EX1) THEN
                    DO CONCURRENT(J=ONE:SWF%NFARM, I=TWO:DIM:THREE)
                          NRD(I,J) = NRD(I,J) * SFAC%EX1(J)
                    END DO
                END IF
                IF(SFAC%HAS_EX2) THEN
                    DO CONCURRENT(J=ONE:SWF%NFARM, I=ONE:SWF%MXNRD)
                          II = (I-ONE)*THREE + TWO
                          NRD(II,J) = NRD(II,J) * SFAC%EX2(I)
                    END DO
                END IF
            END ASSOCIATE
            !
        END IF
    END IF
    !
  END SUBROUTINE
  !  
  !SUBROUTINE SET_SRD_ARRAY( SWF, SRD, UPDATE )
  !  CLASS(SURFACE_WATER_DATA),           INTENT(IN   ):: SWF
  !  INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: SRD
  !  LOGICAL,                             INTENT(IN   ):: UPDATE
  !  INTEGER:: J
  !  !
  !  !!!IF(SWF%ISRD%INUSE) THEN
  !  !!!    !
  !  !!!    IF(UPDATE) THEN
  !  !!!        SRD = Z
  !  !!!        DO CONCURRENT(J=ONE:SWF%NFARM); SRD(ONE,J) = J
  !  !!!        END DO
  !  !!!    END IF
  !  !!!    !
  !  !!!    IF(UPDATE .OR. SWF%ISRD%TRANSIENT) THEN 
  !  !!!        DO CONCURRENT(J=ONE:SWF%NFARM)
  !  !!!            SRD(FOUR,J) = SWF%ISRD%SEGRCH(ONE,J)
  !  !!!            SRD(FIVE,J) = SWF%ISRD%SEGRCH(TWO,J)
  !  !!!        END DO
  !  !!!    END IF
  !  !!!    !
  !  !!!END IF
  !  !
  !END SUBROUTINE
  !  
  !SUBROUTINE SET_SRR_ARRAY( SWF, SRR, UPDATE )
  !  CLASS(SURFACE_WATER_DATA),           INTENT(IN   ):: SWF
  !  INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: SRR
  !  LOGICAL,                             INTENT(IN   ):: UPDATE
  !  INTEGER:: J
  !  !
  !  IF(SWF%ISRR_TFR%INUSE) THEN
  !      !
  !      IF(UPDATE) THEN
  !          SRR = Z
  !          FORALL(J=ONE:SWF%NFARM) SRR(ONE,J) = J
  !      END IF
  !      !
  !      IF(UPDATE .OR. SWF%ISRR_TFR%TRANSIENT) THEN 
  !          DO CONCURRENT(J=ONE:SWF%NFARM)
  !              !!!SRR(FOUR,J) = SWF%ISRR_TFR%SEGRCH(ONE,J)
  !              !!!SRR(FIVE,J) = SWF%ISRR_TFR%SEGRCH(TWO,J)
  !          END DO
  !      END IF
  !      !
  !  END IF
  !  !
  !END SUBROUTINE
  !  
  SUBROUTINE SET_CHOICE_ARRAY( SWF, CHOICE, UPDATE )
    CLASS(SURFACE_WATER_DATA),           INTENT(IN   ):: SWF
    INTEGER, DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: CHOICE
    LOGICAL,                             INTENT(IN   ):: UPDATE
    !
    IF(SWF%HAS_SW) THEN
       IF(UPDATE .OR. SWF%CHOICE%TRANSIENT) THEN
                          CHOICE = SWF%H2ORETURN
       END IF
    ELSE
        CHOICE = Z
    END IF
    !
  END SUBROUTINE
  !
!!!  PURE SUBROUTINE APPY_FARM_SRD_SFR()
!!!        IF(IUNITSFR.NE.Z .AND. (IRDFL.NE.Z .OR. ISRDFL.NE.Z).AND. WBS%H2OSOURCE%SW(NF)) THEN                     ! seb H2OSRC(1,:)=FID; H2OSRC(2,:)=GW; H2OSRC(3,:)=SW; H2OSRC(4,:)=NRD  
!!!         FSLEN=FCSEGL(NF)
!!!         !AFDELSW=DZ
!!!         !RDEL=DZ
!!!         IFCRIDOLD=Z
!!!         IF(ISRDFL.EQ.-1) GOTO 665
!!!         !
!!!         IF(    SWFL%ISRD%ARRAY(ONE,NF) > Z) THEN
!!!            I = SWFL%ISRD%ARRAY(ONE,NF)
!!!            !
!!!            L = SEG_NSTRM(I) + SWFL%ISRD%ARRAY(TWO,NF)
!!!            LL=L-1
!!!            IF(LL<ONE) LL=ONE
!!!            !
!!!            FLOWIN=STRM(9,LL)
!!!            FLOWIN=ANINT(FLOWIN*AC)/AC  
!!!            TOT_DIV_FLOW = FLOWIN
!!!            !
!!!            IF(ALLOT%HAS_SW_ALLOTMENT .AND.
!!!     1         FARMALLOT.LT.FLOWIN) FLOWIN=FARMALLOT
!!!            !
!!!            IF(WBS%HAS_SWO)THEN
!!!               IF(SWODAT%FMP_SW_LIMIT(NF).LT.FLOWIN)
!!!     1                    FLOWIN=SWODAT%FMP_SW_LIMIT(NF)
!!!            END IF
!!!            !
!!!            IF(ND.LE.TF) THEN
!!!                RDEL=TF-ND-QR
!!!            ELSE
!!!                RDEL=-SURPLUS1       !recharge cumulative surplus of nrd (if desired to be sent to SW) into canal
!!!            END IF
!!!            IF(RDEL.GT.FLOWIN) RDEL=FLOWIN
!!!            !
!!!            STRM(12,L)=SNGL(SFRADD(L)-RDEL)
!!!            AFDELSW   =RDEL
!!!            RDR(L)    =RDEL
!!!         ELSE
!!!         !
!!!         DO L=3,NSTRM
!!!            LL=L-1                              
!!!            FLOWIN=STRM(9,LL)
!!!            FLOWIN=ANINT(FLOWIN*AC)/AC                        !STRM(10,L) ?   seb response STRM(9,L-1) = STRM(10,L)  **note that LL=L-1
!!!            RCHLEN=DBLE(STRM(1,L))
!!!C
!!!C7E2A---DETERMINE SW DELIVERY FROM HEAD-GATE REACH
!!!
!!!C7E2A1--DETERMINE LOCATION OF HEAD-GATE REACH
!!!C       Farm Reach: * belongs to farm, * is at all a farm reach,
!!!C                   * 1st one being different from previous one,
!!!C                   * 1st one being different from second previous one, meaning
!!!C                     1st previous one could be just a blank (FCRID(NF,L)=0 at farm corner point),
!!!C                     but still within the same farm.
!!!           IF(IFCRID(NF,L).EQ.NF .AND. IFCRID(NF,L).GT.0 .AND.
!!!     1      IFCRID(NF,L).NE.IFCRID(NF,L-1).AND.IFCRID(NF,L).NE.
!!!     2      IFCRID(NF,L-2).AND.IFCRID(NF,L).NE.IFCRIDOLD) THEN
!!!C
!!!C7E2A2--DETERMINE REACH DELIVERY REQUIREMENT AND ACTUAL DELIVERY FROM HEAD-GATE REACH INTO FARM
!!!              TOT_DIV_FLOW = TOT_DIV_FLOW + FLOWIN
!!!              IFCRIDOLD=IFCRID(NF,L)
!!!              IF(IOPTFL.EQ.0.AND.ND.LE.TF) RDEL=TF-ND-QR                !QR is not zero for acreage optimization, otherwise zero here
!!!              IF(IOPTFL.EQ.1.AND.ND.LE.TF) RDEL=SW-SURPLUS1
!!!              IF(ND.GT.TF) RDEL=-SURPLUS1                               !recharge cumulative surplus of nrd (if desired to be sent to SW) into canal
!!!C
!!!C             GENERAL CASE & EQUAL APPROPRIATION
!!!              IF(ALLOT%HAS_SW_ALLOTMENT .AND.
!!!     1           FARMALLOT.LT.FLOWIN) FLOWIN=FARMALLOT
!!!              !
!!!              IF(WBS%HAS_SWO)THEN
!!!                 IF(SWODAT%FMP_SW_LIMIT(NF).LT.FLOWIN)
!!!     1                      FLOWIN=SWODAT%FMP_SW_LIMIT(NF)
!!!              END IF
!!!              !
!!!              IF(RDEL.GT.FLOWIN) RDEL=FLOWIN
!!!!             IF(IGRID.EQ.1.AND.ANY(IALLOTSW.EQ.[1,4])) FALLOT(NF)=FLOWIN!OVERWRITE PARENT ALLOTMENT WITH JOINT (PARENT + CHILD) ALLOTMENT OR UNRESTRICTED STREAMFLOW
!!!!              IF(IALLOTSW.LT.2.AND.RDEL.GT.FLOWIN) RDEL=FLOWIN                                    SCOTT
!!!!              IF(IGRID.EQ.1.AND.IALLOTSW.EQ.1) FALLOT(NF)=FLOWIN        !OVERWRITE PARENT ALLOTMENT WITH JOINT (PARENT + CHILD) ALLOTMENT OR UNRESTRICTED STREAMFLOW
!!!!           
!!!!           save actual delivery from surface water to farm and pull it from canal 
!!!!           (by adding a 'negative recharge' " - RDEL " to 'reach-by-reach overland recharge' of SFR package)
!!!!
!!!!-----------FOR A PARENT MODEL FARM WITH A HEAD-GATE REACH, FOR A CHILD MODEL WHERE FMP IS ACTIVE, AND WHERE THE CURRENT FARM STRADDLES BOTH MODELS,
!!!!           CHECK IF THE SUM OF RESIDUAL DEMANDS OF PARENT AND CHILD MODEL FARMS EXCEED THE AVAILABLE STREAMFLOW OR NOT:
!!!!           --> for the case that the sum of both residual demands (parent and child) exceed the available streamflow:
!!!!               scale the RDEL of parent farm back by flowin/(parent_farm_demand + child_farm_demand) AND divert all streamflow.
!!!!           --> for the case that the sum of both residual demands (parent and child) does not exceed the available streamflow:
!!!!               divert child farm demand in addition to parent farm demand from the available streamflow.  
!!!            IF(ILGR.NE.0.AND.LGRITER.GT.1.AND.IGRID.EQ.1.AND.
!!!     1         NGRIDS.GT.1) THEN 
!!!               CRDEL=0
!!!               DO N=2,NGRIDS
!!!               IF(N.EQ.LGRDAT(N)%IFMPGRID) THEN
!!!                IF(FMPDAT(N)%ISRDFL.EQ.-1)THEN
!!!                  CRDEL=CRDEL+FMPDAT(N)%TFDR(NF)-FMPDAT(N)%NRD(1,NF)
!!!                  IF(TF-ND-QR+CRDEL.GT.FLOWIN) THEN
!!!                    STRM(12,L)=SNGL(SFRADD(L)-FLOWIN)
!!!                    RDEL=(TF-ND-QR)*FLOWIN/(TF-ND-QR+CRDEL)
!!!                  ELSE
!!!                    STRM(12,L)=SNGL(SFRADD(L)-RDEL-CRDEL)
!!!                  ENDIF
!!!                ENDIF
!!!               ENDIF
!!!               ENDDO
!!!            ELSE
!!!               STRM(12,L)=SNGL(SFRADD(L)-RDEL)
!!!            ENDIF
!!!     
!!!            AFDELSW=RDEL
!!!            RDR(L)=RDEL
!!!         ENDIF
!!!         ENDDO
!!!         !
!!!         END IF
!!!  
!!!  END SUBROUTINE
  !
  !--------------------------------------------------------------------------------------------
  !
  PURE ELEMENTAL SUBROUTINE INIT_NRD_VALUES(NRD, MXNRD)
    CLASS(NRD_VALUES), INTENT(INOUT):: NRD
    INTEGER,           INTENT(IN   ):: MXNRD
    !
    CALL DESTROY_NRD_VALUES(NRD)
    !
    IF(MXNRD > Z) THEN
        ALLOCATE(NRD%RANKPOS(MXNRD), SOURCE=[1:MXNRD])
        ALLOCATE(NRD%AVALIBLE_WATER(MXNRD), SOURCE=DZ)
        ALLOCATE(NRD%CONSUMED_WATER(MXNRD), SOURCE=DZ)
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_NRD_VALUES(NRD, UNRD, SCALE)
    CLASS(NRD_VALUES),                          INTENT(INOUT):: NRD
    DOUBLE PRECISION, DIMENSION(:), CONTIGUOUS, INTENT(IN   ):: UNRD  ! Uses old FMP input structure that incldues the WBS # in UNRD(1)
    DOUBLE PRECISION,                           INTENT(IN   ):: SCALE
    INTEGER:: I, J, K, DIM
    !
    IF( NRD%SIZE() < ONE ) RETURN
    !
    NRD%CONSUMED_WATER = DZ
    !
    DIM = SIZE(UNRD)
    J = ONE
    DO I=TWO, DIM, THREE
                   NRD%AVALIBLE_WATER(J) = UNRD(I) * SCALE
                   J = J + ONE
    END DO
    !
    J = ONE
    DO I=THREE, DIM, THREE
                     K = NINT(UNRD(I))
                     NRD%RANKPOS(K) = J
                     J = J + ONE
    END DO
    !
    NRD%SUPPLY = SUM(NRD%AVALIBLE_WATER)
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE INIT_CONSUME_NRD_VALUES(NRD)
    CLASS(NRD_VALUES), INTENT(INOUT):: NRD
    !
    NRD%DEMAND = DZ
    IF(ALLOCATED(NRD%CONSUMED_WATER)) NRD%CONSUMED_WATER = DZ
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CONSUME_NRD_VALUES(NRD, DEMAND, CONSUMED)
    CLASS(NRD_VALUES), INTENT(INOUT):: NRD
    DOUBLE PRECISION,  INTENT(IN   ):: DEMAND
    DOUBLE PRECISION,  INTENT(INOUT):: CONSUMED
    DOUBLE PRECISION:: AVALIBLE
    INTEGER:: I, J
    !
    IF(NRD%SUPPLY <= NRD%DEMAND) THEN                ! NRD%DEMAND holds past history of demands on NRD,
        CONSUMED = DZ                                !   if supply is less than it, then any additional demands cannot be met
    ELSE
        CONSUMED = SUM(NRD%CONSUMED_WATER)          ! Water already consumed in NRD --sum to zero on first call
        !                                           
        IF( NRD%SUPPLY - CONSUMED <= DEMAND ) THEN  ! Demand exceeds NRD supplies so consume all of it
            NRD%CONSUMED_WATER = NRD%AVALIBLE_WATER
            CONSUMED = NRD%SUPPLY - CONSUMED        ! Actual water consumed during this call
        ELSE
            CONSUMED = DZ
            DO I = 1, NRD%SIZE()
               J = NRD%RANKPOS(I)
               !
               AVALIBLE = NRD%AVALIBLE_WATER(J) - NRD%CONSUMED_WATER(J)
               IF(AVALIBLE > DZ) THEN
                             CONSUMED = CONSUMED + AVALIBLE
                             IF( CONSUMED <= DEMAND ) THEN
                                 NRD%CONSUMED_WATER(J) = NRD%AVALIBLE_WATER(J)
                             ELSE
                                 NRD%CONSUMED_WATER(J) = NRD%CONSUMED_WATER(J) + DEMAND - CONSUMED + AVALIBLE ! DEMAND - (CONSUMED - AVALIBLE))
                                 EXIT
                             END IF
               END IF
            END DO
            CONSUMED = DEMAND
        END IF
        IF(CONSUMED < DZ) CONSUMED = DZ
    END IF
    !
    NRD%DEMAND = NRD%DEMAND + DEMAND
    !
  END SUBROUTINE
  !
  PURE FUNCTION SIZE_NRD_VALUES(NRD) RESULT(SIZ)
    CLASS(NRD_VALUES), INTENT(IN):: NRD
    INTEGER:: SIZ
    !
    SIZ = Z
    IF(ALLOCATED(NRD%RANKPOS)) SIZ = SIZE(NRD%RANKPOS)
    !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE FINAL_NRD_VALUES(NRD)
    TYPE(NRD_VALUES), INTENT(INOUT):: NRD
    CALL DESTROY_NRD_VALUES(NRD)
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE DESTROY_NRD_VALUES(NRD)
    CLASS(NRD_VALUES), INTENT(INOUT):: NRD
    NRD%DEMAND   = DZ
    NRD%SUPPLY   = DZ
    IF(ALLOCATED(NRD%RANKPOS)) DEALLOCATE(NRD%RANKPOS)
    IF(ALLOCATED(NRD%AVALIBLE_WATER)) DEALLOCATE(NRD%AVALIBLE_WATER)
    IF(ALLOCATED(NRD%CONSUMED_WATER)) DEALLOCATE(NRD%CONSUMED_WATER)
  END SUBROUTINE
  !
  !--------------------------------------------------------------------------------------------
  !
  SUBROUTINE PRINT_OUT_SFR_SRD(SWF, STRM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    REAL, DIMENSION(:,:), CONTIGUOUS,          INTENT(IN   ):: STRM
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, FF, II, ISTRM
    DOUBLE PRECISION:: INFLOW, DMD
    CHARACTER(17):: ZER, DT
    CHARACTER(11):: REASON
    !
    IF(SWF%OUT_SFR_SRD%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SWF%OUT_SFR_SRD%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_SFR_SRD%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_SFR_SRD%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER SFR_DELIVERY (SEMI_ROUTED_DELIVERY) INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), SEGMENT (INT), REACH (INT), DELIVERY (double), SFR_INFLOW (double), LOWER_LIMIT (double), UPPER_LIMIT (double), WBS_SFR_DMD (double), SRD ID (int)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !                                                                                                                                                        x
            CALL SWF%OUT_SFR_SRD%SET_HEADER( '    PER    STP    WBS    SEG    RCH      WBS_SFR_DMD         DELIVERY       SFR_INFLOW      LOWER_LIMIT      UPPER_LIMIT  DEFICIT_REASON        DELT   DYEAR         DATE_START           ISRD' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
       !
      IF(SWF%SRDLOC(F)%N == Z) THEN
          CONTINUE        
      ELSEIF(ALL(SWF%SRDLOC(F)%ISTRM < ONE)) THEN
          REASON = '  NO_DELIV'
          WRITE(IU, '(5I7, 5A17, A, A17, 2x,F13.7, 2x,A, 2x,A)') KPER, KSTP, F, Z, Z, ZER, ZER, ZER, ZER, ZER, REASON, DT, DYEAR, DATE, '0'
      ELSE
          IF( SWF%SRDLOC(F)%TOT_DMD_INI - SWF%SRDLOC(F)%TOT_DMD_MET <= NEARZERO_12 ) REASON = '  NONE'
          !
          DO I = ONE, SWF%SRDLOC(F)%N
           !
           IF(SWF%SRDLOC(F)%ISTRM(I) > Z) THEN
             !
             ISTRM = SWF%SRDLOC(F)%ISTRM(I)
             !
             INFLOW = STRM(10,SWF%SRDLOC(F)%ISTRM(I))
             !
             DMD    = SWF%SRDLOC(F)%TOT_DMD_INI
             !
             !--------------------------------------------------------------------------------------------
             ! Deduct previous farms
             DO FF = ONE, F-ONE
                 DO II = ONE, SWF%SRDLOC(FF)%N
                                         IF(ISTRM == SWF%SRDLOC(FF)%ISTRM(II)) THEN
                                             !
                                             INFLOW = INFLOW - SWF%SRDLOC(FF)%FLOW(II)  !Water removed from SFR before current delivery
                                         END IF
                 END DO
             END DO
             !
             !Deduct previous delivery locations
             DO II = ONE, I-ONE
                                     IF(ISTRM == SWF%SRDLOC(F)%ISTRM(II)) THEN
                                         !
                                         INFLOW = INFLOW - SWF%SRDLOC(F)%FLOW(II)  !Water removed from SFR before current delivery
                                     END IF
                                     !
                                     DMD = DMD - SWF%SRDLOC(F)%FLOW(II)
             END DO
             !
             IF(INFLOW < DZ) INFLOW = DZ
             !--------------------------------------------------------------------------------------------
             !
             IF(SWF%SRDLOC(F)%TOT_DMD_INI - SWF%SRDLOC(F)%TOT_DMD_MET > NEARZERO_12) THEN
                 !
                 IF( INFLOW - SWF%SRDLOC(F)%FLOW(I) <= NEARZERO_12 ) THEN  !IS_CLOSE(INFLOW,SWF%SRDLOC(F)%FLOW(I))
                     !
                     REASON = '  INFLOW'
                     !
                 ELSEIF( SWF%SRDLOC(F)%ULIM(I) - SWF%SRDLOC(F)%LLIM(I) - SWF%SRDLOC(F)%FLOW(I) <= NEARZERO_12 ) THEN
                     !
                     REASON = '  LIMIT'
                     !
                 ELSE
                    IF(IS_CLOSE(INFLOW,SWF%SRDLOC(F)%FLOW(I), NEARZERO_5, NEARZERO_3) ) THEN  ! Check in cauase its a precision issue
                        !
                        REASON = '  INFLOW'
                        !
                    ELSEIF( IS_CLOSE(SWF%SRDLOC(F)%ULIM(I) - SWF%SRDLOC(F)%LLIM(I), SWF%SRDLOC(F)%FLOW(I), NEARZERO_5, NEARZERO_3) ) THEN
                        !
                        REASON = '  LIMIT'
                    ELSE
                        REASON = '  UNKNOWN'  !Probably failed to converge on delivery or time step
                    END IF
                 END IF
             END IF
             !
             IF(SWF%OUT_SFR_SRD%BINARY) THEN
                     WRITE(IU) DATE, DYEAR, DELT, KPER, KSTP, F, SWF%SRDLOC(F)%SR(ONE,I), SWF%SRDLOC(F)%SR(TWO,I), SWF%SRDLOC(F)%FLOW(I), INFLOW, SWF%SRDLOC(F)%LLIM(I), SWF%SRDLOC(F)%ULIM(I), DMD, SWF%SRDLOC(F)%ISRD(I)
             ELSE
                     WRITE(IU, '(5I7, 5A17, A, A17, 2x,F13.7, 2x,A, 2x,A)') KPER, KSTP, F, SWF%SRDLOC(F)%SR(ONE,I), SWF%SRDLOC(F)%SR(TWO,I), NUM2STR(DMD), NUM2STR(SWF%SRDLOC(F)%FLOW(I)), NUM2STR(INFLOW), NUM2STR(SWF%SRDLOC(F)%LLIM(I)), NUM2STR(SWF%SRDLOC(F)%ULIM(I)), REASON, DT, DYEAR, DATE, NUM2STR(SWF%SRDLOC(F)%ISRD(I))
             END IF
           END IF
          END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_SFR_SRD_BYWBS(SWF, STRM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    REAL, DIMENSION(:,:), CONTIGUOUS,          INTENT(IN   ):: STRM
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I
    DOUBLE PRECISION:: INFLOW, DELIV, MAX_DELIV, DEFICIT, TOT_ULIM, TOT_LLIM, DMD, SHORT
    CHARACTER(17):: ZER, DT
    !
    IF(SWF%OUT_SFR_SRD_BYWBS%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SWF%OUT_SFR_SRD_BYWBS%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_SFR_SRD_BYWBS%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_SFR_SRD_BYWBS%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER SFR_DELIVERY BY WBS (SEMI_ROUTED_DELIVERY) INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), SEGMENT (INT), REACH (INT), DELIVERY (double), SFR_INFLOW (double), LOWER_LIMIT (double), UPPER_LIMIT (double), WBS_TOT_SFR_DMD (double), SRD ID (int)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !                                                                                                                      X
            CALL SWF%OUT_SFR_SRD_BYWBS%SET_HEADER( '    PER    STP    WBS      WBS_SFR_DMD         DELIVERY       SFR_INFLOW     MAX_DELIVERY   INFLOW_DEFICIT  TOTAL_LOWER_LIM  TOTAL_UPPER_LIM             DELT   DYEAR         DATE_START' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
      !
      IF(SWF%SRDLOC(F)%N == Z) THEN
          IF(SWF%OUT_SFR_SRD_BYWBS%BINARY) THEN
                  WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F,DZ, DZ, DZ, DZ, DZ, SWF%SRDLOC(F)%TOT_DMD_INI, DZ
          ELSE
                  WRITE(IU, '(3I7, 8A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, NUM2STR(SWF%SRDLOC(F)%TOT_DMD_INI),ZER,ZER,ZER,ZER,ZER,ZER, DT, DYEAR, DATE
          END IF
      ELSEIF(ALL(SWF%SRDLOC(F)%ISTRM < ONE)) THEN
          IF(SWF%OUT_SFR_SRD_BYWBS%BINARY) THEN
                  WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F,DZ, DZ, DZ, DZ, DZ, SWF%SRDLOC(F)%TOT_DMD_INI, DZ
          ELSE
                  WRITE(IU, '(3I7, 8A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, NUM2STR(SWF%SRDLOC(F)%TOT_DMD_INI),ZER,ZER,ZER,ZER,ZER,ZER, DT, DYEAR, DATE
          END IF
      ELSE
          INFLOW    = DZ
          DELIV     = DZ
          MAX_DELIV = DZ
          TOT_ULIM  = DZ
          TOT_LLIM  = DZ
          DEFICIT   = DZ
          DMD       = SWF%SRDLOC(F)%TOT_DMD_INI
          !
          DO I = ONE, SWF%SRDLOC(F)%N
                !
                IF(SWF%SRDLOC(F)%ISTRM(I) > Z) THEN
                  !
                  SHORT = SWF%SRDLOC(F)%ULIM(I) - SWF%SRDLOC(F)%LLIM(I)
                  !
                  IF(SHORT > DMD) SHORT = DMD
                  SHORT = SHORT - SWF%SRDLOC(F)%FLOW(I)
                  !
                  IF(SHORT > NEARZERO_12) THEN
                      DEFICIT = DEFICIT + SHORT
                  ELSE
                      SHORT = DZ
                  END IF
                  !
                  INFLOW    = INFLOW    + STRM(10,SWF%SRDLOC(F)%ISTRM(I))
                  DELIV     = DELIV     + SWF%SRDLOC(F)%FLOW(I)
                  MAX_DELIV = MAX_DELIV + SWF%SRDLOC(F)%MAXDEL(I)
                  TOT_ULIM  = TOT_ULIM  + SWF%SRDLOC(F)%ULIM(I)
                  TOT_LLIM  = TOT_LLIM  + SWF%SRDLOC(F)%LLIM(I)
                  !
                  DMD       = DMD       - SWF%SRDLOC(F)%FLOW(I) - SHORT
                  !
                END IF
          END DO
          !
          DEFICIT = SWF%SRDLOC(F)%TOT_DMD_INI - SWF%SRDLOC(F)%TOT_DMD_MET
          !
          IF( DEFICIT <= NEARZERO_12 ) DEFICIT = DZ
          !
          IF(SWF%OUT_SFR_SRD_BYWBS%BINARY) THEN
                  WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F,DELIV, INFLOW, MAX_DELIV, SWF%SRDLOC(F)%TOT_DMD_INI, DEFICIT
          ELSE
                  WRITE(IU, '(3I7, 8A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, NUM2STR(SWF%SRDLOC(F)%TOT_DMD_INI), NUM2STR(DELIV), NUM2STR(INFLOW), NUM2STR(MAX_DELIV), NUM2STR(DEFICIT), NUM2STR(TOT_LLIM), NUM2STR(TOT_ULIM), DT, DYEAR, DATE
          END IF
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_SFR_SRR(SWF, STRM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    REAL, DIMENSION(:,:), CONTIGUOUS,          INTENT(IN   ):: STRM
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I
    DOUBLE PRECISION:: INFLOW, OTFLOW
    CHARACTER(17):: ZER, DT
    !
    IF(SWF%OUT_SFR_SRR%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SWF%OUT_SFR_SRR%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_SFR_SRR%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_SFR_SRR%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER SFR_RETURN (SEMI_ROUTED_RETURN + FULLY_ROUTED_RETURN) INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), SEGMENT (INT), REACH (INT), DELIVERY (double), SFR_INFLOW (double), LOWER_LIMIT (double), UPPER_LIMIT (double), WBS_TOT_SFR_DMD (double), SRR ID (int)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !
            CALL SWF%OUT_SFR_SRR%SET_HEADER( '    PER    STP    WBS    SEG    RCH           RUNOFF       SFR_INFLOW      SFR_OUTFLOW             DELT   DYEAR         DATE_START           ISRR' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
      !
      IF(.NOT. SWF%SRRLOC(F)%FULLY) THEN
         IF(SWF%OUT_SFR_SRR%BINARY) THEN
                 WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F, Z, Z, SWF%SRRLOC(F)%LOST_RUNOFF, DZ, DZ, NEG
         ELSE
                 WRITE(IU, '(5I7, 4A17, 2x,F13.7, 2x,A, 2x,A)') KPER, KSTP, F, Z, Z, NUM2STR(SWF%SRRLOC(F)%LOST_RUNOFF), ZER, ZER, DT, DYEAR, DATE, '-1'
         END IF
         !
         DO I = ONE, SWF%SRRLOC(F)%N
          !
          IF(SWF%SRRLOC(F)%ISTRM(I) == Z) THEN
            OTFLOW = DZ
            INFLOW = DZ
          ELSE
            OTFLOW = STRM(9, SWF%SRRLOC(F)%ISTRM(I))
            INFLOW = STRM(10,SWF%SRRLOC(F)%ISTRM(I))
          END IF
          !
          IF(SWF%OUT_SFR_SRR%BINARY) THEN
                  WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), SWF%SRRLOC(F)%RUNOFF(I), INFLOW, OTFLOW, SWF%SRRLOC(F)%ISRR(I)
          ELSE
                  WRITE(IU, '(5I7, 4A17, 2x,F13.7, 2x,A, 2x,A)') KPER, KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), NUM2STR(SWF%SRRLOC(F)%RUNOFF(I)), NUM2STR(INFLOW), NUM2STR(OTFLOW), DT, DYEAR, DATE, NUM2STR(SWF%SRRLOC(F)%ISRR(I))
          END IF
         END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_SFR_RET(SWF, STRM, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    REAL, DIMENSION(:,:), CONTIGUOUS,          INTENT(IN   ):: STRM
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I
    DOUBLE PRECISION:: INFLOW, OTFLOW
    CHARACTER(17):: ZER, DT
    !
    IF(SWF%OUT_SFR_RET%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    ZER = '0.0'; ZER = ADJUSTR(ZER)
    !
    CALL SWF%OUT_SFR_RET%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_SFR_RET%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_SFR_RET%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER SFR_RETURN (SEMI_ROUTED_RETURN) INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), SEGMENT (INT), REACH (INT), RUNOFF (double), SFR_INFLOW (double), SFR_OUTFLOW (double), SRR ID (int)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !
            CALL SWF%OUT_SFR_RET%SET_HEADER( '    PER    STP    WBS    SEG    RCH           RUNOFF       SFR_INFLOW      SFR_OUTFLOW             DELT   DYEAR         DATE_START           ISRR' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
      !
      IF(SWF%OUT_SFR_RET%BINARY) THEN
              WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP, F, Z, Z, SWF%SRRLOC(F)%LOST_RUNOFF, INFLOW, OTFLOW, NEG
      ELSE
              WRITE(IU, '(5I7, 4A17, 2x,F13.7, 2x,A, 2x,A)') KPER, KSTP, F, Z, Z, NUM2STR(SWF%SRRLOC(F)%LOST_RUNOFF), ZER, ZER, DT, DYEAR, DATE, '-1'
      END IF
      !
      IF(SWF%SRRLOC(F)%FULLY) THEN
          DO I = ONE, SWF%SRRLOC(F)%N
             !
             OTFLOW = STRM(9, SWF%SRRLOC(F)%ISTRM(I))
             INFLOW = STRM(10,SWF%SRRLOC(F)%ISTRM(I))
             !
             IF(SWF%OUT_SFR_RET%BINARY) THEN
                     WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), SWF%SRRLOC(F)%RUNOFF(I), INFLOW, OTFLOW, SWF%SRRLOC(F)%ISRR(I), Z
             ELSE
                     WRITE(IU, '(5I7, 4A17, 2x,F13.7, 2x,A, 2x,A)') KPER, KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), NUM2STR(SWF%SRRLOC(F)%RUNOFF(I)), NUM2STR(INFLOW), NUM2STR(OTFLOW), DT, DYEAR, DATE, '0'
             END IF
          END DO
      ELSE
          DO I = ONE, SWF%SRRLOC(F)%N
           !
           IF(SWF%SRRLOC(F)%ISTRM(I) == Z) THEN
             OTFLOW = DZ
             INFLOW = DZ
           ELSE
             OTFLOW = STRM(9, SWF%SRRLOC(F)%ISTRM(I))
             INFLOW = STRM(10,SWF%SRRLOC(F)%ISTRM(I))
           END IF
           !
           IF(SWF%OUT_SFR_RET%BINARY) THEN
                   WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), SWF%SRRLOC(F)%RUNOFF(I), INFLOW, OTFLOW, SWF%SRRLOC(F)%ISRR(I)
           ELSE
                   WRITE(IU, '(5I7, 4A17, 2x,F13.7, 2x,A, 2x,A)') KPER, KSTP, F, SWF%SRRLOC(F)%SR(ONE,I), SWF%SRRLOC(F)%SR(TWO,I), NUM2STR(SWF%SRRLOC(F)%RUNOFF(I)), NUM2STR(INFLOW), NUM2STR(OTFLOW), DT, DYEAR, DATE, NUM2STR(SWF%SRRLOC(F)%ISRR(I))
           END IF
          END DO
      END IF
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_NRD_BUD_BYWBS(SWF, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I
    DOUBLE PRECISION:: DMD, SUP, CON
    CHARACTER(17):: DT
    !
    IF(SWF%OUT_NRD_BUD_WBS%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    !
    CALL SWF%OUT_NRD_BUD_WBS%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_NRD_BUD_WBS%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_NRD_BUD_WBS%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER NON_ROUTED_DELIVERY BY WBS INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), DEMAND (double), SUPPLY (double), CONSUMED (double)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !
            CALL SWF%OUT_NRD_BUD_WBS%SET_HEADER( '    PER    STP    WBS           DEMAND           SUPPLY         CONSUMED             DELT   DYEAR         DATE_START' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
      !
      DMD = SWF%NRD(F)%DEMAND
      SUP = SWF%NRD(F)%SUPPLY
      CON = SUM(SWF%NRD(F)%CONSUMED_WATER)
      !
      IF(DMD < DZ) DMD = DZ
      IF(SUP < DZ) SUP = DZ
      IF(CON < DZ) CON = DZ
      !
      IF(SWF%OUT_NRD_BUD_WBS%BINARY) THEN
              WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F,DMD, SUP, CON
      ELSE
              WRITE(IU, '(3I7, 4A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, NUM2STR(DMD), NUM2STR(SUP), NUM2STR(CON), DT, DYEAR, DATE
      END IF
      !
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE PRINT_OUT_NRD_BUD(SWF, KPER, KSTP, DELT, DYEAR, DATE)
    CLASS(SURFACE_WATER_DATA),                 INTENT(INOUT):: SWF
    INTEGER,                                   INTENT(IN   ):: KPER, KSTP
    DOUBLE PRECISION,                          INTENT(IN   ):: DELT
    DOUBLE PRECISION,                          INTENT(IN   ):: DYEAR
    CHARACTER(*),                              INTENT(IN   ):: DATE
    INTEGER:: IU, F, I, J
    DOUBLE PRECISION:: DMD, SUP, CON
    CHARACTER(17):: DT
    !
    IF(SWF%OUT_NRD_BUD%IU == Z) RETURN  !NOTHING TO PRINT OUT
    !
    DT = NUM2STR(DELT)
    DT = ADJUSTR(DT)
    !
    CALL SWF%OUT_NRD_BUD%SIZE_CHECK()  !CHECK SIZE EVERY 10 STRESS PERIODS
    !
    IU = SWF%OUT_NRD_BUD%IU
    !
    IF( (KPER==ONE .AND. KSTP==ONE) .OR. SWF%IOUT==IU )  THEN
        IF(SWF%OUT_NRD_BUD%BINARY) THEN 
            WRITE(SWF%IOUT,'(A,/A)')'SURFACE_WATER NON_ROUTED_DELIVERY BY WBS INFORMATION OUTPUT WRITTEN TO BINARY FILE USING STREAM UNFORMATTED STRUCTURE. EACH THE RECORD IN BINARY HAS THE FOLLOWING STRUCTURE:',"DATE_START (19char), DECIMAL YEAR (double), TIME STEP LENGTH (double), STRESS PERIOD (int), TIME STEP (int), WBS ID (INT), DEMAND (double), SUPPLY (double), CONSUMED (double)"
        ELSE
            !
            IF (SWF%IOUT==IU) WRITE(IU,*)
            !
            CALL SWF%OUT_NRD_BUD%SET_HEADER( '    PER    STP    WBS    NRD           DEMAND           SUPPLY         CONSUMED             DELT   DYEAR         DATE_START' )
        END IF
    END IF
    !
    DO F=ONE, SWF%NFARM
       DMD = SWF%NRD(F)%DEMAND
       IF(DMD < DZ) DMD = DZ
       DO I=ONE, SWF%MXNRD
         !
         SUP = SWF%NRD(F)%AVALIBLE_WATER(I)
         CON = SWF%NRD(F)%CONSUMED_WATER(I)
         !
         IF(SUP < DZ) SUP = DZ
         IF(CON < DZ) CON = DZ
         !
         IF(SUP > DZ) THEN
            IF(SWF%OUT_NRD_BUD%BINARY) THEN
                    WRITE(IU) DATE,DYEAR,DELT,KPER,KSTP,F,I, DMD, SUP, CON
            ELSE
                    WRITE(IU, '(4I7, 4A17, 2x,F13.7, 2x,A)') KPER, KSTP, F, I, NUM2STR(DMD), NUM2STR(SUP), NUM2STR(CON), DT, DYEAR, DATE
            END IF
         END IF
       END DO
    END DO
  END SUBROUTINE
  !
END MODULE
!
!#########################################################################################################
!
