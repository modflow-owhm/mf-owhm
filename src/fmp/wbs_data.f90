!
!#########################################################################################################
!
MODULE WBS_DATA_FMP_MODULE
  !
  USE FMP_DIMENSION_MODULE, ONLY: FMP_DIMENSION
  !
  USE GLOBAL, ONLY: DIS_AREA => AREA, KND
  !
  USE CONSTANTS
  USE ULOAD_AND_SFAC_INTERFACE,          ONLY: ULOAD
  USE ERROR_INTERFACE,                   ONLY: STOP_ERROR, WARNING_MESSAGE, FILE_IO_ERROR
  USE PARSE_WORD_INTERFACE,              ONLY: PARSE_WORD, PARSE_WORD_UP
  USE STRINGS,                           ONLY: UPPER
  USE UTIL_INTERFACE,                    ONLY: NEAR_ZERO
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE ALLOC_INTERFACE,                   ONLY: ALLOC
  USE ARRAY_DATA_TYPES,                  ONLY: COMPRESSED_VALUE_STORAGE
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE LIST_ARRAY_INPUT_INTERFACE,        ONLY: LIST_ARRAY_INPUT, LIST_ARRAY_INPUT_INT
  USE LINKED_LIST_INSTRUCTION,           ONLY: INTEGER_LINKED_LIST
  USE WARNING_TYPE_INSTRUCTION,          ONLY: WARNING_TYPE
  !
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: WBS_DATA, INITIALIZE_WBS_DATA
  !  
  TYPE FARMLOCATION
    INTEGER:: NF=Z                                         !--NOT CURRENTLY SUPPORTED, WILL EVENTUALLY HOLD THE FARM ID WHEN THE INDEX IS NO LONGER HARDWIRED AS THE FID
    INTEGER:: Count=Z                                      ! TOTAL NUMBER OF CELLS THAT CONTRAIN THE FARM [FARMLOCATION(1) REFERS TO FARM 1]
    DOUBLE PRECISION:: AREA                                ! FARM TOTAL AREA (INCLUDES BARE LAND, NON-IRRIGIGATED, AND IRRIGATED CROPS)
    INTEGER, DIMENSION(:,:),ALLOCATABLE:: RC               ! LOC(1,:) CONTAINS THE ROW LOCATION OF THE FARM; LOC(2,:) CONTAINS THE COL LOCATION OF THE FARM
  END TYPE
  !
  TYPE FARM_RELATIONSHIP
      INTEGER:: PROJ=Z
      INTEGER:: DIST=Z
      INTEGER:: UNIT=Z
  END TYPE
  !
  TYPE UNIT_RELATIONSHIP
      INTEGER:: NFARM=Z, NAUX=Z
      INTEGER:: PROJ=Z, DIST=Z
      INTEGER,DIMENSION(:),ALLOCATABLE:: FARM
      INTEGER,DIMENSION(:),ALLOCATABLE:: AUX
  END TYPE
  !
  TYPE DIST_RELATIONSHIP
      INTEGER:: NUNIT=Z, NFARM=Z, NAUX=Z
      INTEGER:: PROJ=Z
      INTEGER,DIMENSION(:),ALLOCATABLE:: UNIT
      INTEGER,DIMENSION(:),ALLOCATABLE:: FARM
      INTEGER,DIMENSION(:),ALLOCATABLE:: AUX
  END TYPE
  !
  TYPE PROJ_RELATIONSHIP
      INTEGER:: NDIST=Z, NUNIT=Z, NFARM=Z, NAUX=Z
      INTEGER,DIMENSION(:),ALLOCATABLE:: DIST
      INTEGER,DIMENSION(:),ALLOCATABLE:: UNIT
      INTEGER,DIMENSION(:),ALLOCATABLE:: FARM
      INTEGER,DIMENSION(:),ALLOCATABLE:: AUX
  END TYPE
  !
  TYPE CROP_POINTER
      INTEGER:: N = Z
      INTEGER,DIMENSION(:,:),ALLOCATABLE:: PNT
  END TYPE
  !
  TYPE WBS_SUPPLY
      DOUBLE PRECISION:: TOTAL   = DZ
      DOUBLE PRECISION:: USED    = DZ
      DOUBLE PRECISION:: CROP    = DZ
      DOUBLE PRECISION:: SFR     = DZ
      DOUBLE PRECISION:: WEL     = DZ
      DOUBLE PRECISION:: NRD     = DZ
      DOUBLE PRECISION:: MAGIC   = DZ
      DOUBLE PRECISION:: SFR_TOT = DZ
      DOUBLE PRECISION:: WEL_TOT = DZ
      DOUBLE PRECISION:: NRD_TOT = DZ
      LOGICAL::          HAS_MAGIC = FALSE
      !DOUBLE PRECISION:: SWR     = DZ
      !DOUBLE PRECISION:: SWR_TOT = DZ
      CONTAINS
      PROCEDURE, PASS(SUP):: INIT=>INIT_SUPPLY
      PROCEDURE, PASS(SUP):: SET_TOTAL  !--DOES NOT INCLUDE MAGIC
      PROCEDURE, PASS(SUP):: SET_USED   !--INCLUDES MAGIC
      PROCEDURE, PASS(SUP):: SET_MAGIC
      PROCEDURE, PASS(SUP):: SET_SFR
      PROCEDURE, PASS(SUP):: SET_WEL
      PROCEDURE, PASS(SUP):: SET_NRD
      PROCEDURE, PASS(SUP):: SET_SFR_TOT
      PROCEDURE, PASS(SUP):: SET_WEL_TOT
      PROCEDURE, PASS(SUP):: SET_NRD_TOT
      !PROCEDURE, PASS(SUP):: SET_SWR
  END TYPE
  !
  TYPE WATER_SOURCES
      LOGICAL,DIMENSION(:),ALLOCATABLE:: GW,SW,NRD
      CONTAINS
      PROCEDURE,PASS(SRC):: ALLOC => ALLOCATE_WATER_SOURCES!(N)
  END TYPE
  
  !
  !TYPE FALLOW_ORDER
  !    INTEGER:: NF, N
  !    INTEGER,DIMENSION(:), ALLOCATABLE:: CROP
  !END TYPE
  !
  TYPE WBS_DATA
      !
      INTEGER:: NFARM, NCROP
      INTEGER:: NPROJ, NDIST, NUNIT, NAUXDEM
      INTEGER:: NROW, NCOL, ITMUNI
      INTEGER:: IOUT=Z, LOUT=Z
      INTEGER:: PRORATE_DEFICIENCY = ONE
      !
      LOGICAL,                 DIMENSION(:), ALLOCATABLE:: INUSE
      !
      TYPE(FARMLOCATION),      DIMENSION(:), ALLOCATABLE:: FID
      TYPE (FARM_RELATIONSHIP),DIMENSION(:), ALLOCATABLE:: FARM, AUX_DEMAND
      TYPE (PROJ_RELATIONSHIP),DIMENSION(:), ALLOCATABLE:: PROJ
      TYPE (DIST_RELATIONSHIP),DIMENSION(:), ALLOCATABLE:: DIST
      TYPE (UNIT_RELATIONSHIP),DIMENSION(:), ALLOCATABLE:: UNIT
      TYPE (CROP_POINTER),DIMENSION(:),      ALLOCATABLE:: CROP
      TYPE (WBS_SUPPLY),  DIMENSION(:),      ALLOCATABLE:: SUPPLY
      TYPE(WATER_SOURCES):: H2OSOURCE
      !TYPE(FALLOW_ORDER)      ,DIMENSION(:), ALLOCATABLE:: FALLOW
      !
      LOGICAL:: NEW_FID = TRUE  !SET TO FALSE IF STRESS PERIOD IS REUSING PREVIOUS STRESS PERIODS FID
      !
      INTEGER,                 DIMENSION(:),   ALLOCATABLE:: FALLOW_RANK, MAX_FALLOW_RANK
      INTEGER,                 DIMENSION(:,:), ALLOCATABLE:: FID_ARRAY
      INTEGER,                 DIMENSION(:,:), ALLOCATABLE:: HIERARCHY_ARRAY
      !
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: GSE
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: AREA
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: DPERC
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: RUNOFF
      !
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: DEMAND
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: DEMAND_INI
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: DEMAND_POT
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: Q_DEMAND
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: Q_DEMAND_INI
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: CROP_DEMAND      !Total demand -- includes added
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: CROP_DEMAND_ADDED
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TOT_DIR_RCH
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TOT_DPERC
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TOT_RUNOFF
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TOT_FNRCH
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: TTOT, ETOT, TGWA, EGWA, TIRR, EIRR
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: PRECIP, TPRECIP, EPRECIP
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: IRR_AREA
      DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: EFF
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: CROP_VOLR
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: CROP_FLUX
      !DOUBLE PRECISION,        DIMENSION(:),   ALLOCATABLE:: BARE_AREA
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: CROP_DEMAND_ARRAY
      DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: FNRCH
      !INTEGER,                 DIMENSION(:,:), ALLOCATABLE:: WATERSTACK
      !DOUBLE PRECISION,        DIMENSION(:,:), ALLOCATABLE:: OFE
      !
      CHARACTER(20)           ,DIMENSION(:), ALLOCATABLE:: FARM_NAME
      CHARACTER(20)           ,DIMENSION(:), ALLOCATABLE:: PROJ_NAME, DIST_NAME, UNIT_NAME
      !
      TYPE(LIST_ARRAY_INPUT_INT):: HIERARCHY_TFR
      TYPE(LIST_ARRAY_INPUT_INT):: FID_TFR, FALLOW_RANK_TFR, DEFICIENCY, H2OSOURCE_TFR, EFF_IMPROVE_TFR!, FALLOW_TFR
      TYPE(LIST_ARRAY_INPUT    ):: EFF_TFR
      TYPE(LIST_ARRAY_INPUT    ):: ADRF_TFR
      TYPE(LIST_ARRAY_INPUT    ):: CROP_VOLR_TFR
      TYPE(LIST_ARRAY_INPUT    ):: CROP_FLUX_TFR
      !TYPE(LIST_ARRAY_INPUT    ):: EFL_TFR
      TYPE(LIST_ARRAY_INPUT):: BARE_FRAC_RUNOFF
      !TYPE(LIST_ARRAY_INPUT):: BARE_FRAC_PRECIP
      !INTEGER,DIMENSION(:,:), ALLOCATABLE:: FID_ARRAY, HIERARCHY_ARRAY, EFF
      !
      LOGICAL:: UZF_LINK
      LOGICAL:: HAS_HIERARCHY
      LOGICAL:: HAS_WATERSTACK = FALSE
      LOGICAL:: HAS_CROP = FALSE
      LOGICAL:: HAS_WELL = FALSE
      LOGICAL:: HAS_ALLOT= FALSE
      LOGICAL:: HAS_SOIL = FALSE
      LOGICAL:: HAS_CLIM = FALSE
      LOGICAL:: HAS_SWO  = FALSE
      LOGICAL:: HAS_SALT = FALSE
      LOGICAL:: HAS_SFR  = FALSE  ! Must set outside of datatype, such as:  WBS%HAS_SFR  = IUNITSFR  .NE. Z
      LOGICAL:: HAS_UZF  = FALSE  ! Ditto
      LOGICAL:: HAS_MNW1 = FALSE  ! Ditto
      LOGICAL:: HAS_MNW2 = FALSE  ! Ditto
      LOGICAL:: HAS_DRT  = FALSE  ! Ditto
      LOGICAL:: HAS_NWT  = FALSE  ! Ditto
      LOGICAL:: HAS_UPW  = FALSE  ! Ditto
      LOGICAL:: HAS_CROP_VOLR
      LOGICAL:: HAS_CROP_FLUX
      LOGICAL:: EFF_IMPROVE = FALSE
      !
      LOGICAL, DIMENSION(:),ALLOCATABLE:: WBS_HAS_ADMD
      LOGICAL, DIMENSION(:),ALLOCATABLE:: CRP_HAS_ADMD
      !
      LOGICAL:: TFR_READ
      !
      CONTAINS
      !
      PROCEDURE, PASS(WBS):: NEXT => SETUP_NEXT_STRESS_PERIOD
      !
      PROCEDURE, PASS(WBS):: SETUP_NO_WBS_DATA
      PROCEDURE, PASS(WBS):: SETUP_FID_RC
      PROCEDURE, PASS(WBS):: SETUP_FARM_HIERARCHY_POINTERS
      PROCEDURE, PASS(WBS):: SETUP_FALLOW_FRACTION_ARRAY
      PROCEDURE, PASS(WBS):: SUM_WBS_DEMAND!(WBS)
      PROCEDURE, PASS(WBS):: SUM_WBS_PRECIP!(CLIM%PRECIP)
      PROCEDURE, PASS(WBS):: SUM_WBS_RUNOFF_DPERC
      PROCEDURE, PASS(WBS):: SUM_WBS_DIRECT_RECHARGE
      PROCEDURE, PASS(WBS):: SUM_WBS_FNRCH
      PROCEDURE, PASS(WBS):: CHECK_SOIL_ID
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE SETUP_BASIC_VAR_WBS_DATA( WBS, FDIM, IOUT )  
    CLASS(WBS_DATA),     INTENT(INOUT):: WBS
    TYPE(FMP_DIMENSION), INTENT(IN   ):: FDIM
    INTEGER,             INTENT(IN   ):: IOUT
    INTEGER:: NROW, NCOL, NFARM, I
    !
    NROW  = FDIM%NROW
    NCOL  = FDIM%NCOL
    !
    NFARM  = FDIM%NFARM
    IF(NFARM < ONE) NFARM = ONE
    !
    WBS%ITMUNI=FDIM%ITMUNI
    WBS%NCOL = FDIM%NCOL
    WBS%NROW = FDIM%NROW
    !
    WBS%NFARM = NFARM
    WBS%NCROP = FDIM%NCROP
    WBS%NPROJ = FDIM%NPROJ
    WBS%NDIST = FDIM%NDIST
    WBS%NUNIT = FDIM%NUNIT
    WBS%NAUXDEM = FDIM%NAUXDEM
    WBS%UZF_LINK = FDIM%UZF_LINK
    !
    WBS%IOUT = IOUT
    WBS%LOUT = IOUT
    WBS%HAS_HIERARCHY = FDIM%HAS_HIERARCHY
    WBS%TFR_READ      = FALSE
    !
    WBS%HAS_CROP_FLUX = FALSE
    WBS%HAS_CROP_VOLR = FALSE
    !
    ALLOCATE(WBS%INUSE(WBS%NFARM), SOURCE=FALSE)
    !
    ALLOCATE(WBS%FID(WBS%NFARM))
    DO CONCURRENT(I=ONE:WBS%NFARM) 
                                  WBS%FID(I)%NF = I
    END DO
    !
    ALLOCATE( WBS%DEMAND      (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%DEMAND_INI  (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%DEMAND_POT  (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%Q_DEMAND    (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%Q_DEMAND_INI(WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%CROP_DEMAND (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TOT_DPERC   (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TOT_DIR_RCH (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TOT_RUNOFF  (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TOT_FNRCH   (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%EFF         (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%PRECIP      (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TPRECIP     (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%EPRECIP     (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TTOT        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%ETOT        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TIRR        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%EIRR        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%TGWA        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%EGWA        (WBS%NFARM), SOURCE = DZ )
    ALLOCATE( WBS%IRR_AREA    (WBS%NFARM), SOURCE = DZ )
    !
    ALLOCATE( WBS%SUPPLY      (WBS%NFARM) )
    ALLOCATE( WBS%CROP        (WBS%NFARM) )
    ALLOCATE( WBS%FARM        (WBS%NFARM) )
    ALLOCATE( WBS%FARM_NAME   (WBS%NFARM) )
    !
    ALLOCATE(WBS%CROP_DEMAND_ADDED(WBS%NFARM), SOURCE = DZ)
    !
    IF(WBS%NAUXDEM > Z) ALLOCATE(WBS%AUX_DEMAND(WBS%NAUXDEM))
    !
    ALLOCATE(WBS%FID_ARRAY        (NCOL, NROW), SOURCE = NINER )
    ALLOCATE(WBS%FNRCH            (NCOL, NROW) , &
             WBS%CROP_DEMAND_ARRAY(NCOL, NROW) , &
             WBS%DPERC            (NCOL, NROW) , &
             WBS%RUNOFF           (NCOL, NROW), SOURCE=DZ )
    !
    CALL WBS%H2OSOURCE%ALLOC(WBS%NFARM)
    WBS%H2OSOURCE%GW  = TRUE
    !
    IF( WBS%HAS_SFR ) THEN
      WBS%H2OSOURCE%SW  = TRUE
    ELSE 
      WBS%H2OSOURCE%SW  = FALSE
    END IF
    !
    WBS%H2OSOURCE%NRD = TRUE
    !    
    ALLOCATE(WBS%AREA(NCOL, NROW))
    WBS%AREA = DIS_AREA    !REDUNDANT FROM BAS BECAUSE THERE MAYBE A TIME TO HAVE FMP GRID BE INDEPENDENT OF MODEL GRID.  --WHEN MADE GRID INDEPENDENT, REMOVE AND CALCULATE AREA
    !
    DO CONCURRENT (I=ONE:WBS%NFARM)
                                 WBS%FARM(I)%UNIT = I
                                 WBS%FARM(I)%DIST = I
                                 WBS%FARM(I)%PROJ = I    
    END DO
    !
    IF(WBS%HAS_HIERARCHY) THEN
                              ALLOCATE(WBS%HIERARCHY_ARRAY(THREE, NFARM + FDIM%NAUXDEM), SOURCE=Z)
                              ALLOCATE(WBS%PROJ(FDIM%NPROJ))
                              ALLOCATE(WBS%DIST(FDIM%NDIST))
                              ALLOCATE(WBS%UNIT(FDIM%NUNIT))
                              !
                              ALLOCATE(WBS%PROJ_NAME(FDIM%NPROJ))
                              ALLOCATE(WBS%DIST_NAME(FDIM%NDIST))
                              ALLOCATE(WBS%UNIT_NAME(FDIM%NUNIT))
                              WBS%PROJ_NAME = BLNK
                              WBS%DIST_NAME = BLNK
                              WBS%UNIT_NAME = BLNK
    END IF
    ! 
    DO CONCURRENT(I=ONE:WBS%NFARM)
                        WBS%FARM_NAME(I) = 'FARM_'//NUM2STR(I,THREE,TRUE)
    END DO
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_WBS_DATA( BL, WBS, LINE, FDIM )  
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL   !DATA BLOCK
    CLASS(WBS_DATA),             INTENT(INOUT):: WBS
    CHARACTER(*),                INTENT(INOUT):: LINE
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    !DOUBLE PRECISION, DIMENSION(:,:), CONTIGUOUS,INTENT(IN   ):: AREA
    CHARACTER(5):: ERROR
    LOGICAL:: EOF
    INTEGER:: LLOC, ISTART, ISTOP, IU, NIRRG, NCROP
    CHARACTER(6):: BYFARM, BYCROP
    TYPE(WARNING_TYPE):: WARN_MSG
    BYFARM = 'BYWBS'
    BYCROP = 'BYCROP'
    !
    WRITE(BL%IOUT,'(/A/)') 'WBS BLOCK FOUND AND NOW LOADING PROPERTIES'
    !
    CALL SETUP_BASIC_VAR_WBS_DATA( WBS, FDIM, BL%IOUT )  
    !
    IF(FDIM%NFARM < ONE) THEN
        CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: THE GLOBAL DIMENSION BLOCK SPECIFIED NWBS WITH A VALUE LESS THAN 1.'//NL// &
                                                'THE WBS BLOCK WILL BE SKIPPED AND ALL ITS INPUT IGNORED.'//BLN//                           &
                                                'NWBS IS RESET TO 1 WITH THE ENTIRE MODEL GRID SET TO THE SAME WBS'//NL//                   &
                                                'That is: "LOCATION STATIC LIST CONSTANT 1"', CMD_PRINT=TRUE)
        CALL SETUP_NO_WBS_DATA( WBS, FDIM, BL%IU, BL%IOUT )
        RETURN
    END IF
    !
    ERROR='ERROR'
    CALL WARN_MSG%INIT()
    !
    NCROP = FDIM%NCROP
    IF(NCROP < ONE) NCROP = ONE
    !
    NIRRG = FDIM%NIRRG
    IF(NIRRG < ONE) NIRRG = ONE
    !
    CALL BL%MAKE_SCRATCH_FILE()
    !
    !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE
    CALL BL%READ_SCRATCH(EOF,LINE)
    !
    DO WHILE (.NOT. EOF)
      !
      LLOC=ONE
      CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
      !
      SELECT CASE ( LINE(ISTART:ISTOP) )
      ! %INIT(TYP, LLOC, LINE, IOUT, IN, LDIM1, LDIM2, NROW, NCOL,EX1_DIM, EX1_WORD, EX2_DIM, EX2_WORD)
      CASE ("LOCATION")
                        WRITE(BL%IOUT,'(A)') '   LOCATION                         KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND FIRST LOCATION ARRAY.'
                        CALL WBS%FID_TFR%INIT('LOCATION', LLOC, LINE, BL%IOUT, BL%IU, Z, Z, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH)  !, FDIM%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
      !
      CASE ("DEFICIENCY","DEFICIENCY_SCENARIO")
                        IF(LINE(ISTART:ISTOP) == "DEFICIENCY") CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
                        WRITE(BL%IOUT,'(A)') '   DEFICIENCY_SCENARIO              KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST INPUT OF DEFICIENCY FLAG BY WBS.'
                        CALL WBS%DEFICIENCY%INIT('DEFICIENCY_SCENARIO', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, ONE, Z, Z, SCRATCH=BL%SCRATCH)  !, FDIM%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
      !
      CASE ("PRORATE","PRORATE_DEFICIENCY")
                        IF(LINE(ISTART:ISTOP) == "PRORATE") CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
                        WRITE(BL%IOUT,'(A)') '   PRORATE_DEFICIENCY               KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST INPUT OF DEFICIENCY FLAG BY WBS.'
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE(LINE(ISTART:ISTOP))
                        CASE("BYAVERAGE","BYAVE"); WBS%PRORATE_DEFICIENCY = Z   !BY AVERAGE SUPPLY
                        CASE("BYDEMAND");          WBS%PRORATE_DEFICIENCY = ONE !   --DEFAULT
                        CASE DEFAULT;              CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FOUND "PRORATE_DEFICIENCY" KEYWORD,'//NL//'WHICH MUST BE FOLLOWED BY EITHER "ByAVERAVE" OR "ByDEMAND".')
                        END SELECT
      !
      CASE ("EFFICIENCY", "EFF")
                        WRITE(BL%IOUT,'(A)') '   EFFICIENCY (EFF)                 KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF EFFICIENCIES.'
                        IF(FDIM%NIRRG > Z) THEN
                            CALL WBS%EFF_TFR%INIT('EFF', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, FDIM%NIRRG, FDIM%NROW, FDIM%NCOL, WBS%NFARM, BYFARM, NCROP, BYCROP, FDIM%NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)  !, MSG='ALSO PLEASE DOUBLE CHECK THAT NIRRIGATE IN THE GLOBAL DIMENSION BLOCK IS SET UP CORRECTLY. EFFICIENCY EXPECTS TO READ AN ID COLUMN AND THEN NIRRIGATE COLUMNS OF EFECIENCIES.'
                        ELSE
                            CALL WBS%EFF_TFR%INIT('EFF', DZ, BL%IOUT, BL%IU, WBS%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
                            CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: FOUND KEYWORD "EFFICIENCY" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EFFICIENCY SET TO 0.0 FOR ALL WBS (FARMS).',CMD_PRINT=TRUE)
                        END IF
                        !
      CASE ("EFFICIENCY_IMPROVEMENT","EFF_IMPROVE")
                        WRITE(BL%IOUT,'(A)') '   EFFICIENCY_IMPROVEMENT           KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF EFFICIENCY IMPROVEMENT FLAGS (0 OR 1).'
                        IF(FDIM%NIRRG > Z) THEN
                            CALL WBS%EFF_IMPROVE_TFR%INIT('EFF_IMPROVE', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, FDIM%NIRRG, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                        ELSE
                            CALL WBS%EFF_IMPROVE_TFR%INIT('EFF_IMPROVE', Z, BL%IOUT, BL%IU, WBS%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
                            CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: FOUND KEYWORD "EFFICIENCY_IMPROVEMENT" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE IMPROVEMENT FLAG SET TO 0 FOR ALL WBS (FARMS).',CMD_PRINT=TRUE)
                        END IF
                        !
      CASE ("ADDED_DEMAND_RUNOFF_SPLIT", "ADRS")
                        WRITE(BL%IOUT,'(A)') '   ADDED_DEMAND_RUNOFF_SPLIT (ADRS) KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF EFFICIENCIES.'
                        IF(FDIM%NIRRG > Z) THEN
                            CALL WBS%ADRF_TFR%INIT('ADRS', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, FDIM%NIRRG, FDIM%NROW, FDIM%NCOL, WBS%NFARM, BYFARM, NCROP, BYCROP, FDIM%NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                        ELSE
                            CALL WBS%ADRF_TFR%INIT('ADRS', DZ, BL%IOUT, BL%IU, WBS%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
                            CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: FOUND KEYWORD "ADDED_DEMAND_RUNOFF_SPLIT" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EFFICIENCY SET TO 0.0 FOR ALL WBS (FARMS).',CMD_PRINT=TRUE)
                        END IF
                        !
      CASE ("ADDED_CROP_DEMAND","CDMD")
                        WRITE(BL%IOUT,'(A)') '   ADDED_CROP_DEMAND (CDMD)         KEYWORD FOUND. NOW LOADING LENGTH (OR FLUX) OR RATE KEYWORDS THEN STATIC/TRANSIENT KEYWORD AND THEN LIST/ARRAY KEYWORD.'
                        IF(FDIM%NCROP < ONE) CALL STOP_ERROR(OUTPUT=WBS%LOUT, MSG='FMP WBS BLOCK ERROR. YOU CAN ONLY SPECIFY KEYWORD "ADDED_CROP_DEMAND"'//NL//'IF THE GLOBAL DIMENSION BLOCK HAS NCROP>0.'//NL//'THAT IS YOU MUST HAVE AT LEAST ONE LAND USE DEFINED.')
                        !
                        CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                        SELECT CASE ( LINE(ISTART:ISTOP) )
                        CASE("LENGTH","FLUX")
                                               IF(WBS%CROP_FLUX_TFR%INUSE) CALL STOP_ERROR(OUTPUT=WBS%LOUT, MSG='FMP WBS BLOCK ERROR. YOU MAY ONLY SPECIFY KEYWORD "ADDED_CROP_DEMAND LENGTH" AT MOST ONE TIME. YOU MY SPECIFY "ADDED_CROP_DEMAND LENGTH" AND "ADDED_CROP_DEMAND RATE" AS TWO SEPARATE INPUTS (DIFFERENT LINES), BUT YOU MAY NOT SPECIFY THEM TWICE.')
                                               CALL WBS%CROP_FLUX_TFR%INIT('CDMD_FLUX',LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, NCROP, Z, Z, WBS%NFARM, BYFARM, NCROP, BYCROP,SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                                               ALLOCATE(WBS%CROP_FLUX(WBS%NFARM, NCROP))
                        CASE("RATE")
                                               IF(WBS%CROP_VOLR_TFR%INUSE) CALL STOP_ERROR(OUTPUT=WBS%LOUT, MSG='FMP WBS BLOCK ERROR. YOU MAY ONLY SPECIFY KEYWORD "ADDED_CROP_DEMAND RATE" AT MOST ONE TIME. YOU MY SPECIFY "ADDED_CROP_DEMAND RATE" AND "ADDED_CROP_DEMAND LENGTH" AS TWO SEPARATE INPUTS (DIFFERENT LINES), BUT YOU MAY NOT SPECIFY THEM TWICE.')
                                               CALL WBS%CROP_VOLR_TFR%INIT('CDMD_VOLR',LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, NCROP, Z, Z, WBS%NFARM, BYFARM, NCROP, BYCROP,SCRATCH=BL%SCRATCH, LISTARRAY=TRUE)
                                               ALLOCATE(WBS%CROP_VOLR(WBS%NFARM, NCROP))
                        CASE DEFAULT;          CALL STOP_ERROR(OUTPUT=WBS%LOUT, MSG='FMP WBS BLOCK ERROR. IF YOU SPECIFY KEYWORD "ADDED_CROP_DEMAND", YOU MUST FOLLOW IT WITH THE KEYWORD "LENGTH" OR "RATE"'//NL//'TO INDICATE ADDED DEMAND IS LENGTH PER TIME OR VOLUME PER TIME.')
                        END SELECT
                        !
      CASE ("BARE_RUNOFF_FRACTION", "FALLOW_RUNOFF_FRACTION", "BARE_RUNOFF_FRAC", "BFR")
                        WRITE(BL%IOUT,'(A)') '   BARE_RUNOFF_FRACTION (BFR)       KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF FRACTIONS.'
                        CALL WBS%BARE_FRAC_RUNOFF%INIT('BFR',LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, ONE, FDIM%NROW, FDIM%NCOL, WBS%NFARM, BYFARM, SCRATCH=BL%SCRATCH)
                        !
      !CASE ("BARE_PRECIP_CONSUMPTION_FRACTION", "BARE_PRECIPITATION_CONSUMPTION_FRACTION", "BFP")
      !                  WRITE(BL%IOUT,'(A)') '   BARE_RUNOFF_FRACTION (BFR)       KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF FRACTIONS.'
      !                  CALL WBS%BARE_FRAC_PRECIP%INIT('BFR',LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, ONE, FDIM%NROW, FDIM%NCOL, WBS%NFARM, BYFARM, SCRATCH=BL%SCRATCH)
      !
      CASE ("WATERSOURCE", "WATER_SOURCE", "H2OSRC")
                        IF(LINE(ISTART:ISTOP) == "WATER") CALL PARSE_WORD(LINE,LLOC,ISTART,ISTOP)
                        WRITE(BL%IOUT,'(A)') '   WATER_SOURCE (H2OSRC)                         KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST OF FARMS AND WHAT WATER SOURCES THEY HAVE TO PROVIDE WATER SUPPLIES.'
                        CALL WBS%H2OSOURCE_TFR%INIT('H2OSRC', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, THREE, Z, Z, SCRATCH=BL%SCRATCH)  !, WBS%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
      !
      CASE ("HIERARCHY")
                        WRITE(BL%IOUT,'(A)') '   HIERARCHY                        KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND FIRST LIST OF HIERARCHYS.'
                        IF(.NOT. WBS%HAS_HIERARCHY) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FOUND "HIERARCHY" KEYWORD, WHICH REQUIRES REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
                        CALL WBS%HIERARCHY_TFR%INIT('HIERARCHY', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM+FDIM%NAUXDEM, THREE, Z, Z, SCRATCH=BL%SCRATCH)  !, WBS%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
      !
      CASE ("WBS_NAME","FARM_NAME", "NAME")
                        WRITE(BL%IOUT,'(A)') '   FARM_NAME                        KEYWORD FOUND. NOW LOADING WBS NAMES.'
                        IU = Z
                        CALL ULOAD(WBS%FARM_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
      CASE ("PROJ_NAME")
                        WRITE(BL%IOUT,'(A)') '   PROJ_NAME                        KEYWORD FOUND. NOW LOADING PROJECT NAMES.'
                        IF(WBS%HAS_HIERARCHY) THEN
                            IU = Z
                            CALL ULOAD(WBS%PROJ_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
                        ELSE
                            CALL STOP_ERROR(LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='FOUND KEYWORD "PROJ_NAME", WHICH REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
                        END IF
      CASE ("DIST_NAME")
                        WRITE(BL%IOUT,'(A)') '   DIST_NAME                        KEYWORD FOUND. NOW LOADING DSTRICT NAMES.'
                        IF(WBS%HAS_HIERARCHY) THEN
                            IU = Z
                            CALL ULOAD(WBS%DIST_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
                        ELSE
                            CALL STOP_ERROR(LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='FOUND KEYWORD "DIST_NAME", WHICH REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
                        END IF
      CASE ("UNIT_NAME")
                        WRITE(BL%IOUT,'(A)') '   UNIT_NAME                        KEYWORD FOUND. NOW LOADING UNIT NAMES.'
                        IF(WBS%HAS_HIERARCHY) THEN
                            IU = Z
                            CALL ULOAD(WBS%UNIT_NAME, LLOC, LINE, BL%IOUT, BL%IU, IU, SCRATCH=BL%SCRATCH)
                        ELSE
                            CALL STOP_ERROR(LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG='FOUND KEYWORD "UNIT_NAME", WHICH REQUIRES THAT "NPROJ", "NDIST", AND "NUNIT" BE SPECIFIED AND SET TO GREATER THAN ZERO IN THE GLOBAL DIMENSION BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.')
                        END IF
      CASE DEFAULT
                        CALL WARN_MSG%ADD('FOUND UNKNOWN KEYWORD "'//LINE(ISTART:ISTOP)//'" ***IT WILL BE IGNORED***'//BLN)
      !
      !!!CASE ("IRRIGATION_IMMEDIATE_EVAPORATION")
      !!!                  WRITE(BL%IOUT,'(A)') '   EVAPORATION_LOSS_FRACTION KEYWORD FOUND. NOW LOADING LIST/ARRAY KEY AND STATIC/TRANSIENT KEYWORDS AND FIRST SET OF EFFICIENCIES.'
      !!!                  IF(FDIM%NIRRG > Z) THEN
      !!!                      CALL WBS%EFL_TFR%INIT('ELF', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, FDIM%NIRRG, FDIM%NROW, FDIM%NCOL, WBS%NFARM, BYFARM, FDIM%NCROP, BYCROP, FDIM%NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH)
      !!!                  ELSE
      !!!                      LLOC=ONE
      !!!                      LINE = 'CONSTANT 0.0D0 '
      !!!                      CALL WBS%EFL_TFR%INIT('ELF', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, WBS%NFARM, BYFARM, FDIM%NCROP, BYCROP, NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH)
      !!!                      CALL WARNING_MESSAGE(OUTPUT=BL%IOUT,MSG='FMP WBS BLOCK: FOUND KEYWORD "" WHEN NIRRIGATE = 0. THIS LINE WILL BE IGNORED AND THE EFFICIENCY SET TO 0.0 FOR ALL WBS (FARMS).',CMD_PRINT=TRUE)
      !!!                  END IF
      !
      !CASE ("FALLOW_RANK")
      !                  WRITE(BL%IOUT,'(A)') '   FALLOW_RANK         KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST OF FARMS OR LOCATIONS THAT ALLOW WATER STACKING. MAKE SURE TO SET THE "FOLLOW" KEYWORD.'
      !                  CALL WBS%FALLOW_RANK_TFR%INIT('WSTACK', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, FDIM%NCROP, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH) 
      !                  ALLOCATE(WBS%FALLOW_RANK(WBS%NFARM), WBS%MAX_FALLOW_RANK(WBS%NFARM))
      !                  WBS%HAS_WATERSTACK = TRUE
      !
      !CASE ("FALLOW_RESET")
      !                  WRITE(BL%IOUT,'(A)') '   FALLOW_RESET KEYWORD FOUND. NOW LOADING STATIC/TRANSIENT KEYWORD AND LIST OF FARMS OR LOCATIONS THAT ALLOW WATER STACKING. MAKE SURE TO SET THE "FOLLOW" KEYWORD.'
      !                  CALL WBS%FALLOW_RESET_TFR%INIT('WSTACK', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, FDIM%NCROP, FDIM%NROW, FDIM%NCOL, SCRATCH=BL%SCRATCH) 
      END SELECT
      !
      !READ(BL%SCRATCH, '(A)', IOSTAT=IERR) LINE 
      CALL BL%READ_SCRATCH(EOF, LINE)
      !
    END DO
    !
    CALL WARN_MSG%CHECK(HED='FMP WBS BLOCK'//NL,INFILE=BL%IU,OUTPUT=BL%IOUT,INLINE=TRUE,CMD_PRINT=TRUE,TAIL=NL,INIT=TRUE)
    !
    IF(.NOT. WBS%FID_TFR%INUSE) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FAILED TO LOCATE KEYWORD "LOCATION" WITHIN FMP WBS BLOCK. PLEASE DOUBLE CHECK BLOCK SET UP.') 
    IF(.NOT. WBS%EFF_TFR%INUSE) THEN
        IF(FDIM%NIRRG>Z) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='FAILED TO LOCATE KEYWORD "EFFICIENCY" WITHIN FMP WBS BLOCK.'//BLN//'IT IS A REQUIRED INPUT IF YOU HAVE NIRRIGATE > 0.'//BLN//'IF YOU DO NOT HAVE IRRIGATION, YOU MUST SET NIRRIGATE=0 IN THE GLOBAL DIMENSION BLOCK.'//BLN//'PLEASE DOUBLE CHECK BLOCK SET UP.') 
        !
        CALL WBS%EFF_TFR%INIT('EFF', DZ, BL%IOUT, BL%IU, WBS%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
    END IF
    !
    IF(.NOT. WBS%ADRF_TFR%INUSE .AND. FDIM%NIRRG>Z) THEN
        !CALL WBS%ADRF_TFR%INIT('ADRS', TENTH, BL%IOUT, BL%IU, WBS%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
        CALL WARN_MSG%ADD('FMP WBS BLOCK FAILED TO LOCATE KEYWORD "ADDED_DEMAND_RUNOFF_SPLIT" WHEN NIRRIGATE > 0.'//NL//'THIS FRACTION IS THE SPLIT OF RUNOFF TO DEEP PERCOLATION OF ANY ADDITIONAL DEMAND SPECIFIED FOR CROPS.'//NL//'THE SPLIT IS AUTOMATICALLY SET TO 0.1 (10% BECOMES RUNOFF AND 90% DEEP PERCOLATION) FOR ALL WBS (FARMS) AND IRRIGATION TYPES.'//BLN)
    END IF
    !
    !!!IF(.NOT. WBS%EFL_TFR%INUSE .AND. FDIM%NIRRG>Z) THEN
    !!!    LLOC=ONE
    !!!    LINE = 'CONSTANT 0.0D0 '
    !!!    CALL WBS%EFL_TFR%INIT('EFL', LLOC, LINE, BL%IOUT, BL%IU, WBS%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, WBS%NFARM, BYFARM, FDIM%NCROP, BYCROP, NIRRG, 'BYIRRIGATE', SCRATCH=BL%SCRATCH)
    !!!END IF
    !
    IF(.NOT. WBS%BARE_FRAC_RUNOFF%INUSE) THEN
                                               CALL WARN_MSG%ADD('FAILED TO LOCATE "BARE_RUNOFF_FRACTION" KEYWORD.'//NL//'THE FACTION OF PRECIPITATION TO RUNOFF FOR FALLOW/BARE LAND IS AUTOMATICALLY SET TO 1.'//BLN)
                                               !
                                               CALL WBS%BARE_FRAC_RUNOFF%INIT('BFR',UNO, BL%IOUT, BL%IU, WBS%NFARM, ONE, FDIM%NROW, FDIM%NCOL)
    END IF
    !
    !IF(.NOT. WBS%BARE_FRAC_PRECIP%INUSE) THEN
    !                                           CALL WARN_MSG%ADD('FAILED TO LOCATE "BARE_PRECIP_CONSUMPTION_FRACTION" KEYWORD.'//NL//'THE FACTION OF AVAILIBLE FOR EVAPORATION OVER BARE/FALLOW SOIL IS AUTOMATICALLY SET TO 1.'//BLN)
    !                                           !
    !                                           CALL WBS%BARE_FRAC_PRECIP%INIT('BFP',UNO, BL%IOUT, BL%IU, WBS%NFARM, ONE, FDIM%NROW, FDIM%NCOL)
    !END IF
    !
    !IF(.NOT. WBS%HIERARCHY_TFR%INUSE .AND. WBS%HAS_HIERARCHY) CALL STOP_ERROR(INFILE=BL%IU, OUTPUT=BL%IOUT,MSG='"NPROJ", "NDIST", "NUNIT", OR "NAUXDEM" WERE SPECIFIED AND GREATER THAN ZERO,'//NL//'BUT FAILED TO LOCATION KEYWORD "HIERARCHY" TO LOAD THE RELATIONSHIP BETWEEN THEM.'//NL//'PLEASE DOUBLE CHECK BLOCK SET UP.')
    !
    IF(.NOT. WBS%DEFICIENCY%INUSE) THEN
                            CALL WBS%DEFICIENCY%INIT('DEFF', ONE, BL%IOUT, BL%IU, WBS%NFARM, ONE, Z, Z)  !, WBS%NFARM, 'BYWBS', FDIM%NCROP, 'BYCROP'
                            CALL WARN_MSG%ADD('FAILED TO LOCATE KEYWORD "DEFICIENCY_SCENARIO" WITHIN FMP WBS BLOCK.'//NL//'IT WILL BE SET TO THE DEFAULT "DEFICIT IRRIGATION SCENARIO" (1),'//NL//'SO IRRIGATED CROPS THAT DO NOT HAVE ENOUGH SUPPLY WILL ONLY USE THE AVAILIBLE WATER AND NOT HAVE EXTERNAL WATER FROM SOURCES BEYOND THE MODEL INSTEAD OF DEFICIT IRRIGATE.'//NL//'IF YOU WANT TO USE THE ZERO SCENARIO OR HAVE A MIXTURE OF DEFICIT AND EXZTERNAL WATER IRRIGATION PRACTICES, PLEASE INCLUDE THE "DEFICIENCY_SCENARIO" KEYWORD FOLLOWED BY NFARM ZEROS AND ONES'//NL//'TO INDICATE IF THE WBS RECIEVES EXTERNAL WATER OR DEFICIT IRRIGATES.'//BLN)
                        
    END IF
    !
    IF(.NOT. WBS%EFF_IMPROVE_TFR%INUSE) THEN
        !
        CALL WBS%EFF_IMPROVE_TFR%INIT('EFF_IMPROVE', Z, BL%IOUT, BL%IU, WBS%NFARM, NIRRG, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)  ! NIRRG = 1 or FDIM%NIRRG
        !       HAS DEFICIT IRR SCENARIO   MAY HAVE DEFICIT IRR SCENARIO 
        !IF(FDIM%NIRRG > Z .AND. (ANY(WBS%DEFICIENCY%LIST.NE.Z).OR.WBS%DEFICIENCY%TRANSIENT)) CALL WARN_MSG%ADD('FAILED TO LOCATE KEYWORD "EFFICIENCY_IMPROVEMENT" WITHIN FMP WBS BLOCK.'//NL//'IT WILL BE SET TO 0, WHICH INDICATES EFFICIENCIES ARE NOT IMPROVED UNDER DEFICIT IRRIGATION SCENARIOS.'//NL//'THIS KEEPS THE EFFICIENCY THE SAME AS IT IS SPECIFIED BY INPUT AND IS THE RECOMMEND OPTION.'//BLN)
    END IF
    !
    CALL WARN_MSG%CHECK('FMP WBS BLOCK: THE FOLLOWING ARE WARNING MESSAGES RECIEVED WHILE LOADING AND PROCESSING THE WBS BLOCK INPUT.',BL%IU,BL%IOUT)
    !
    WBS%HAS_CROP_FLUX = WBS%CROP_FLUX_TFR%INUSE
    WBS%HAS_CROP_VOLR = WBS%CROP_VOLR_TFR%INUSE
    !
    IF(WBS%HAS_CROP_FLUX .OR. WBS%HAS_CROP_VOLR) THEN
                                                 ALLOCATE(WBS%WBS_HAS_ADMD(WBS%NFARM), SOURCE=FALSE)
                                                 ALLOCATE(WBS%CRP_HAS_ADMD(FDIM%NCROP), SOURCE=FALSE)    
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SETUP_NO_WBS_DATA( WBS, FDIM, IN_FMP, IOUT )  
    CLASS(WBS_DATA),             INTENT(INOUT):: WBS
    TYPE(FMP_DIMENSION),         INTENT(IN   ):: FDIM
    INTEGER,                     INTENT(IN   ):: IN_FMP, IOUT
    !
    IF(FDIM%NIRRG>Z) CALL STOP_ERROR(INFILE=IN_FMP, OUTPUT=IOUT,                                             &
                                     MSG='IF YOU SPECIFY IN THE GLOBAL DIMENSION BLOCK NIRRIGATE > 0,'//NL// &
                                    'THEN YOU MUST INCLUDE THE WATER_BALANCE_SUBREGION BLOCK'//NL//          &
                                    'AND SPECIFY THE "EFFICIENCY" WITHIN IT.'//NL//                          &
                                    'PLEASE ADD THE MISSING BLOCK AND KEYWORD OR SET NIRRIGATE = 0')
    !
    CALL SETUP_BASIC_VAR_WBS_DATA( WBS, FDIM, IOUT )  
    !
    CALL WBS%FID_TFR%INIT('LOCATION', ONE, IOUT, Z, Z, Z, FDIM%NROW, FDIM%NCOL)
    !
    CALL WBS%DEFICIENCY%INIT('DEFF', ONE, IOUT, Z, WBS%NFARM, ONE, Z, Z)
    !
    WBS%PRORATE_DEFICIENCY = ONE
    !
    CALL WBS%EFF_TFR%INIT('EFF', DZ, IOUT, Z, WBS%NFARM, ONE, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
    !
    CALL WBS%EFF_IMPROVE_TFR%INIT('EFF_IMPROVE', Z, IOUT, Z, WBS%NFARM, ONE, FDIM%NROW, FDIM%NCOL, LISTARRAY=TRUE)
    !
    CALL WBS%BARE_FRAC_RUNOFF%INIT('BFR',UNO, IOUT, Z, WBS%NFARM, ONE, FDIM%NROW, FDIM%NCOL)
    !
  END SUBROUTINE 
  !
  SUBROUTINE SETUP_NEXT_STRESS_PERIOD(WBS)
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: I, J, F
    LOGICAL:: UPDATE
    !
    IF(WBS%TFR_READ) THEN
                         UPDATE = FALSE
                         !
                         CALL WBS%FID_TFR%NEXT()
                         !
                         IF(WBS%FID_TFR%TFR%REPEAT) THEN
                                                    WBS%NEW_FID = FALSE
                         ELSE
                                                    WBS%NEW_FID = TRUE  !ASSUME ITS TRUE UPDATED IN CALL WBS%SETUP_FID_RC()
                         END IF
                         !
                         CALL WBS%EFF_TFR         %NEXT()
                         CALL WBS%ADRF_TFR        %NEXT()
                         CALL WBS%EFF_IMPROVE_TFR %NEXT()
                         CALL WBS%BARE_FRAC_RUNOFF%NEXT()
                         !CALL WBS%BARE_FRAC_PRECIP%NEXT()
                         CALL WBS%DEFICIENCY      %NEXT()
                         CALL WBS%HIERARCHY_TFR   %NEXT()
                         CALL WBS%FALLOW_RANK_TFR %NEXT()
                         CALL WBS%H2OSOURCE_TFR   %NEXT()
                         CALL WBS%CROP_FLUX_TFR   %NEXT()
                         CALL WBS%CROP_VOLR_TFR   %NEXT()
                         !CALL WBS%EFL_TFR         %NEXT()
                         !
                         !CALL WBS%FID_TFR%NEXT()
                         !
                         !!
                         !CALL WBS%HIERARCHY_TFR%NEXT()                              
                         !IF(WBS%HIERARCHY_TFR%TRANSIENT) CALL WBS%SETUP_FARM_HIERARCHY_POINTERS() !TRANSIENT WILL NEVER BE TRUE IF NOT INUSE
                         !!
                         !CALL WBS%EFF_TFR%NEXT()
    ELSE
        WBS%TFR_READ = TRUE
        UPDATE = TRUE
    END IF
    !
    IF(UPDATE .OR. WBS%FID_TFR%TRANSIENT) THEN ! Make Zero the common null value
       DO J=ONE, WBS%NROW
       DO I=ONE, WBS%NCOL
       IF(WBS%FID_TFR%ARRAY(I,J) < Z .OR. WBS%FID_TFR%ARRAY(I,J) > WBS%NFARM ) THEN
          WBS%FID_TFR%ARRAY(I,J) = Z
       END IF
       END DO
       END DO
    END IF
    !
    IF(UPDATE .OR. WBS%NEW_FID) THEN
        !
        CALL WBS%SETUP_FID_RC()  !SETS WBS%NEW_FID
        !
        IF(WBS%NEW_FID) UPDATE = TRUE  !FORCE UPDATE DUE TO NEW FID ARRAY
        !
    END IF
    !
    IF(WBS%HAS_HIERARCHY .AND. (WBS%HIERARCHY_TFR%TRANSIENT .OR. UPDATE)) CALL WBS%SETUP_FARM_HIERARCHY_POINTERS() !TRANSIENT WILL NEVER BE TRUE IF NOT INUSE
    !
    IF(WBS%HAS_WATERSTACK .AND. (WBS%FALLOW_RANK_TFR%TRANSIENT .OR. UPDATE) ) THEN
          !
          WBS%FALLOW_RANK = Z
          IF (WBS%FALLOW_RANK_TFR%LISTARRAY) THEN  !NOTE IT IS EITHER A LISTARRAY OR ARRAY
              DO CONCURRENT (F=ONE:WBS%NFARM)
                                             WBS%MAX_FALLOW_RANK(F) = MAXVAL(WBS%FALLOW_RANK_TFR%ARRAY(:,F))
              END DO
          ELSE
              DO CONCURRENT (F=ONE:WBS%NFARM)
                                             WBS%MAX_FALLOW_RANK(F) = MAXVAL( WBS%FALLOW_RANK_TFR%ARRAY, MASK = WBS%FID_ARRAY==F )
              END DO
          END IF
          !
    END IF
    !
    !
    IF (UPDATE .OR. WBS%EFF_IMPROVE_TFR%TRANSIENT) THEN
        IF( WBS%EFF_IMPROVE_TFR%LISTLOAD) THEN
            WBS%EFF_IMPROVE = ANY(WBS%EFF_IMPROVE_TFR%LIST  > Z)
        ELSE
            WBS%EFF_IMPROVE = ANY(WBS%EFF_IMPROVE_TFR%ARRAY > Z)
        END IF
  END IF
    !
    !
    IF(WBS%HAS_CROP_FLUX) THEN;  IF (UPDATE .OR. WBS%CROP_FLUX_TFR%TRANSIENT) THEN
            !
            WBS%CROP_FLUX = TRANSPOSE(WBS%CROP_FLUX_TFR%ARRAY)
            !    
            ASSOCIATE(SFAC=>WBS%CROP_FLUX_TFR%SFAC)
                !
                IF(SFAC%HAS_ALL) WBS%CROP_FLUX = WBS%CROP_FLUX * SFAC%ALL
                !
                IF(SFAC%HAS_EX1) THEN
                    DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                          !
                          WBS%CROP_FLUX(F,I) = WBS%CROP_FLUX(F,I) * SFAC%EX1(F)
                          !
                    END DO
                END IF
                !  
                IF(SFAC%HAS_EX2) THEN
                    DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                          !
                          WBS%CROP_FLUX(F,I) = WBS%CROP_FLUX(F,I) * SFAC%EX2(I)
                          !
                    END DO
                END IF
            END ASSOCIATE
            !
            DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM, NEAR_ZERO(WBS%CROP_FLUX(F,I)))
                  !
                  WBS%CROP_FLUX(F,I) = DZ
                  !
            END DO
            !
    END IF; END IF
    !
    IF(WBS%HAS_CROP_VOLR) THEN;  IF (UPDATE .OR. WBS%CROP_VOLR_TFR%TRANSIENT) THEN
            !
            DO CONCURRENT(I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                                                     WBS%CROP_VOLR(F,I) = WBS%CROP_VOLR_TFR%ARRAY(I,F)
            END DO
            !    
            ASSOCIATE(SFAC=>WBS%CROP_VOLR_TFR%SFAC)
                !
                IF(SFAC%HAS_ALL) WBS%CROP_VOLR = WBS%CROP_VOLR * SFAC%ALL
                !
                IF(SFAC%HAS_EX1) THEN
                    DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                          !
                          WBS%CROP_VOLR(F,I) = WBS%CROP_VOLR(F,I) * SFAC%EX1(F)
                          !
                    END DO
                END IF
                !  
                IF(SFAC%HAS_EX2) THEN
                    DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM)
                          !
                          WBS%CROP_VOLR(F,I) = WBS%CROP_VOLR(F,I) * SFAC%EX2(I)
                          !
                    END DO
                END IF
            END ASSOCIATE
            !
            DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM, NEAR_ZERO(WBS%CROP_VOLR(F,I)))
                  !
                  WBS%CROP_VOLR(F,I) = DZ
                  !
            END DO
            !
    END IF; END IF
    !
    IF(WBS%HAS_CROP_FLUX .OR. WBS%HAS_CROP_VOLR) THEN
        IF (UPDATE .OR. WBS%CROP_VOLR_TFR%TRANSIENT .OR. WBS%CROP_FLUX_TFR%TRANSIENT) THEN
            !
            WBS%WBS_HAS_ADMD = FALSE
            WBS%CRP_HAS_ADMD = FALSE
            !
            !DO CONCURRENT (I=ONE:WBS%NCROP, F=ONE:WBS%NFARM, WBS%CROP_FLUX(F,I).NE.DZ .OR. WBS%CROP_VOLR(F,I).NE.DZ)
            !      !
            !      WBS%WBS_HAS_ADMD(F) = TRUE
            !      WBS%CRP_HAS_ADMD(I) = TRUE
            !      !
            !END DO
            IF(WBS%HAS_CROP_FLUX) THEN
                !
                DO CONCURRENT (I=ONE:WBS%NCROP)
                    WBS%CRP_HAS_ADMD(I) = ANY( WBS%CROP_FLUX(:,I).NE.DZ)
                    !DO F=ONE, WBS%NFARM
                    !              IF( WBS%CROP_FLUX(F,I).NE.DZ ) THEN
                    !                  WBS%CRP_HAS_ADMD(I) = TRUE
                    !                  EXIT
                    !              END IF
                    !END DO
                END DO  
                DO CONCURRENT (F=ONE:WBS%NFARM)
                    DO I=ONE, WBS%NCROP 
                                  IF( WBS%CROP_FLUX(F,I).NE.DZ ) THEN
                                      WBS%WBS_HAS_ADMD(F) = TRUE
                                      EXIT
                                  END IF
                    END DO
                END DO
            END IF
            !
            IF(WBS%HAS_CROP_VOLR) THEN
                !
                DO CONCURRENT (I=ONE:WBS%NCROP, .NOT. WBS%CRP_HAS_ADMD(I))
                    WBS%CRP_HAS_ADMD(I) = ANY( WBS%CROP_VOLR(:,I).NE.DZ )
                    !DO F=ONE, WBS%NFARM
                    !              IF( WBS%CROP_VOLR(F,I).NE.DZ ) THEN
                    !                  WBS%CRP_HAS_ADMD(I) = TRUE
                    !                  EXIT
                    !              END IF
                    !END DO
                END DO  
                DO CONCURRENT (F=ONE:WBS%NFARM, .NOT. WBS%WBS_HAS_ADMD(F))
                    DO I=ONE, WBS%NCROP 
                                  IF( WBS%CROP_VOLR(F,I).NE.DZ ) THEN
                                      WBS%WBS_HAS_ADMD(F) = TRUE
                                      EXIT
                                  END IF
                    END DO
                END DO
            END IF
        END IF
    END IF
    !
    ! SET UP WATER SOURCES AVAILIBLE TO WBS IF IN USE
    !
    IF(WBS%H2OSOURCE_TFR%INUSE) THEN
        IF (UPDATE .OR. WBS%H2OSOURCE_TFR%TRANSIENT) THEN
            !
            WBS%H2OSOURCE%GW    = WBS%H2OSOURCE_TFR%ARRAY(ONE,  :) .NE. Z
            !
            IF( WBS%HAS_SFR ) THEN
              WBS%H2OSOURCE%SW  = WBS%H2OSOURCE_TFR%ARRAY(TWO,  :) .NE. Z  
            ELSE 
              WBS%H2OSOURCE%SW  = FALSE
            END IF
            !
            WBS%H2OSOURCE%NRD   = WBS%H2OSOURCE_TFR%ARRAY(THREE,:) .NE. Z
            !
        END IF
    END IF
    !
    ! SET UP WATER SUPPY FLAG FOR MAGIC WATER IF THERE IS NO DEFICIT SCENARIO IN USE.
    !
    IF (UPDATE .OR. WBS%DEFICIENCY%TRANSIENT) THEN
        DO CONCURRENT (F=ONE:WBS%NFARM )
            IF(WBS%DEFICIENCY%LIST(F) == Z) THEN
                     WBS%SUPPLY(F)%HAS_MAGIC = TRUE
            ELSE
                     WBS%SUPPLY(F)%HAS_MAGIC = FALSE
            END IF
        END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_PRECIP(WBS,HAS_PRECIP,PRECIP) 
    CLASS(WBS_DATA),                              INTENT(INOUT):: WBS
    LOGICAL,                                      INTENT(IN   ):: HAS_PRECIP
    DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE,INTENT(IN   ):: PRECIP
    INTEGER:: I,K
    !
    WBS%PRECIP = DZ
    !
    !SUM CROP DEMANDS
    IF(HAS_PRECIP) THEN
       DO CONCURRENT (I=ONE:WBS%NFARM)
       DO CONCURRENT (K=ONE:WBS%FID(I)%Count)
                                             WBS%PRECIP(I) = WBS%PRECIP(I) + PRECIP( WBS%FID(I)%RC(TWO,K), WBS%FID(I)%RC(ONE,K) ) * WBS%AREA( WBS%FID(I)%RC(TWO,K), WBS%FID(I)%RC(ONE,K) )
       END DO; END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_DEMAND(WBS) !EVENTUALLY COULD HAVE ADDITIONAL DEMANDS TO ADD IN
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: F,K
    !
    WBS%CROP_DEMAND = DZ
    !
    !SUM CROP DEMANDS
    DO CONCURRENT (F=ONE:WBS%NFARM)
    DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                          WBS%CROP_DEMAND(F) = WBS%CROP_DEMAND(F) + WBS%CROP_DEMAND_ARRAY( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) )
    END DO; END DO
    !
    WBS%DEMAND = WBS%CROP_DEMAND
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_RUNOFF_DPERC(WBS) !EVENTUALLY COULD HAVE ADDITIONAL DEMANDS TO ADD IN
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: F,K
    !
    WBS%TOT_DPERC   = DZ
    !
    DO CONCURRENT (F=ONE:WBS%NFARM)
    DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                          WBS%TOT_DPERC(F) = WBS%TOT_DPERC(F) + WBS%DPERC( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) )
    END DO; END DO
    !
    WBS%TOT_RUNOFF  = DZ
    DO CONCURRENT (F=ONE:WBS%NFARM)
    DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                          WBS%TOT_RUNOFF(F) = WBS%TOT_RUNOFF(F) + WBS%RUNOFF( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) )
    END DO; END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_DIRECT_RECHARGE(WBS, NDRCH, DRCH)
    CLASS(WBS_DATA),                                   INTENT(INOUT):: WBS
    INTEGER,                                           INTENT(IN   ):: NDRCH
    CLASS(COMPRESSED_VALUE_STORAGE), DIMENSION(NDRCH), INTENT(IN   ):: DRCH
    INTEGER:: F,I,K
    !
    WBS%TOT_DIR_RCH   = DZ
    !
    DO I=ONE, NDRCH
       DO K=ONE, DRCH(I)%N
                                  F = WBS%FID_ARRAY( DRCH(I)%DIM(ONE,K), DRCH(I)%DIM(TWO,K) )
                                  !
                                  IF( F > Z) WBS%TOT_DIR_RCH(F) = WBS%TOT_DIR_RCH(F) + DRCH(I)%VAL(K)
       END DO
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SUM_WBS_FNRCH(WBS) !EVENTUALLY COULD HAVE ADDITIONAL DEMANDS TO ADD IN
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: F,K
    !
    WBS%TOT_FNRCH = DZ
    !
    DO CONCURRENT (F=ONE:WBS%NFARM)
    DO CONCURRENT (K=ONE:WBS%FID(F)%Count)
                                                           WBS%TOT_FNRCH(F) = WBS%TOT_FNRCH(F) + WBS%FNRCH( WBS%FID(F)%RC(TWO,K), WBS%FID(F)%RC(ONE,K) )
    END DO; END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_FID_RC(WBS)
    CLASS(WBS_DATA),        INTENT(INOUT):: WBS
    INTEGER:: I,J
    !
    WBS%NEW_FID = FALSE
    NEW_FID: &
    DO J=ONE, WBS%NROW
    DO I=ONE, WBS%NCOL
             IF(WBS%FID_TFR%ARRAY(I,J) .NE. WBS%FID_ARRAY(I,J)) THEN
                 WBS%NEW_FID = TRUE
                 EXIT NEW_FID
             END IF
    END DO
    END DO NEW_FID
    !
    IF(WBS%NEW_FID) THEN
        !
        DO CONCURRENT (J=ONE:WBS%NROW, I=ONE:WBS%NCOL)
                       WBS%FID_ARRAY(I,J) = WBS%FID_TFR%ARRAY(I,J)
        END DO
        !
        DO CONCURRENT (I=ONE:WBS%NFARM); CALL SETUP_SINGLE_FID_RC(WBS%FID(I), WBS%NROW, WBS%NCOL, WBS%FID_ARRAY, WBS%AREA)
        END DO
        !
        DO CONCURRENT (I=ONE:WBS%NFARM);  WBS%INUSE(I) = WBS%FID(I)%COUNT > Z
        END DO
    ELSE
        WBS%NEW_FID = FALSE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SETUP_SINGLE_FID_RC(FID, NROW, NCOL, FID_ARRAY, AREA)
    CLASS(FARMLOCATION),                    INTENT(INOUT):: FID
    INTEGER,                                INTENT(IN   ):: NROW, NCOL
    INTEGER,          DIMENSION(NCOL,NROW), INTENT(IN   ):: FID_ARRAY         !FARM LOCATION ARRAY
    DOUBLE PRECISION, DIMENSION(NCOL,NROW), INTENT(IN   ):: AREA
    INTEGER:: I, IR, IC, N
    !
    N=COUNT(FID%NF.EQ.FID_ARRAY)                                 !COUNT THE NUMBER OF CELLS THAT CONTAIN FARM NF
    !
    CALL ALLOC( FID%RC, TWO, N, DIMCHK=TWO )
    !
    FID%Count = N
    FID%AREA = DZ
    IF ( FID%Count > Z ) THEN
                               I=Z                    !COUNTER FOR NUMBER OR RC READS
                               DO IR=ONE, NROW  !SEARCH FOR FARM NF IN MODEL AND STORE ITS ROW/COL LOCATION  ==> FID_ARRAY(NCOL,NROW)
                               DO IC=ONE, NCOL
                                                      IF(FID_ARRAY(IC,IR).EQ.FID%NF) THEN
                                                                                      I=I+ONE
                                                                                      FID%RC(ONE,I)=IR
                                                                                      FID%RC(TWO,I)=IC
                                                                                      FID%AREA = FID%AREA + AREA(IC,IR)
                                                      END IF
                               END DO
                               END DO
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SETUP_FARM_HIERARCHY_POINTERS(WBS)
    CLASS(WBS_DATA),  INTENT(INOUT):: WBS
    !
    TYPE(INTEGER_LINKED_LIST):: DIST_LIST, UNIT_LIST, FARM_LIST, AUX_LIST
    INTEGER:: I, J, P, D, U, NFARM, NAUX, TOT, AUX_STR
    LOGICAL:: SORT
    TYPE(WARNING_TYPE):: WARN_MSG
    !
    IF (WBS%HAS_HIERARCHY) THEN
        !
        NFARM= WBS%NFARM
        NAUX = WBS%NAUXDEM 
        AUX_STR = WBS%NFARM + ONE      
        TOT  = NFARM + NAUX
        !
        IF( ANY(WBS%HIERARCHY_ARRAY .NE. WBS%HIERARCHY_TFR%ARRAY) ) THEN
            !
            CALL WARN_MSG%INIT()
            !
            DO CONCURRENT (I=ONE:TOT, ANY(WBS%HIERARCHY_TFR%ARRAY(:,I) == Z) .AND. ANY(WBS%HIERARCHY_TFR%ARRAY(:,I) .NE. Z))
                IF(I <= WBS%NFARM) THEN
                    CALL WARN_MSG%ADD('WBS     '//NUM2STR(I)//NL )
                ELSE
                    CALL WARN_MSG%ADD('AUX_DEM '//NUM2STR(I-WBS%NFARM)//NL)
                END IF
                WBS%HIERARCHY_TFR%ARRAY(:,I) = Z
            END DO
            !
            CALL WARN_MSG%CHECK('FMP WBS BLOCK: VALUES IN THE HIERARCHY CONTAINED ZEROS AND NONZEROS FOR THE SAME WBS/AUXILIARY DEMAND.'//BLN//'SINCE THERE WAS A ZERO PROJECT, DISTRICT, OR UNIT SPECIFIED, THE REST ARE SET TO ZERO'//NL//'(EITHER ALL HIERARCHY RELATIONSHIPS MUST BE SPECIFIED GREATER THAN ZERO OR ALL SET TO ZERO).'//NL//'FOR PROGRAM TO CONTINUE THE FARMS/AUXILIARY DEMANDS WITH ZERO VALUES WILL BE SET TO 0 FOR ITS PROJECT, DISTRICT, AND UNIT.'//BLN//'THE FOLLOWING ARE THE FARMS/AUXILIARY DEMANDS THAT HAD THEIR HIERARCHY ZEROED OUT:', OUTPUT=WBS%IOUT, INLINE=TRUE, INIT=TRUE)
            !
            WBS%HIERARCHY_ARRAY = WBS%HIERARCHY_TFR%ARRAY
            !
            SORT = TRUE
            !
            !CHECK THAT PROJ, DIST, AND UNIT ARE UNIQUE
            P=Z;U=Z;D=Z
            DO CONCURRENT (U=ONE:WBS%NUNIT)
               D=Z
               DO CONCURRENT (I=ONE:TOT, WBS%HIERARCHY_ARRAY(ONE,I) == U)
                   IF(D==Z) THEN
                           D  =   WBS%HIERARCHY_ARRAY(TWO,I)
                   ELSEIF (D .NE. WBS%HIERARCHY_ARRAY(TWO,I)) THEN
                           CALL WARN_MSG%ADD('FMP UNIT '//NUM2STR(U)//' CAN ONLY BE ASSOCIATED WITH ONE DISTRICT AT ONE TIME. INSTEAD IT HAS BEEN SPECIFIED TO BE APART OF DISTRICT '//NUM2STR(D)//' AND DISTRICT '//NUM2STR(WBS%HIERARCHY_ARRAY(TWO,I))//NL )
                   END IF
               END DO
            END DO
            P=Z;U=Z;D=Z
            !
            DO CONCURRENT (D=ONE:WBS%NDIST)
               P=Z
               DO CONCURRENT (I=ONE:TOT, WBS%HIERARCHY_ARRAY(TWO,I) == D)
                   IF(P==Z) THEN
                           P  =   WBS%HIERARCHY_ARRAY(THREE,I)
                   ELSEIF (P .NE. WBS%HIERARCHY_ARRAY(THREE,I)) THEN
                           CALL WARN_MSG%ADD( 'FMP DISTRICT '//NUM2STR(D)//' CAN ONLY BE ASSOCIATED WITH ONE DISTRICT AT ONE TIME. INSTEAD IT HAS BEEN SPECIFIED TO BE APART OF DISTRICT '//NUM2STR(P)//' AND DISTRICT '//NUM2STR(WBS%HIERARCHY_ARRAY(THREE,I))//NL )
                   END IF
               END DO
            END DO
            !
            CALL WARN_MSG%CHECK(HED='FMP HIERARCHY HAD FATAL ERRORS:'//NL, OUTPUT=WBS%IOUT, KILL=TRUE, TAIL=NL )
            !
            ! ASSINGLE EACH FARMS PROJ, DIST, UNIT
            DO CONCURRENT (I=ONE:NFARM)
                                         WBS%FARM(I)%UNIT = WBS%HIERARCHY_ARRAY(ONE,  I)
                                         WBS%FARM(I)%DIST = WBS%HIERARCHY_ARRAY(TWO,  I)
                                         WBS%FARM(I)%PROJ = WBS%HIERARCHY_ARRAY(THREE,I)    
            END DO
            !
            IF( NAUX > Z) THEN
               J = AUX_STR
               DO I=ONE, NAUX
                                            WBS%AUX_DEMAND(I)%UNIT = WBS%HIERARCHY_ARRAY(ONE,  J)
                                            WBS%AUX_DEMAND(I)%DIST = WBS%HIERARCHY_ARRAY(TWO,  J)
                                            WBS%AUX_DEMAND(I)%PROJ = WBS%HIERARCHY_ARRAY(THREE,J)    
                                            J=J+1
               END DO
            END IF
            !
            !FIND ALL DIST, UNIT, AND FARM ASSOCIATED WITH PROJECT----------------------------------------------------------------
            P=Z;U=Z;D=Z
            DO P=ONE, WBS%NPROJ
              CALL DIST_LIST%INIT()
              CALL UNIT_LIST%INIT()
              CALL FARM_LIST%INIT()
              CALL AUX_LIST%INIT()
              !
              DO I=ONE, NFARM
                  IF ( WBS%HIERARCHY_ARRAY(THREE,I) == P )  THEN!FIND ROWS WITH PROJECT P
                      CALL UNIT_LIST%ADD(WBS%HIERARCHY_ARRAY(ONE,I))
                      CALL DIST_LIST%ADD(WBS%HIERARCHY_ARRAY(TWO,I))
                      CALL FARM_LIST%ADD(I)
                  END IF
              END DO
              !
              IF( NAUX > Z) THEN
                 J = AUX_STR
                 DO I=ONE, NAUX
                     IF ( WBS%HIERARCHY_ARRAY(THREE,J) == P )  THEN!FIND ROWS WITH PROJECT P
                                CALL UNIT_LIST%ADD(WBS%HIERARCHY_ARRAY(ONE,J))
                                CALL DIST_LIST%ADD(WBS%HIERARCHY_ARRAY(TWO,J))
                                CALL AUX_LIST%ADD(I)
                                J=J+1
                     END IF
                 END DO
              END IF
              !
              CALL DIST_LIST%DROP_DUPLICATES()
              CALL UNIT_LIST%DROP_DUPLICATES()
              !CALL FARM_LIST%DROP_DUPLICATES()  --SHOULD NEVER BE A DUBLICATE FARM
              !
              WBS%PROJ(P)%NDIST=DIST_LIST%LEN()
              WBS%PROJ(P)%NUNIT=UNIT_LIST%LEN()
              WBS%PROJ(P)%NFARM=FARM_LIST%LEN()
              WBS%PROJ(P)%NAUX =AUX_LIST %LEN()
              !
              CALL DIST_LIST%TOARRAY(WBS%PROJ(P)%DIST, SORT)
              CALL UNIT_LIST%TOARRAY(WBS%PROJ(P)%UNIT, SORT)
              CALL FARM_LIST%TOARRAY(WBS%PROJ(P)%FARM, SORT)
              CALL AUX_LIST %TOARRAY(WBS%PROJ(P)%AUX,  SORT)
            END DO
            !
            !FIND ALL UNIT, AND FARM ASSOCIATED WITH DIST----------------------------------------------------------------
            P=Z;U=Z;D=Z
            DO D=ONE, WBS%NDIST
              CALL UNIT_LIST%INIT()
              CALL FARM_LIST%INIT()
              CALL AUX_LIST%INIT()
              !
              WBS%DIST(D)%PROJ = Z
              DO I=ONE, NFARM
                  IF ( WBS%HIERARCHY_ARRAY(TWO,I) == D ) THEN !FIND ROWS WITH DISTRIC D
                      CALL UNIT_LIST%ADD(WBS%HIERARCHY_ARRAY(ONE,I))
                      CALL FARM_LIST%ADD(I)
                      !
                      IF(WBS%DIST(D)%PROJ == Z) WBS%DIST(D)%PROJ = WBS%HIERARCHY_ARRAY(THREE,I)
                  END IF
              END DO
              !
              IF( NAUX > Z) THEN
                  J = AUX_STR
                  DO I=ONE, NAUX
                   IF ( WBS%HIERARCHY_ARRAY(TWO,J) == D ) THEN !FIND ROWS WITH DISTRIC D
                       CALL UNIT_LIST%ADD(WBS%HIERARCHY_ARRAY(ONE,J))
                       CALL AUX_LIST%ADD(I)
                       !
                       IF(WBS%DIST(D)%PROJ == Z) WBS%DIST(D)%PROJ = WBS%HIERARCHY_ARRAY(THREE,J)
                   END IF
                   J=J+1
                  END DO
              END IF
              !
              CALL UNIT_LIST%DROP_DUPLICATES()
              !CALL FARM_LIST%DROP_DUPLICATES()  --SHOULD NEVER BE A DUBLICATE FARM
              !
              WBS%DIST(D)%NUNIT=UNIT_LIST%LEN()
              WBS%DIST(D)%NFARM=FARM_LIST%LEN()
              WBS%DIST(D)%NAUX = AUX_LIST%LEN()
              !
              CALL UNIT_LIST%TOARRAY(WBS%DIST(D)%UNIT, SORT)
              CALL FARM_LIST%TOARRAY(WBS%DIST(D)%FARM, SORT)
              CALL AUX_LIST %TOARRAY(WBS%DIST(D)%AUX,  SORT)
            END DO
            !
            !FIND ALL FARM ASSOCIATED WITH UNIT----------------------------------------------------------------
            P=Z;U=Z;D=Z
            DO U=ONE, WBS%NUNIT
              CALL FARM_LIST%INIT()
              !
              WBS%UNIT(U)%PROJ = Z
              WBS%UNIT(U)%DIST = Z
              DO I=ONE, WBS%NFARM
                  IF ( WBS%HIERARCHY_ARRAY(ONE,I) == U ) THEN !FIND ROWS WITH UNIT U
                     CALL FARM_LIST%ADD(I)
                     IF(WBS%UNIT(U)%DIST == Z) WBS%UNIT(U)%DIST = WBS%HIERARCHY_ARRAY(TWO,I)
                     IF(WBS%UNIT(U)%PROJ == Z) WBS%UNIT(U)%PROJ = WBS%HIERARCHY_ARRAY(THREE,I)
                  END IF
              END DO
              !
              IF( NAUX > Z) THEN
                J = AUX_STR
                DO I=ONE, NAUX
                  IF ( WBS%HIERARCHY_ARRAY(ONE,J) == U ) THEN !FIND ROWS WITH UNIT U
                     CALL AUX_LIST%ADD(I)
                     IF(WBS%UNIT(U)%DIST == Z) WBS%UNIT(U)%DIST = WBS%HIERARCHY_ARRAY(TWO,  J)
                     IF(WBS%UNIT(U)%PROJ == Z) WBS%UNIT(U)%PROJ = WBS%HIERARCHY_ARRAY(THREE,J)
                  END IF  
                  J=J+1
                END DO
              END IF
              !
              !CALL FARM_LIST%DROP_DUPLICATES()  --SHOULD NEVER BE A DUBLICATE FARM
              !
              WBS%UNIT(U)%NFARM=FARM_LIST%LEN()
              WBS%UNIT(U)%NAUX = AUX_LIST%LEN()
              !
              CALL FARM_LIST%TOARRAY(WBS%UNIT(U)%FARM, SORT)
              CALL AUX_LIST %TOARRAY(WBS%UNIT(U)%AUX,  SORT)
            END DO
            !
            CALL DIST_LIST%DESTROY()
            CALL UNIT_LIST%DESTROY()
            CALL FARM_LIST%DESTROY()
            CALL AUX_LIST%DESTROY()
            !
        END IF
        !
    END IF
  END SUBROUTINE
  !
  SUBROUTINE SETUP_FALLOW_FRACTION_ARRAY(WBS, WBS_BARE_FRAC, BFR, UPDATE)
    CLASS(WBS_DATA),                             INTENT(IN   ):: WBS
    TYPE(LIST_ARRAY_INPUT),                      INTENT(IN   ):: WBS_BARE_FRAC  ! SHOULD BE WBS%BARE_FRAC_RUNOFF OR WBS%BARE_FRAC_PRECIP
    DOUBLE PRECISION, DIMENSION(:,:),CONTIGUOUS, INTENT(INOUT):: BFR
    LOGICAL,                                     INTENT(IN   ):: UPDATE
    INTEGER:: I,J
    !
    IF(.NOT. WBS_BARE_FRAC%INUSE .AND. UPDATE) THEN
        !
        BFR = UNO
        !
    ELSEIF(WBS_BARE_FRAC%INUSE .AND. (WBS_BARE_FRAC%TRANSIENT .OR. UPDATE)) THEN   !  .OR. WBS%FID_TFR%TRANSIENT -> Should be included in UPDATE
        !
        IF(WBS_BARE_FRAC%LISTLOAD) THEN
            !
            DO CONCURRENT(J=ONE:SIZE(WBS%FID_ARRAY,TWO), I=ONE:SIZE(WBS%FID_ARRAY,ONE))
                  !
                  IF (WBS%FID_ARRAY(I,J) == Z) THEN
                      BFR(I,J) = DZ
                  ELSE
                      BFR(I,J) = WBS_BARE_FRAC%LIST( WBS%FID_ARRAY(I,J) )
                      IF(WBS_BARE_FRAC%SFAC%HAS_EX1) BFR(I,J) = BFR(I,J) * WBS_BARE_FRAC%SFAC%EX1(WBS%FID_ARRAY(I,J))
                  END IF
                  !
            END DO
            !
            IF(WBS_BARE_FRAC%SFAC%HAS_ALL) BFR = BFR * WBS_BARE_FRAC%SFAC%ALL
            !
        ELSE
            BFR = WBS_BARE_FRAC%ARRAY
            !
            IF(WBS_BARE_FRAC%SFAC%HAS_ALL) BFR = BFR * WBS_BARE_FRAC%SFAC%ALL
            !
            IF(WBS_BARE_FRAC%SFAC%HAS_EX1) THEN
                  DO CONCURRENT(J=ONE:SIZE(WBS%FID_ARRAY,TWO), I=ONE:SIZE(WBS%FID_ARRAY,ONE), WBS%FID_ARRAY(I,J) > Z)
                        !
                        BFR(I,J) = BFR(I,J) * WBS_BARE_FRAC%SFAC%EX1(WBS%FID_ARRAY(I,J))
                  END DO
            END IF
            
        END IF
        !
        DO CONCURRENT(J=ONE:SIZE(WBS%FID_ARRAY,TWO), I=ONE:SIZE(WBS%FID_ARRAY,ONE))
            IF    ( BFR(I,J)>UNO ) THEN; BFR(I,J)=UNO
            ELSEIF( BFR(I,J)<DZ  ) THEN; BFR(I,J)=DZ
            END IF
        END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOCATE_WATER_SOURCES(SRC,N)
    CLASS(WATER_SOURCES),   INTENT(INOUT):: SRC
    INTEGER,                INTENT(IN   ):: N
    !
    IF(ALLOCATED(SRC%GW )) DEALLOCATE(SRC%GW )
    IF(ALLOCATED(SRC%SW )) DEALLOCATE(SRC%SW )
    IF(ALLOCATED(SRC%NRD)) DEALLOCATE(SRC%NRD)
    !
    ALLOCATE(SRC%GW (N))
    ALLOCATE(SRC%SW (N))
    ALLOCATE(SRC%NRD(N))
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_TOTAL(SUP)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    SUP%TOTAL = SUP%NRD_TOT + SUP%SFR_TOT + SUP%WEL_TOT
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_USED(SUP)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    SUP%USED = SUP%NRD + SUP%SFR + SUP%WEL + SUP%MAGIC
    SUP%CROP  = SUP%USED
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_MAGIC(SUP, TFDR, DEF)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: TFDR
    INTEGER,           INTENT(IN   ):: DEF
    !
    IF(DEF==Z) SUP%MAGIC = TFDR - SUP%NRD - SUP%SFR - SUP%WEL
    !
    IF(SUP%MAGIC<DZ) SUP%MAGIC=DZ
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_SFR  (SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%SFR = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_NRD  (SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%NRD = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_WEL  (SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%WEL = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_SFR_TOT(SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%SFR_TOT = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_NRD_TOT(SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%NRD_TOT = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_WEL_TOT(SUP, FLOW)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    DOUBLE PRECISION,  INTENT(IN   ):: FLOW
    SUP%WEL_TOT = FLOW
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE INIT_SUPPLY(SUP)
    CLASS(WBS_SUPPLY), INTENT(INOUT):: SUP
    SUP%TOTAL   = DZ
    SUP%USED    = DZ
    SUP%CROP    = DZ
    SUP%MAGIC   = DZ
    SUP%SFR     = DZ
    SUP%WEL     = DZ
    SUP%NRD     = DZ
    SUP%SFR_TOT = DZ
    !SUP%SWR_TOT = DZ
    SUP%WEL_TOT = DZ
    SUP%NRD_TOT = DZ
    !SUP%SWR     = DZ
  END SUBROUTINE
  !  
  SUBROUTINE CHECK_SOIL_ID(WBS,SID)
    CLASS(WBS_DATA),                  INTENT(IN):: WBS
    INTEGER,DIMENSION(:,:),CONTIGUOUS,INTENT(IN):: SID
    INTEGER:: R,C
    TYPE(WARNING_TYPE):: ERR
    !
    CALL ERR%INIT()
    DO CONCURRENT (R=ONE:WBS%NROW, C=ONE:WBS%NCOL, WBS%FID_ARRAY(C,R) > Z .AND. SID(C,R) < ONE); CALL ERR%ADD(NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL)
    END DO
    !
    IF(ERR%RAISED) CALL ERR%CHECK(HED='FMP WBS ERROR. FOUND WBS ID > 0 BUT THE CORRESPONDING SOIL ID = 0 FOR THE SAME ROW/COLUMN. THE FOLLOWING ARE THE PROBLEM MODEL CELLS:'//NL//'ROW       COLUMN'//NL, OUTPUT=WBS%IOUT, KILL=TRUE, TAIL=NL )
    !
    !!!CHARACTER(:),ALLOCATABLE:: ERROR
    !!!!
    !!!ERROR=NL
    !!!DO CONCURRENT (R=ONE:WBS%NROW, C=ONE:WBS%NCOL, WBS%FID_ARRAY(C,R) > Z .AND. SID(C,R) < ONE); ERROR = ERROR//NUM2STR(R,-10)//' '//NUM2STR(C,-10)//NL
    !!!END DO
    !!!IF (ERROR.NE.NL) CALL STOP_ERROR(OUTPUT=WBS%LOUT,MSG='FMP WBS ERROR. FOUND FARM ID > 0 BUT THE CORRESPONDING SOIL ID = 0 FOR THE SAME ROW/COLUMN. THE FOLLOWING ARE THE PROBLEM MODEL CELLS:'//NL//'ROW       COLUMN'//ERROR)
    ! 
  END SUBROUTINE
END MODULE
!
!#########################################################################################################
!
